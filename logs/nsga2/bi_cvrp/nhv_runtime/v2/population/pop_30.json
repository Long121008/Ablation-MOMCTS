[
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes, and customers are reallocated to either new route or existing routes to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Find the best split point to split the route\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(2, len(longest_route)-1):\n        # Create two new routes\n        route1 = np.concatenate([longest_route[:split], [0]])\n        route2 = np.concatenate([[0], longest_route[split:-1]])\n\n        if sum(demand[route1[1:-1]]) > capacity or sum(demand[route2[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the new routes\n        total_distance = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                          sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Split the route at the best split point\n    route1 = np.concatenate([longest_route[:best_split], [0]])\n    route2 = np.concatenate([[0], longest_route[best_split:-1]])\n\n    # Replace the original route with the two new routes\n    new_solution.pop(longest_route_idx)\n    new_solution.append(route1)\n    new_solution.append(route2)\n\n    # Reallocate customers between the new routes and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx].copy()\n            if len(route) <= 2:\n                continue\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Try to move the customer to another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    route = np.delete(route, customer_idx)\n                    other_route = np.insert(other_route, -1, customer)\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9224177510870178,
            3.514884978532791
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    }
]