[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: combine route merging and 2-opt with load balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Apply 2-opt on the merged route to improve distance\n            for _ in range(10):  # Limit iterations for efficiency\n                a, b = np.random.choice(len(merged_route) - 2, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if reversing the segment improves distance\n                if sum(distance_matrix[merged_route[a-1:a+1]]) + sum(distance_matrix[merged_route[b:b+2]]) > \\\n                   sum(distance_matrix[merged_route[a-1:a+1][::-1]]) + sum(distance_matrix[merged_route[b:b+2][::-1]]):\n                    merged_route[a:b+1] = merged_route[a:b+1][::-1]\n            new_solution = [merged_route] if i == 0 else [route for route in new_solution if route is not None]\n\n    # Ensure the solution is feasible (capacity constraints)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.842552619113653,
            0.16613224148750305
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of distance and makespan objectives, then applies a novel hybrid local search that combines route splitting, customer relocation with demand-aware positioning, and route merging with angular distance optimization to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.3, 0.7]  # More weight on makespan to balance objectives\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Smart route splitting with angular analysis\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            # Calculate angular differences along the route\n            angles = []\n            for k in range(1, len(route)-2):\n                a = coords[route[k-1]] - coords[route[k]]\n                b = coords[route[k+1]] - coords[route[k]]\n                angle = np.arctan2(np.cross(a, b), np.dot(a, b))\n                angles.append(abs(angle))\n\n            if len(angles) > 0 and max(angles) > np.pi/2:  # Significant angular change\n                split_pos = np.argmax(angles) + 1\n                new_route1 = np.concatenate([route[:split_pos+1], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos+1:-1], [0]])\n\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Step 2: Demand-aware customer relocation with distance optimization\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            # Sort customers in route_i by demand in descending order\n            customers_i = sorted([(k, demand[route_i[k]]) for k in range(1, len(route_i)-1)],\n                               key=lambda x: -x[1])\n\n            for customer_idx, customer_demand in customers_i:\n                customer = route_i[customer_idx]\n                current_demand_j = sum(demand[node] for node in route_j[1:-1])\n\n                if current_demand_j + customer_demand <= capacity:\n                    # Find best insertion position in route_j\n                    best_pos = None\n                    min_increase = float('inf')\n\n                    for pos in range(1, len(route_j)):\n                        prev_node = route_j[pos-1]\n                        next_node = route_j[pos]\n                        increase = (distance_matrix[prev_node, customer] +\n                                   distance_matrix[customer, next_node] -\n                                   distance_matrix[prev_node, next_node])\n\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    if best_pos is not None and min_increase <= distance_matrix[route_j[best_pos-1], route_j[best_pos]] * 0.2:\n                        # Create new routes\n                        new_route_i = np.concatenate([route_i[:customer_idx], route_i[customer_idx+1:]])\n                        new_route_j = np.concatenate([route_j[:best_pos], [customer], route_j[best_pos:]])\n\n                        if len(new_route_i) > 2 and len(new_route_j) > 2:\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            return new_solution\n\n    # Step 3: Route merging with angular distance optimization\n    if len(new_solution) > 1:\n        # Calculate angular distance between routes\n        angular_distances = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n\n                # Vector from last customer of route_i to depot\n                vec_i = coords[0] - coords[route_i[-2]]\n                # Vector from depot to first customer of route_j\n                vec_j = coords[route_j[1]] - coords[0]\n\n                # Calculate angle between vectors\n                angle = np.arctan2(np.cross(vec_i, vec_j), np.dot(vec_i, vec_j))\n                angular_distances.append((i, j, abs(angle)))\n\n        if angular_distances:\n            # Find pair with smallest angular distance\n            best_pair = min(angular_distances, key=lambda x: x[2])\n            i, j = best_pair[0], best_pair[1]\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n\n            if (sum(demand[node] for node in route_i[1:-1]) +\n                sum(demand[node] for node in route_j[1:-1]) <= capacity):\n                # Merge routes with minimal angular connection\n                merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7918424017581615,
            0.7859784662723541
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: combine route merging and 2-opt with load balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Apply 2-opt on the merged route to improve distance\n            for _ in range(10):  # Limit iterations for efficiency\n                a, b = np.random.choice(len(merged_route) - 2, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if reversing the segment improves distance\n                if sum(distance_matrix[merged_route[a-1:a+1]]) + sum(distance_matrix[merged_route[b:b+2]]) > \\\n                   sum(distance_matrix[merged_route[a-1:a+1][::-1]]) + sum(distance_matrix[merged_route[b:b+2][::-1]]):\n                    merged_route[a:b+1] = merged_route[a:b+1][::-1]\n            new_solution = [merged_route] if i == 0 else [route for route in new_solution if route is not None]\n\n    # Ensure the solution is feasible (capacity constraints)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.842552619113653,
            0.16613224148750305
        ]
    }
]