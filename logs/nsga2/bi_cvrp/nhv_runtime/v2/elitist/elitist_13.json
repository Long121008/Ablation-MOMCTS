[
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest makespan from the archive, then applies a demand-balanced route reshaping strategy that redistributes customers across routes while balancing demand and distance, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select a route to reshape\n        i = np.random.choice(len(new_solution))\n        route = new_solution[i]\n        customers = route[1:-1]\n\n        # Calculate demand and distance of the selected route\n        route_demand = sum(demand[customers])\n        route_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n\n        # Split the route into segments based on demand balance\n        split_points = [0]\n        current_demand = 0\n        target_demand = route_demand / (len(new_solution) + 1)  # Target demand per new route\n\n        for idx in range(len(customers)):\n            current_demand += demand[customers[idx]]\n            if current_demand >= target_demand and len(customers) - idx > 1:\n                split_points.append(idx + 1)\n                current_demand = 0\n\n        split_points.append(len(customers))\n        split_routes = []\n\n        for k in range(len(split_points) - 1):\n            start, end = split_points[k], split_points[k + 1]\n            split_route = np.concatenate([[0], customers[start:end], [0]])\n            if sum(demand[split_route[1:-1]]) <= capacity:\n                split_routes.append(split_route)\n\n        # Replace the original route with the split routes\n        new_solution = [route for route in new_solution if not np.array_equal(route, route)]\n        new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6728692338453062,
            0.1202603280544281
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest makespan from the archive, then applies a demand-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a demand-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_demand = sum(demand[customers])\n            avg_demand_per_route = total_demand / (len(new_solution) + 1)  # Target demand per new route\n\n            current_demand = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_demand += demand[customers[idx]]\n                if current_demand > avg_demand_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_demand = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8776352846833095,
            0.13646996021270752
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest makespan from the archive, then applies a demand-balanced route reshaping strategy that redistributes customers across routes by strategically swapping segments between routes while preserving capacity constraints and minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) < 2:\n        return selected_solution.copy()\n\n    # Select the longest route to reshape\n    route_lengths = [sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Find the most balanced route to exchange segments with\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n    demand_diff = [abs(d - route_demands[longest_route_idx]) for d in route_demands]\n    target_route_idx = np.argmin(demand_diff[demand_diff != 0])\n\n    if target_route_idx == longest_route_idx:\n        return selected_solution.copy()\n\n    target_route = new_solution[target_route_idx].copy()\n\n    # Find the best segment to swap\n    best_segment = None\n    min_improvement = float('inf')\n\n    for i in range(1, len(longest_route)-1):\n        for j in range(1, len(target_route)-1):\n            # Check if swapping segments is feasible\n            segment1 = longest_route[i:-1]\n            segment2 = target_route[j:-1]\n\n            if (sum(demand[segment1]) + sum(demand[target_route[1:j]]) <= capacity and\n                sum(demand[segment2]) + sum(demand[longest_route[1:i]]) <= capacity):\n\n                # Calculate potential improvement\n                original_distance = (sum(distance_matrix[longest_route[:-1], longest_route[1:]]) +\n                                   sum(distance_matrix[target_route[:-1], target_route[1:]]))\n                new_distance = (sum(distance_matrix[np.concatenate([[0], longest_route[1:i], target_route[j:-1], [0]])[:-1],\n                                                  np.concatenate([[0], longest_route[1:i], target_route[j:-1], [0]])[1:]]) +\n                              sum(distance_matrix[np.concatenate([[0], target_route[1:j], longest_route[i:-1], [0]])[:-1],\n                                                  np.concatenate([[0], target_route[1:j], longest_route[i:-1], [0]])[1:]]))\n\n                improvement = original_distance - new_distance\n                if improvement < min_improvement:\n                    min_improvement = improvement\n                    best_segment = (i, j)\n\n    if best_segment is not None:\n        i, j = best_segment\n        new_longest_route = np.concatenate([[0], longest_route[1:i], target_route[j:-1], [0]])\n        new_target_route = np.concatenate([[0], target_route[1:j], longest_route[i:-1], [0]])\n\n        new_solution[longest_route_idx] = new_longest_route\n        new_solution[target_route_idx] = new_target_route\n\n    # Check feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8807171094925561,
            0.862873375415802
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a distance-aware route merging and splitting strategy that combines customers from different routes into a single route and then intelligently splits it back into multiple routes while optimizing both objectives, ensuring feasibility with capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Split the merged route into multiple routes using a distance-aware splitting strategy\n            customers = merged_route[1:-1]\n            total_distance = sum(distance_matrix[np.concatenate([[0], customers, [0]])[:-1], np.concatenate([[0], customers, [0]])[1:]])\n            avg_distance_per_route = total_distance / (len(new_solution) + 1)  # Target distance per new route\n\n            current_distance = 0\n            split_points = [0]\n            for idx in range(len(customers)):\n                current_distance += distance_matrix[customers[idx-1] if idx > 0 else 0, customers[idx]]\n                if current_distance > avg_distance_per_route and len(customers) - idx > 1:\n                    split_points.append(idx + 1)\n                    current_distance = 0\n\n            split_points.append(len(customers))\n            split_routes = []\n            for k in range(len(split_points) - 1):\n                start, end = split_points[k], split_points[k + 1]\n                split_route = np.concatenate([[0], customers[start:end], [0]])\n                if sum(demand[split_route[1:-1]]) <= capacity:\n                    split_routes.append(split_route)\n\n            # Replace the merged route with the split routes\n            new_solution = [route for route in new_solution if not np.array_equal(route, merged_route)]\n            new_solution.extend(split_routes)\n\n    # Check feasibility of the new solution\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6806918007897813,
            0.1337893307209015
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    }
]