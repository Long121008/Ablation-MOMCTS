[
    {
        "algorithm": "{A new algorithm that selects a solution with the highest total distance, merges two randomly chosen routes if feasible, applies a load-balanced 2-opt with demand-aware segment reversal, and ensures feasibility by reverting to the original solution if capacity constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            for _ in range(10):\n                a, b = np.random.choice(len(merged_route) - 2, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n\n                segment_demand = sum(demand[merged_route[a:b+1]])\n                if segment_demand <= capacity:\n                    if sum(distance_matrix[merged_route[a-1:a+1]]) + sum(distance_matrix[merged_route[b:b+2]]) > \\\n                       sum(distance_matrix[merged_route[a-1:a+1][::-1]]) + sum(distance_matrix[merged_route[b:b+2][::-1]]):\n                        merged_route[a:b+1] = merged_route[a:b+1][::-1]\n            new_solution = [merged_route] if i == 0 else [route for route in new_solution if route is not None]\n\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7614701755461959,
            0.13811582326889038
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with customer reallocation, where a long route is split into two shorter routes by identifying a high-demand segment and reallocating customers to balance the load while reducing the makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select the longest route to split\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    customers = longest_route[1:-1]\n    cumulative_demand = np.cumsum(demand[customers])\n    split_pos = np.argmax(cumulative_demand) + 1  # +1 to exclude the depot\n\n    # Split the route into two parts\n    route1 = np.concatenate([longest_route[:split_pos+1], [0]])\n    route2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n    # Check feasibility of the split routes\n    if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = route1\n        new_solution.append(route2)\n    else:\n        # If split is infeasible, revert to the original solution\n        return base_solution.copy()\n\n    # Reallocate customers between the two routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        # Randomly select a customer from route1 (excluding depot)\n        if len(route1) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(route1)-1)\n        customer = route1[customer_idx]\n\n        # Try to move the customer to route2\n        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            route1 = np.delete(route1, customer_idx)\n            route2 = np.insert(route2, -1, customer)\n\n    # Update the solution\n    new_solution[longest_route_idx] = route1\n    new_solution.append(route2)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8466710336907324,
            0.39870911836624146
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: combine route merging and 2-opt with load balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Apply 2-opt on the merged route to improve distance\n            for _ in range(10):  # Limit iterations for efficiency\n                a, b = np.random.choice(len(merged_route) - 2, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if reversing the segment improves distance\n                if sum(distance_matrix[merged_route[a-1:a+1]]) + sum(distance_matrix[merged_route[b:b+2]]) > \\\n                   sum(distance_matrix[merged_route[a-1:a+1][::-1]]) + sum(distance_matrix[merged_route[b:b+2][::-1]]):\n                    merged_route[a:b+1] = merged_route[a:b+1][::-1]\n            new_solution = [merged_route] if i == 0 else [route for route in new_solution if route is not None]\n\n    # Ensure the solution is feasible (capacity constraints)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.842552619113653,
            0.16613224148750305
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution with the highest total distance, merges two randomly chosen routes if feasible, applies a load-balanced 2-opt with demand-aware segment reversal, and ensures feasibility by reverting to the original solution if capacity constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            for _ in range(10):\n                a, b = np.random.choice(len(merged_route) - 2, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n\n                segment_demand = sum(demand[merged_route[a:b+1]])\n                if segment_demand <= capacity:\n                    if sum(distance_matrix[merged_route[a-1:a+1]]) + sum(distance_matrix[merged_route[b:b+2]]) > \\\n                       sum(distance_matrix[merged_route[a-1:a+1][::-1]]) + sum(distance_matrix[merged_route[b:b+2][::-1]]):\n                        merged_route[a:b+1] = merged_route[a:b+1][::-1]\n            new_solution = [merged_route] if i == 0 else [route for route in new_solution if route is not None]\n\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7614701755461959,
            0.13811582326889038
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with customer reallocation, where a long route is split into two shorter routes by identifying a high-demand segment and reallocating customers to balance the load while reducing the makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select the longest route to split\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    customers = longest_route[1:-1]\n    cumulative_demand = np.cumsum(demand[customers])\n    split_pos = np.argmax(cumulative_demand) + 1  # +1 to exclude the depot\n\n    # Split the route into two parts\n    route1 = np.concatenate([longest_route[:split_pos+1], [0]])\n    route2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n    # Check feasibility of the split routes\n    if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = route1\n        new_solution.append(route2)\n    else:\n        # If split is infeasible, revert to the original solution\n        return base_solution.copy()\n\n    # Reallocate customers between the two routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        # Randomly select a customer from route1 (excluding depot)\n        if len(route1) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(route1)-1)\n        customer = route1[customer_idx]\n\n        # Try to move the customer to route2\n        if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n            route1 = np.delete(route1, customer_idx)\n            route2 = np.insert(route2, -1, customer)\n\n    # Update the solution\n    new_solution[longest_route_idx] = route1\n    new_solution.append(route2)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8466710336907324,
            0.39870911836624146
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: combine route merging and 2-opt with load balancing\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the routes by inserting route2 into route1\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [merged_route if k == i else route for k, route in enumerate(new_solution) if k != j]\n\n            # Apply 2-opt on the merged route to improve distance\n            for _ in range(10):  # Limit iterations for efficiency\n                a, b = np.random.choice(len(merged_route) - 2, 2, replace=False)\n                if a > b:\n                    a, b = b, a\n                # Check if reversing the segment improves distance\n                if sum(distance_matrix[merged_route[a-1:a+1]]) + sum(distance_matrix[merged_route[b:b+2]]) > \\\n                   sum(distance_matrix[merged_route[a-1:a+1][::-1]]) + sum(distance_matrix[merged_route[b:b+2][::-1]]):\n                    merged_route[a:b+1] = merged_route[a:b+1][::-1]\n            new_solution = [merged_route] if i == 0 else [route for route in new_solution if route is not None]\n\n    # Ensure the solution is feasible (capacity constraints)\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to the original solution\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.842552619113653,
            0.16613224148750305
        ]
    }
]