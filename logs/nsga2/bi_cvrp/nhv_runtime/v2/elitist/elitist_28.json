[
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route inversion with strategic customer relocation, where a selected route is inverted to potentially reduce the makespan, then customers are strategically relocated between routes to balance capacity and minimize both total distance and makespan by considering the spatial proximity of customers.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select a route with high makespan potential\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    selected_route_idx = np.argmax(route_lengths)\n    selected_route = new_solution[selected_route_idx].copy()\n\n    # Invert the selected route to potentially reduce makespan\n    inverted_route = np.concatenate([[0], selected_route[-2:0:-1], [0]])\n\n    # Check capacity constraint\n    if sum(demand[inverted_route[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the inverted route\n    new_solution[selected_route_idx] = inverted_route\n\n    # Relocate customers between routes based on spatial proximity\n    for i in range(10):  # Limit iterations for efficiency\n        if len(new_solution) < 2:\n            break\n\n        # Select a random customer from the inverted route\n        if len(inverted_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(inverted_route)-1)\n        customer = inverted_route[customer_idx]\n\n        # Find the nearest route that can accommodate the customer\n        min_distance = float('inf')\n        best_route_idx = -1\n\n        for route_idx in range(len(new_solution)):\n            if route_idx == selected_route_idx:\n                continue\n            route = new_solution[route_idx]\n            if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Calculate the insertion cost\n            for i in range(len(route)-1):\n                insertion_cost = (distance_matrix[route[i], customer] +\n                                distance_matrix[customer, route[i+1]] -\n                                distance_matrix[route[i], route[i+1]])\n                if insertion_cost < min_distance:\n                    min_distance = insertion_cost\n                    best_route_idx = route_idx\n\n        if best_route_idx != -1:\n            # Find the best insertion position\n            best_insert_pos = 1\n            min_insert_cost = float('inf')\n            for i in range(len(new_solution[best_route_idx])-1):\n                insert_cost = (distance_matrix[new_solution[best_route_idx][i], customer] +\n                             distance_matrix[customer, new_solution[best_route_idx][i+1]] -\n                             distance_matrix[new_solution[best_route_idx][i], new_solution[best_route_idx][i+1]])\n                if insert_cost < min_insert_cost:\n                    min_insert_cost = insert_cost\n                    best_insert_pos = i + 1\n\n            # Insert the customer\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n            inverted_route = np.delete(inverted_route, customer_idx)\n\n            # Update the inverted route\n            new_solution[selected_route_idx] = inverted_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9140927597784447,
            0.7713631689548492
        ]
    },
    {
        "algorithm": "{This new algorithm implements a route splitting and customer reinsertion strategy, where long routes are strategically split into multiple shorter routes by identifying critical customers that, when removed, allow the remaining customers to form feasible sub-routes while balancing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Find the best customer to remove that allows splitting\n    best_customer = None\n    best_split_score = float('inf')\n\n    for i in range(1, len(longest_route)-1):\n        customer = longest_route[i]\n        remaining_route = np.delete(longest_route, i)\n\n        # Check if remaining route is feasible\n        if sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate split score (minimize distance increase and balance makespan)\n        original_distance = sum(distance_matrix[longest_route[j], longest_route[j+1]] for j in range(len(longest_route)-1))\n        new_distance = sum(distance_matrix[remaining_route[j], remaining_route[j+1]] for j in range(len(remaining_route)-1))\n\n        # Create potential new route with just the removed customer\n        new_route = np.array([0, customer, 0])\n        split_score = (new_distance - original_distance) + 0.5 * distance_matrix[0, customer]\n\n        if split_score < best_split_score:\n            best_split_score = split_score\n            best_customer = customer\n\n    if best_customer is None:\n        return base_solution.copy()\n\n    # Split the route\n    customer_idx = np.where(longest_route == best_customer)[0][0]\n    remaining_route = np.delete(longest_route, customer_idx)\n    new_route = np.array([0, best_customer, 0])\n\n    new_solution[longest_route_idx] = remaining_route\n    new_solution.append(new_route)\n\n    # Reinsert customers from the new route to other routes if possible\n    for i in range(10):  # Limit iterations for efficiency\n        if len(new_route) <= 2:\n            break\n        customer = new_route[1]\n        new_route = np.delete(new_route, 1)\n\n        # Try to insert into other routes\n        for route_idx in range(len(new_solution)):\n            if route_idx == longest_route_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                min_increase = float('inf')\n                for pos in range(1, len(route)):\n                    increase = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]] -\n                               distance_matrix[route[pos-1], route[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n                route = np.insert(route, best_pos, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the new route\n    new_solution[longest_route_idx] = remaining_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9136323581357221,
            0.4226047992706299
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with strategic customer redistribution, where two short routes are merged into one by identifying a high-demand segment in one route, then reallocating customers between the merged route and other routes to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    second_shortest_route_idx = np.argmin([l if i != shortest_route_idx else float('inf') for i, l in enumerate(route_lengths)])\n\n    first_route = new_solution[shortest_route_idx].copy()\n    second_route = new_solution[second_shortest_route_idx].copy()\n\n    # Check if merging is feasible\n    if sum(demand[first_route[1:-1]]) + sum(demand[second_route[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Merge the two routes\n    merged_route = np.concatenate([first_route[:-1], second_route[1:]])\n\n    # Replace the two routes with the merged route\n    new_solution.pop(max(shortest_route_idx, second_shortest_route_idx))\n    new_solution.pop(min(shortest_route_idx, second_shortest_route_idx))\n    new_solution.append(merged_route)\n\n    # Reallocate customers to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to a new route\n        for route in new_solution:\n            if route is not merged_route and sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                new_solution[new_solution.index(route)] = np.insert(route, -1, customer)\n                break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8852405724661682,
            0.12507635354995728
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the highest makespan from the archive, then applies a hybrid route segmentation and rebalancing strategy that intelligently segments the longest route into multiple smaller routes and rebalances customers across all routes to minimize both total distance and makespan while ensuring feasibility through capacity checks and reverting to the original solution if constraints are violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) < 2:\n        return selected_solution.copy()\n\n    # Select the longest route to segment\n    longest_route_idx = np.argmax([len(route) - 2 for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Segment the longest route into multiple smaller routes using a demand-aware strategy\n    customers = longest_route[1:-1]\n    total_demand = sum(demand[customers])\n    num_segments = max(1, int(np.ceil(total_demand / capacity)))\n\n    if num_segments == 1:\n        return selected_solution.copy()\n\n    # Split the customers into segments with balanced demand\n    segment_demands = [0] * num_segments\n    segments = [[] for _ in range(num_segments)]\n    segment_idx = 0\n\n    for customer in customers:\n        if segment_demands[segment_idx] + demand[customer] > capacity:\n            segment_idx += 1\n            if segment_idx >= num_segments:\n                break\n        segments[segment_idx].append(customer)\n        segment_demands[segment_idx] += demand[customer]\n\n    # Create new routes from the segments\n    new_routes = []\n    for segment in segments:\n        if len(segment) > 0:\n            new_route = np.concatenate([[0], segment, [0]])\n            new_routes.append(new_route)\n\n    # Replace the longest route with the new routes\n    new_solution[longest_route_idx] = new_routes[0]\n    for route in new_routes[1:]:\n        new_solution.append(route)\n\n    # Rebalance customers between routes to optimize both objectives\n    for _ in range(10):  # Limit iterations for efficiency\n        # Select a random route to modify\n        route_idx = np.random.randint(len(new_solution))\n        route = new_solution[route_idx].copy()\n\n        if len(route) <= 2:\n            continue\n\n        # Randomly select a customer to move\n        customer_idx = np.random.randint(1, len(route)-1)\n        customer = route[customer_idx]\n\n        # Find the best target route to move the customer to\n        best_route_idx = -1\n        min_distance_increase = float('inf')\n\n        for target_idx in range(len(new_solution)):\n            if target_idx == route_idx:\n                continue\n            target_route = new_solution[target_idx].copy()\n\n            if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Calculate the distance increase if moved\n            prev_node = route[customer_idx - 1]\n            next_node = route[customer_idx + 1]\n            distance_removed = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n            target_prev_node = target_route[-2]\n            target_next_node = 0\n            distance_added = distance_matrix[target_prev_node, customer] + distance_matrix[customer, target_next_node]\n\n            distance_increase = distance_added - distance_removed\n\n            if distance_increase < min_distance_increase:\n                min_distance_increase = distance_increase\n                best_route_idx = target_idx\n\n        if best_route_idx != -1:\n            # Perform the move\n            target_route = new_solution[best_route_idx].copy()\n            new_solution[route_idx] = np.delete(route, customer_idx)\n            new_solution[best_route_idx] = np.insert(target_route, -1, customer)\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.882662697278869,
            0.10308289527893066
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6461963431058788,
            0.07186675071716309
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with customer reallocation, where two shorter routes are merged into one longer route by strategically selecting a split point that balances the load while minimizing the makespan and total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select two shortest routes to merge\n    route_lengths = [len(route) - 2 for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    route1_idx, route2_idx = shortest_route_indices[0], shortest_route_indices[1]\n    route1, route2 = new_solution[route1_idx].copy(), new_solution[route2_idx].copy()\n\n    # Find the best split point to merge\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(1, len(route1)):\n        # Create merged route\n        merged_route = np.concatenate([route1[:split], route2[1:-1], route1[split:]])\n        if sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the merged route\n        total_distance = 0\n        for i in range(len(merged_route) - 1):\n            total_distance += distance_matrix[merged_route[i], merged_route[i+1]]\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Merge the routes at the best split point\n    merged_route = np.concatenate([route1[:best_split], route2[1:-1], route1[best_split:]])\n    new_solution[route1_idx] = merged_route\n    new_solution.pop(route2_idx)\n\n    # Reallocate customers between the merged route and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == route1_idx:\n                continue\n            route = new_solution[route_idx].copy()\n            if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                route = np.insert(route, -1, customer)\n                new_solution[route_idx] = route\n                break\n\n    # Update the merged route\n    new_solution[route1_idx] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9170505233040438,
            1.033637374639511
        ]
    }
]