[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    median_makespan = np.median(makespans)\n    candidates = [sol for sol, obj in archive if obj[1] <= median_makespan]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    selected_solution = min(candidates, key=lambda sol: sum(distance_matrix[route[:-1], route[1:]].sum() for route in sol))\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting - split long routes into two if feasible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand <= capacity * 0.8:  # Only split if demand is low\n                split_pos = len(route) // 2\n                # Create two new routes\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n                # Check feasibility\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break  # Only split one route per iteration\n\n    # Step 2: Customer relocation - move customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            # Try to move each customer from route_i to route_j\n            for k in range(1, len(route_i)-1):\n                customer = route_i[k]\n                # Check if moving customer to route_j is feasible\n                if sum(demand[node] for node in route_j[1:-1]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_route_i = np.concatenate([route_i[:k], route_i[k+1:]])\n                    new_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n                    # Check if routes are valid (length > 2)\n                    if len(new_route_i) > 2 and len(new_route_j) > 2:\n                        # Calculate change in total distance\n                        old_dist = (distance_matrix[route_i[k-1], route_i[k]] +\n                                    distance_matrix[route_i[k], route_i[k+1]] +\n                                    distance_matrix[route_j[-2], 0] +\n                                    distance_matrix[0, route_j[1]])\n                        new_dist = (distance_matrix[route_i[k-1], route_i[k+1]] +\n                                   distance_matrix[route_j[-2], customer] +\n                                   distance_matrix[customer, 0] +\n                                   distance_matrix[0, customer])\n                        # Only accept if distance doesn't increase significantly\n                        if new_dist <= old_dist * 1.1:\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            return new_solution\n\n    # Step 3: Route merging - merge short routes if feasible\n    if len(new_solution) > 1:\n        # Find the pair of routes with the smallest combined distance\n        min_merge_cost = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                # Check if merging is feasible\n                if (sum(demand[node] for node in route_i[1:-1]) +\n                    sum(demand[node] for node in route_j[1:-1]) <= capacity):\n                    # Calculate merge cost\n                    merge_cost = (distance_matrix[route_i[-2], 0] +\n                                 distance_matrix[0, route_j[1]] +\n                                 distance_matrix[route_i[-2], route_j[1]])\n                    if merge_cost < min_merge_cost:\n                        min_merge_cost = merge_cost\n                        best_pair = (i, j)\n        if best_pair:\n            i, j = best_pair\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            # Create merged route\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            # Replace the two routes with the merged one\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7681715648155978,
            0.3784652650356293
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with a high total distance and makespan, then applies a hybrid local search strategy combining route splitting, customer reinsertion with distance-aware evaluation, and a novel \"route fusion\" operator to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Route splitting - split long routes into smaller ones\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Only consider routes with more than 2 customers\n            split_pos = random.randint(1, len(route)-2)\n            new_route1 = np.concatenate([route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], route[split_pos:]])\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    # Step 2: Distance-aware customer reinsertion\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with at least one customer\n            # Select a random customer to remove\n            remove_pos = random.randint(1, len(route)-2)\n            customer = route[remove_pos]\n            # Remove the customer\n            new_route = np.concatenate([route[:remove_pos], route[remove_pos+1:]])\n            # Find the best position to reinsert\n            best_pos = 1\n            min_increase = float('inf')\n            for pos in range(1, len(new_route)):\n                # Calculate the increase in distance\n                prev_node = new_route[pos-1]\n                next_node = new_route[pos]\n                increase = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n                if increase < min_increase and (sum(demand[new_route[1:pos]]) + demand[customer] <= capacity):\n                    min_increase = increase\n                    best_pos = pos\n            # Reinsert the customer at the best position\n            new_route = np.concatenate([new_route[:best_pos], [customer], new_route[best_pos:]])\n            new_solution[i] = new_route\n\n    # Step 3: Route fusion - merge small routes if beneficial\n    if len(new_solution) > 1:\n        # Select two random routes to consider fusion\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        # Check if fusion is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Calculate the distance savings if fused\n            original_dist = distance_matrix[route1[-2]][0] + distance_matrix[route2[-2]][0]\n            fused_dist = distance_matrix[route1[-2]][route2[1]] + distance_matrix[route2[-2]][0]\n            if fused_dist < original_dist:\n                # Perform fusion\n                fused_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[i] = fused_route\n                new_solution.pop(j)\n\n    return new_solution\n\n",
        "score": [
            -0.7677402437204395,
            0.5371992588043213
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    median_makespan = np.median(makespans)\n    candidates = [sol for sol, obj in archive if obj[1] <= median_makespan]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    selected_solution = min(candidates, key=lambda sol: sum(distance_matrix[route[:-1], route[1:]].sum() for route in sol))\n\n    # Create a copy of the selected solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search steps\n    # Step 1: Route splitting - split long routes into two if feasible\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            total_demand = sum(demand[node] for node in route[1:-1])\n            if total_demand <= capacity * 0.8:  # Only split if demand is low\n                split_pos = len(route) // 2\n                # Create two new routes\n                new_route1 = np.concatenate([route[:split_pos], [0]])\n                new_route2 = np.concatenate([[0], route[split_pos:-1], [0]])\n                # Check feasibility\n                if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                    sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break  # Only split one route per iteration\n\n    # Step 2: Customer relocation - move customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            # Try to move each customer from route_i to route_j\n            for k in range(1, len(route_i)-1):\n                customer = route_i[k]\n                # Check if moving customer to route_j is feasible\n                if sum(demand[node] for node in route_j[1:-1]) + demand[customer] <= capacity:\n                    # Create new routes\n                    new_route_i = np.concatenate([route_i[:k], route_i[k+1:]])\n                    new_route_j = np.concatenate([route_j[:-1], [customer], [0]])\n                    # Check if routes are valid (length > 2)\n                    if len(new_route_i) > 2 and len(new_route_j) > 2:\n                        # Calculate change in total distance\n                        old_dist = (distance_matrix[route_i[k-1], route_i[k]] +\n                                    distance_matrix[route_i[k], route_i[k+1]] +\n                                    distance_matrix[route_j[-2], 0] +\n                                    distance_matrix[0, route_j[1]])\n                        new_dist = (distance_matrix[route_i[k-1], route_i[k+1]] +\n                                   distance_matrix[route_j[-2], customer] +\n                                   distance_matrix[customer, 0] +\n                                   distance_matrix[0, customer])\n                        # Only accept if distance doesn't increase significantly\n                        if new_dist <= old_dist * 1.1:\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            return new_solution\n\n    # Step 3: Route merging - merge short routes if feasible\n    if len(new_solution) > 1:\n        # Find the pair of routes with the smallest combined distance\n        min_merge_cost = float('inf')\n        best_pair = None\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                # Check if merging is feasible\n                if (sum(demand[node] for node in route_i[1:-1]) +\n                    sum(demand[node] for node in route_j[1:-1]) <= capacity):\n                    # Calculate merge cost\n                    merge_cost = (distance_matrix[route_i[-2], 0] +\n                                 distance_matrix[0, route_j[1]] +\n                                 distance_matrix[route_i[-2], route_j[1]])\n                    if merge_cost < min_merge_cost:\n                        min_merge_cost = merge_cost\n                        best_pair = (i, j)\n        if best_pair:\n            i, j = best_pair\n            route_i = new_solution[i]\n            route_j = new_solution[j]\n            # Create merged route\n            merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n            # Replace the two routes with the merged one\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7681715648155978,
            0.3784652650356293
        ]
    }
]