[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes by identifying a high-demand segment, then reallocating customers from the original route to the new route to balance capacity and minimize both total distance and makespan.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 1:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [len(route) - 2 for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    long_route = new_solution[longest_route_idx].copy()\n\n    # Find the segment with the highest cumulative demand\n    max_demand_segment = 0\n    best_split_point = 0\n    max_cumulative_demand = 0\n\n    for i in range(1, len(long_route) - 1):\n        segment_demand = sum(demand[long_route[1:i+1]])\n        if segment_demand > max_cumulative_demand:\n            max_cumulative_demand = segment_demand\n            best_split_point = i\n\n    if best_split_point <= 1:\n        return base_solution.copy()\n\n    # Split the route into two parts\n    first_part = long_route[:best_split_point+1]\n    second_part = np.concatenate([[0], long_route[best_split_point+1:]])\n\n    # Check capacity constraints\n    if sum(demand[first_part[1:-1]]) > capacity or sum(demand[second_part[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = first_part\n    new_solution.insert(longest_route_idx + 1, second_part)\n\n    # Reallocate customers between the two new routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        if len(first_part) <= 2 or len(second_part) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(first_part)-1)\n        customer = first_part[customer_idx]\n\n        # Try to move the customer to the second route\n        if sum(demand[second_part[1:-1]]) + demand[customer] <= capacity:\n            first_part = np.delete(first_part, customer_idx)\n            second_part = np.insert(second_part, -1, customer)\n\n    # Update the routes\n    new_solution[longest_route_idx] = first_part\n    new_solution[longest_route_idx + 1] = second_part\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes, and customers are reallocated to either new route or existing routes to optimize both total distance and makespan while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Find the best split point to split the route\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(2, len(longest_route)-1):\n        # Create two new routes\n        route1 = np.concatenate([longest_route[:split], [0]])\n        route2 = np.concatenate([[0], longest_route[split:-1]])\n\n        if sum(demand[route1[1:-1]]) > capacity or sum(demand[route2[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the new routes\n        total_distance = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                          sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Split the route at the best split point\n    route1 = np.concatenate([longest_route[:best_split], [0]])\n    route2 = np.concatenate([[0], longest_route[best_split:-1]])\n\n    # Replace the original route with the two new routes\n    new_solution.pop(longest_route_idx)\n    new_solution.append(route1)\n    new_solution.append(route2)\n\n    # Reallocate customers between the new routes and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx].copy()\n            if len(route) <= 2:\n                continue\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Try to move the customer to another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    route = np.delete(route, customer_idx)\n                    other_route = np.insert(other_route, -1, customer)\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The new algorithm combines route merging with strategic customer redistribution, where two short routes are merged into one longer route, and customers are intelligently redistributed between the new route and other routes to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select the two shortest routes to merge\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    remaining_lengths = route_lengths.copy()\n    remaining_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(remaining_lengths)\n\n    route1 = new_solution[shortest_route_idx1].copy()\n    route2 = new_solution[shortest_route_idx2].copy()\n\n    # Check if merging is feasible\n    if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Merge the two routes\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Replace the two routes with the merged route\n    new_solution.pop(max(shortest_route_idx1, shortest_route_idx2))\n    new_solution.pop(min(shortest_route_idx1, shortest_route_idx2))\n    new_solution.append(merged_route)\n\n    # Redistribute customers between the merged route and other routes\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == len(new_solution) - 1:  # Skip the merged route itself\n                continue\n            other_route = new_solution[route_idx].copy()\n            if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                other_route = np.insert(other_route, -1, customer)\n                new_solution[route_idx] = other_route\n                break\n\n    # Update the merged route\n    new_solution[-1] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5955908150557748,
            1.5011207461357117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select the two shortest routes to merge\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    remaining_lengths = route_lengths.copy()\n    remaining_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(remaining_lengths)\n\n    route1 = new_solution[shortest_route_idx1].copy()\n    route2 = new_solution[shortest_route_idx2].copy()\n\n    # Check if merging is feasible\n    if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Merge the two routes\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Replace the two routes with the merged route\n    new_solution.pop(max(shortest_route_idx1, shortest_route_idx2))\n    new_solution.pop(min(shortest_route_idx1, shortest_route_idx2))\n    new_solution.append(merged_route)\n\n    # Redistribute customers between the merged route and other routes\n    for i in range(10):  # Limit iterations for efficiency\n        if len(merged_route) <= 2:\n            break\n        customer_idx = np.random.randint(1, len(merged_route)-1)\n        customer = merged_route[customer_idx]\n\n        # Try to move the customer to another route\n        for route_idx in range(len(new_solution)):\n            if route_idx == len(new_solution) - 1:  # Skip the merged route itself\n                continue\n            other_route = new_solution[route_idx].copy()\n            if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                merged_route = np.delete(merged_route, customer_idx)\n                other_route = np.insert(other_route, -1, customer)\n                new_solution[route_idx] = other_route\n                break\n\n    # Update the merged route\n    new_solution[-1] = merged_route\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines route splitting with strategic customer insertion, where a long route is split into two shorter routes, and customers are reallocated to either new route or existing routes to optimize both total distance and makespan while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select the longest route to split\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Find the best split point to split the route\n    best_split = 0\n    min_total_distance = float('inf')\n\n    for split in range(2, len(longest_route)-1):\n        # Create two new routes\n        route1 = np.concatenate([longest_route[:split], [0]])\n        route2 = np.concatenate([[0], longest_route[split:-1]])\n\n        if sum(demand[route1[1:-1]]) > capacity or sum(demand[route2[1:-1]]) > capacity:\n            continue\n\n        # Calculate total distance of the new routes\n        total_distance = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                          sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            best_split = split\n\n    if best_split == 0:\n        return base_solution.copy()\n\n    # Split the route at the best split point\n    route1 = np.concatenate([longest_route[:best_split], [0]])\n    route2 = np.concatenate([[0], longest_route[best_split:-1]])\n\n    # Replace the original route with the two new routes\n    new_solution.pop(longest_route_idx)\n    new_solution.append(route1)\n    new_solution.append(route2)\n\n    # Reallocate customers between the new routes and other routes to balance load\n    for i in range(10):  # Limit iterations for efficiency\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx].copy()\n            if len(route) <= 2:\n                continue\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Try to move the customer to another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    route = np.delete(route, customer_idx)\n                    other_route = np.insert(other_route, -1, customer)\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The new algorithm combines route merging with strategic customer redistribution, where two short routes are merged into one, and customers are reallocated to existing routes to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select the two shortest routes to merge\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    shortest_route1 = new_solution[shortest_route_indices[0]].copy()\n    shortest_route2 = new_solution[shortest_route_indices[1]].copy()\n\n    # Combine the two routes\n    merged_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    if sum(demand[merged_route[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the two routes with the merged route\n    new_solution.pop(shortest_route_indices[1])\n    new_solution.pop(shortest_route_indices[0])\n    new_solution.append(merged_route)\n\n    # Redistribute customers to balance load and reduce total distance\n    for i in range(10):  # Limit iterations for efficiency\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx].copy()\n            if len(route) <= 2:\n                continue\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Try to move the customer to another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    route = np.delete(route, customer_idx)\n                    other_route = np.insert(other_route, -1, customer)\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6214937569935646,
            0.8202908039093018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) < 2:\n        return base_solution.copy()\n\n    # Select the two shortest routes to merge\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    shortest_route_indices = np.argsort(route_lengths)[:2]\n    shortest_route1 = new_solution[shortest_route_indices[0]].copy()\n    shortest_route2 = new_solution[shortest_route_indices[1]].copy()\n\n    # Combine the two routes\n    merged_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    if sum(demand[merged_route[1:-1]]) > capacity:\n        return base_solution.copy()\n\n    # Replace the two routes with the merged route\n    new_solution.pop(shortest_route_indices[1])\n    new_solution.pop(shortest_route_indices[0])\n    new_solution.append(merged_route)\n\n    # Redistribute customers to balance load and reduce total distance\n    for i in range(10):  # Limit iterations for efficiency\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx].copy()\n            if len(route) <= 2:\n                continue\n            customer_idx = np.random.randint(1, len(route)-1)\n            customer = route[customer_idx]\n\n            # Try to move the customer to another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx == route_idx:\n                    continue\n                other_route = new_solution[other_route_idx].copy()\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    route = np.delete(route, customer_idx)\n                    other_route = np.insert(other_route, -1, customer)\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n                    break\n\n    # Ensure feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            return base_solution.copy()\n\n    return new_solution\n\n"
    }
]