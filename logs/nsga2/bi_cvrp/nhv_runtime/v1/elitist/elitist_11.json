[
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel \"route clustering and sequential insertion\" approach that combines adaptive route clustering based on spatial proximity with a demand-aware sequential insertion heuristic to optimize both distance and makespan while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route centers for clustering\n    route_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n        else:\n            route_centers.append(np.zeros(2))\n\n    # Cluster routes based on spatial proximity\n    if len(new_solution) > 1:\n        # Find the most isolated route\n        max_dist = -1\n        isolated_idx = 0\n        for i in range(len(new_solution)):\n            min_dist = min([np.linalg.norm(route_centers[i] - route_centers[j])\n                          for j in range(len(new_solution)) if j != i])\n            if min_dist > max_dist:\n                max_dist = min_dist\n                isolated_idx = i\n\n        isolated_route = new_solution[isolated_idx]\n        customers = isolated_route[1:-1]\n\n        # Create new solution without the isolated route\n        new_solution.pop(isolated_idx)\n\n        # Attempt to reinsert customers into nearby routes\n        for customer in customers:\n            best_improvement = 0\n            best_insert_pos = None\n            best_route_idx = None\n\n            for route_idx, route in enumerate(new_solution):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position\n                for pos in range(1, len(route)):\n                    # Calculate insertion cost\n                    old_dist = distance_matrix[route[pos-1], route[pos]]\n                    new_dist = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n                        best_route_idx = route_idx\n\n            # Perform the best insertion if found\n            if best_route_idx is not None:\n                route = new_solution[best_route_idx]\n                new_route = np.concatenate([\n                    route[:best_insert_pos],\n                    [customer],\n                    route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_route\n\n        # If any customers couldn't be inserted, create a new route\n        if len(new_solution) < len(base_solution):\n            remaining_customers = []\n            for route in base_solution:\n                if len(route) > 2:\n                    remaining_customers.extend(route[1:-1])\n\n            if remaining_customers:\n                new_route = np.concatenate([[0], remaining_customers, [0]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9220103985383832,
            1.0114791989326477
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel \"route clustering and sequential insertion\" approach that combines adaptive route clustering based on spatial proximity with a demand-aware sequential insertion heuristic to optimize both distance and makespan while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route centers for clustering\n    route_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n        else:\n            route_centers.append(np.zeros(2))\n\n    # Cluster routes based on spatial proximity\n    if len(new_solution) > 1:\n        # Find the most isolated route\n        max_dist = -1\n        isolated_idx = 0\n        for i in range(len(new_solution)):\n            min_dist = min([np.linalg.norm(route_centers[i] - route_centers[j])\n                          for j in range(len(new_solution)) if j != i])\n            if min_dist > max_dist:\n                max_dist = min_dist\n                isolated_idx = i\n\n        isolated_route = new_solution[isolated_idx]\n        customers = isolated_route[1:-1]\n\n        # Create new solution without the isolated route\n        new_solution.pop(isolated_idx)\n\n        # Attempt to reinsert customers into nearby routes\n        for customer in customers:\n            best_improvement = 0\n            best_insert_pos = None\n            best_route_idx = None\n\n            for route_idx, route in enumerate(new_solution):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position\n                for pos in range(1, len(route)):\n                    # Calculate insertion cost\n                    old_dist = distance_matrix[route[pos-1], route[pos]]\n                    new_dist = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n                        best_route_idx = route_idx\n\n            # Perform the best insertion if found\n            if best_route_idx is not None:\n                route = new_solution[best_route_idx]\n                new_route = np.concatenate([\n                    route[:best_insert_pos],\n                    [customer],\n                    route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_route\n\n        # If any customers couldn't be inserted, create a new route\n        if len(new_solution) < len(base_solution):\n            remaining_customers = []\n            for route in base_solution:\n                if len(route) > 2:\n                    remaining_customers.extend(route[1:-1])\n\n            if remaining_customers:\n                new_route = np.concatenate([[0], remaining_customers, [0]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9220103985383832,
            1.0114791989326477
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with adaptive route splitting and merging, incorporating demand-based clustering and distance-aware merging to balance distance and makespan optimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Step 1: Select a route based on demand density\n        demand_densities = [sum(demand[route[1:-1]]) / len(route) if len(route) > 2 else 0 for route in new_solution]\n        rev_route_idx = np.argmax(demand_densities)\n        rev_route = new_solution[rev_route_idx]\n\n        if len(rev_route) > 3:\n            # Step 2: Reverse the route and find optimal split point\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            cumulative_demand = np.cumsum(demand[reversed_route[1:-1]])\n            split_pos = np.argmin(np.abs(cumulative_demand - capacity/2)) + 1\n\n            first_part = reversed_route[:split_pos + 1]\n            second_part = reversed_route[split_pos:]\n\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[rev_route_idx] = first_part\n                new_solution.insert(rev_route_idx + 1, second_part)\n\n                # Step 3: Merge with the closest feasible route\n                if len(new_solution) > 2:\n                    candidate_routes = [i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1]\n                    if candidate_routes:\n                        last_node_first = first_part[-2]\n                        last_node_second = second_part[-2]\n\n                        merge_candidates = []\n                        for i in candidate_routes:\n                            candidate_route = new_solution[i]\n                            first_node = candidate_route[1]\n                            last_node = candidate_route[-2]\n\n                            dist_to_first = distance_matrix[last_node_first][first_node]\n                            dist_to_last = distance_matrix[last_node_second][last_node]\n\n                            merge_candidates.append((i, dist_to_first + dist_to_last))\n\n                        merge_candidates.sort(key=lambda x: x[1])\n                        for candidate_idx, _ in merge_candidates:\n                            candidate_route = new_solution[candidate_idx]\n                            combined_route = np.concatenate([candidate_route[:-1], second_part[1:]])\n\n                            if check_capacity(combined_route):\n                                new_solution[candidate_idx] = combined_route\n                                new_solution.pop(rev_route_idx + 1)\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.8097662771981953,
            0.11018463969230652
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines route reversal with capacity-aware route splitting and merging, while incorporating a dynamic scoring mechanism to prioritize solutions with balanced distance and makespan improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    def score_solution(solution, objectives):\n        total_dist, makespan = objectives\n        # Prioritize solutions with high makespan reduction potential\n        score = (1 / (makespan + 1e-6)) * (1 / (total_dist + 1e-6))\n        return score\n\n    # Select the most promising solution based on the score\n    scored_solutions = [(score_solution(sol, obj), sol, obj) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes with capacity awareness\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7637791628386918,
            0.053460150957107544
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with capacity-aware route splitting and merging to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Reverse and split routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route and reverse it\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx]\n        if len(rev_route) > 3:  # Ensure we can reverse meaningfully\n            reversed_route = np.concatenate([[0], rev_route[-2:0:-1], [0]])\n            new_solution[rev_route_idx] = reversed_route\n\n            # Step 2: Check if splitting the reversed route is beneficial\n            if len(reversed_route) > 4:\n                split_pos = random.randint(2, len(reversed_route) - 3)\n                first_part = reversed_route[:split_pos + 1]\n                second_part = reversed_route[split_pos:]\n\n                # Check capacity feasibility for both parts\n                def check_capacity(route):\n                    return sum(demand[route[1:-1]]) <= capacity\n\n                if check_capacity(first_part) and check_capacity(second_part):\n                    new_solution[rev_route_idx] = first_part\n                    new_solution.insert(rev_route_idx + 1, second_part)\n\n                    # Step 3: Attempt to merge with another route if possible\n                    if len(new_solution) > 2:\n                        merge_candidate = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx and i != rev_route_idx + 1])\n                        candidate_route = new_solution[merge_candidate]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[rev_route_idx + 1][1:]])\n\n                        if check_capacity(combined_route):\n                            new_solution[merge_candidate] = combined_route\n                            new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7271908651038972,
            0.038024723529815674
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation with demand-aware route merging and intelligent insertion, using a combined score function to balance distance and makespan reduction while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], -x[1][0]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Demand-aware fragmentation and merging\n    if len(new_solution) > 1:\n        # Step 1: Select a route with high demand concentration\n        demand_ratios = [sum(demand[route[1:-1]]) / len(route) if len(route) > 2 else 0 for route in new_solution]\n        frag_route_idx = np.argmax(demand_ratios)\n        frag_route = new_solution[frag_route_idx]\n\n        if len(frag_route) > 4:\n            # Step 2: Find optimal split point based on demand balance\n            total_demand = sum(demand[frag_route[1:-1]])\n            split_pos = 1\n            min_diff = float('inf')\n\n            for i in range(2, len(frag_route) - 2):\n                current_demand = sum(demand[frag_route[1:i]])\n                diff = abs(2 * current_demand - total_demand)\n                if diff < min_diff:\n                    min_diff = diff\n                    split_pos = i\n\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 3: Check capacity feasibility\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 4: Intelligent merging with demand-aware selection\n                if len(new_solution) > 2:\n                    # Calculate potential merging scores\n                    scores = []\n                    for i in range(len(new_solution)):\n                        if i != frag_route_idx and i != frag_route_idx + 1:\n                            route = new_solution[i]\n                            combined_route = np.concatenate([route[:-1], new_solution[frag_route_idx + 1][1:]])\n                            if check_capacity(combined_route):\n                                # Score based on demand balance and distance reduction\n                                current_demand = sum(demand[route[1:-1]])\n                                new_demand = sum(demand[new_solution[frag_route_idx + 1][1:-1]])\n                                demand_diff = abs(current_demand - new_demand)\n                                dist_reduction = distance_matrix[route[-2], new_solution[frag_route_idx + 1][1]] + \\\n                                                distance_matrix[new_solution[frag_route_idx + 1][-2], route[-2]] - \\\n                                                distance_matrix[route[-2], route[-2]] - \\\n                                                distance_matrix[new_solution[frag_route_idx + 1][1], new_solution[frag_route_idx + 1][1]]\n                                score = demand_diff + dist_reduction\n                                scores.append((score, i))\n\n                    if scores:\n                        best_score, best_idx = min(scores, key=lambda x: x[0])\n                        candidate_route = new_solution[best_idx]\n                        combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n                        new_solution[best_idx] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.8877584424107394,
            0.11397606134414673
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route reversal with demand-aware route splitting and insertion to balance distance minimization and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    def check_capacity(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if len(new_solution) > 1:\n        # Step 1: Randomly select a route to reverse\n        rev_route_idx = random.randint(0, len(new_solution) - 1)\n        rev_route = new_solution[rev_route_idx].copy()\n        rev_route[1:-1] = rev_route[-2:0:-1]\n\n        # Step 2: Split the reversed route into two parts based on demand balance\n        if len(rev_route) > 4:\n            total_demand = sum(demand[rev_route[1:-1]])\n            split_pos = 1\n            current_demand = 0\n            for i in range(1, len(rev_route) - 2):\n                current_demand += demand[rev_route[i]]\n                if current_demand >= total_demand / 2:\n                    split_pos = i\n                    break\n\n            first_part = rev_route[:split_pos + 1]\n            second_part = rev_route[split_pos:]\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[rev_route_idx] = first_part\n                new_solution.insert(rev_route_idx + 1, second_part)\n\n                # Step 3: Insert the second part into another route if beneficial\n                if len(new_solution) > 2:\n                    target_route_idx = random.choice([i for i in range(len(new_solution)) if i != rev_route_idx])\n                    target_route = new_solution[target_route_idx].copy()\n\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for i in range(1, len(target_route)):\n                        inserted_route = np.concatenate([\n                            target_route[:i],\n                            second_part[1:-1],\n                            target_route[i:]\n                        ])\n\n                        if check_capacity(inserted_route):\n                            cost = (sum(distance_matrix[inserted_route[:-1], inserted_route[1:]]) +\n                                    sum(distance_matrix[inserted_route[-2:], inserted_route[1:2]]))\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = i\n\n                    if best_pos != 1:\n                        inserted_route = np.concatenate([\n                            target_route[:best_pos],\n                            second_part[1:-1],\n                            target_route[best_pos:]\n                        ])\n                        new_solution[target_route_idx] = inserted_route\n                        new_solution.pop(rev_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.8048702169252595,
            0.10750618577003479
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    }
]