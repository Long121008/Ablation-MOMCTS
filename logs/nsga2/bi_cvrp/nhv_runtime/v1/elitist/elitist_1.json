[
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a route to modify\n    if len(new_solution) > 1:\n        route_idx = np.random.randint(0, len(new_solution))\n        selected_route = new_solution[route_idx]\n\n        # Split the route into two parts at a random customer\n        split_pos = np.random.randint(1, len(selected_route) - 1)\n        route1 = selected_route[:split_pos + 1]\n        route2 = selected_route[split_pos:]\n\n        # Check capacity constraints for both new routes\n        demand1 = np.sum(demand[route1[1:-1]])\n        demand2 = np.sum(demand[route2[1:-1]])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx + 1, route2)\n\n        # Randomly reallocate a customer from one route to another\n        if len(new_solution) > 1:\n            from_route_idx = np.random.randint(0, len(new_solution))\n            to_route_idx = np.random.randint(0, len(new_solution))\n            if from_route_idx != to_route_idx and len(new_solution[from_route_idx]) > 2:\n                from_route = new_solution[from_route_idx]\n                to_route = new_solution[to_route_idx]\n\n                # Select a random customer to move\n                customer_idx = np.random.randint(1, len(from_route) - 1)\n                customer = from_route[customer_idx]\n\n                # Check capacity constraint for the target route\n                if np.sum(demand[to_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert the customer into the target route at a random position\n                    insert_pos = np.random.randint(1, len(to_route))\n                    new_to_route = np.insert(to_route, insert_pos, customer)\n                    new_from_route = np.delete(from_route, customer_idx)\n\n                    # Update the solution\n                    new_solution[from_route_idx] = new_from_route\n                    new_solution[to_route_idx] = new_to_route\n\n        # Randomly reorder a segment within a route\n        for route in new_solution:\n            if len(route) > 3:\n                start = np.random.randint(1, len(route) - 2)\n                end = np.random.randint(start + 1, len(route))\n                segment = route[start:end]\n                np.random.shuffle(segment)\n                route[start:end] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7005218798675689,
            0.14733517169952393
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    }
]