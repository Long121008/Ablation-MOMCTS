[
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route rebalancing with capacity-aware customer swapping to optimize both total distance and makespan while ensuring feasibility through a multi-phase improvement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route metrics\n    route_metrics = []\n    for route in new_solution:\n        route_demand = sum(demand[route[1:-1]])\n        route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n        route_metrics.append((route_demand, route_distance, len(route)))\n\n    # Phase 1: Adaptive route rebalancing\n    if len(new_solution) > 1:\n        # Find routes with demand imbalance\n        avg_demand = sum(m[0] for m in route_metrics) / len(new_solution)\n        underutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d < avg_demand]\n        overutilized = [i for i, (d, _, _) in enumerate(route_metrics) if d > avg_demand]\n\n        if underutilized and overutilized:\n            under_idx = random.choice(underutilized)\n            over_idx = random.choice(overutilized)\n\n            # Attempt to transfer customers\n            over_route = new_solution[over_idx]\n            candidates = [i for i in range(1, len(over_route)-1) if\n                         sum(demand[over_route[1:i]]) + sum(demand[over_route[i+1:-1]]) <= capacity]\n\n            if candidates:\n                transfer_idx = random.choice(candidates)\n                customer = over_route[transfer_idx]\n\n                # Check capacity for underutilized route\n                under_route = new_solution[under_idx]\n                if sum(demand[under_route[1:-1]]) + demand[customer] <= capacity:\n                    # Update routes\n                    new_over_route = np.concatenate([over_route[:transfer_idx], over_route[transfer_idx+1:]])\n                    new_under_route = np.concatenate([under_route[:-1], [customer], [0]])\n\n                    # Verify distance improvement\n                    old_dist = (sum(distance_matrix[over_route[i], over_route[i+1]] for i in range(len(over_route)-1)) +\n                                sum(distance_matrix[under_route[i], under_route[i+1]] for i in range(len(under_route)-1)))\n                    new_dist = (sum(distance_matrix[new_over_route[i], new_over_route[i+1]] for i in range(len(new_over_route)-1)) +\n                                sum(distance_matrix[new_under_route[i], new_under_route[i+1]] for i in range(len(new_under_route)-1)))\n\n                    if new_dist < old_dist:\n                        new_solution[over_idx] = new_over_route\n                        new_solution[under_idx] = new_under_route\n\n    # Phase 2: Capacity-aware customer swapping\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Find valid swap candidates\n        candidates1 = [i for i in range(1, len(route1)-1) if\n                      sum(demand[route1[1:i]]) + sum(demand[route1[i+1:-1]]) <= capacity and\n                      sum(demand[route2[1:-1]]) + demand[route1[i]] <= capacity]\n        candidates2 = [i for i in range(1, len(route2)-1) if\n                      sum(demand[route2[1:i]]) + sum(demand[route2[i+1:-1]]) <= capacity and\n                      sum(demand[route1[1:-1]]) + demand[route2[i]] <= capacity]\n\n        if candidates1 and candidates2:\n            pos1 = random.choice(candidates1)\n            pos2 = random.choice(candidates2)\n\n            # Create new routes\n            new_route1 = np.concatenate([\n                route1[:pos1],\n                [route2[pos2]],\n                route1[pos1+1:]\n            ])\n            new_route2 = np.concatenate([\n                route2[:pos2],\n                [route1[pos1]],\n                route2[pos2+1:]\n            ])\n\n            # Verify distance improvement\n            old_dist = (sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1)) +\n                        sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1)))\n            new_dist = (sum(distance_matrix[new_route1[i], new_route1[i+1]] for i in range(len(new_route1)-1)) +\n                        sum(distance_matrix[new_route2[i], new_route2[i+1]] for i in range(len(new_route2)-1)))\n\n            if new_dist < old_dist:\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.8941970377257581,
            0.4434971511363983
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    }
]