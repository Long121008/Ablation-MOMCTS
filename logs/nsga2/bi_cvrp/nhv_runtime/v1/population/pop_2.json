[
    {
        "algorithm": "{This algorithm implements a novel hybrid local search that combines adaptive route reversal with capacity-aware subsequence relocation to balance distance reduction and makespan optimization while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], -x[1][1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Adaptive route reversal and subsequence relocation\n    if len(new_solution) > 1:\n        # Step 1: Select a route with high distance and reverse a subsequence\n        route_distances = []\n        for route in new_solution:\n            route_dist = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n            route_distances.append(route_dist)\n\n        high_dist_idx = np.argmax(route_distances)\n        high_dist_route = new_solution[high_dist_idx]\n\n        if len(high_dist_route) > 4:  # Ensure we can reverse a meaningful subsequence\n            start_pos = random.randint(1, len(high_dist_route)-3)\n            end_pos = random.randint(start_pos+1, len(high_dist_route)-2)\n\n            # Reverse the subsequence\n            reversed_sub = high_dist_route[start_pos:end_pos][::-1]\n            modified_route = np.concatenate([\n                high_dist_route[:start_pos],\n                reversed_sub,\n                high_dist_route[end_pos:]\n            ])\n\n            # Check capacity feasibility\n            if sum(demand[modified_route[1:-1]]) <= capacity:\n                new_solution[high_dist_idx] = modified_route\n\n                # Step 2: Relocate a subsequence from this route to another\n                if len(new_solution) > 1:\n                    target_route_idx = random.choice([i for i in range(len(new_solution)) if i != high_dist_idx])\n                    target_route = new_solution[target_route_idx]\n\n                    # Select a subsequence to relocate\n                    sub_start = random.randint(1, len(modified_route)-3)\n                    sub_end = random.randint(sub_start+1, len(modified_route)-2)\n                    subsequence = modified_route[sub_start:sub_end]\n\n                    # Check capacity feasibility for both routes\n                    new_source_route = np.concatenate([\n                        modified_route[:sub_start],\n                        modified_route[sub_end:]\n                    ])\n                    new_target_route = np.concatenate([\n                        target_route[:-1],\n                        subsequence,\n                        [0]\n                    ])\n\n                    if (sum(demand[new_source_route[1:-1]]) <= capacity and\n                        sum(demand[new_target_route[1:-1]]) <= capacity):\n                        new_solution[high_dist_idx] = new_source_route\n                        new_solution[target_route_idx] = new_target_route\n\n    return new_solution\n\n",
        "score": [
            -0.8138782333527369,
            0.29710352420806885
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route fragmentation and insertion with capacity-aware route merging to balance distance and makespan reduction while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Fragment and merge routes\n    if len(new_solution) > 1:\n        # Step 1: Randomly fragment a route into two parts\n        frag_route_idx = random.randint(0, len(new_solution) - 1)\n        frag_route = new_solution[frag_route_idx]\n        if len(frag_route) > 4:  # Ensure we can split meaningfully\n            split_pos = random.randint(2, len(frag_route) - 3)\n            first_part = frag_route[:split_pos + 1]\n            second_part = frag_route[split_pos:]\n\n            # Step 2: Check capacity feasibility for both parts\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[frag_route_idx] = first_part\n                new_solution.insert(frag_route_idx + 1, second_part)\n\n                # Step 3: Attempt to merge with another route if possible\n                if len(new_solution) > 2:\n                    merge_candidate = random.choice([i for i in range(len(new_solution)) if i != frag_route_idx])\n                    candidate_route = new_solution[merge_candidate]\n                    combined_route = np.concatenate([candidate_route[:-1], new_solution[frag_route_idx + 1][1:]])\n\n                    if check_capacity(combined_route):\n                        new_solution[merge_candidate] = combined_route\n                        new_solution.pop(frag_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7480548182022992,
            0.03834328055381775
        ]
    }
]