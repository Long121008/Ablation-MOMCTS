[
    {
        "algorithm": "{This algorithm implements a novel \"route clustering and sequential insertion\" approach that combines adaptive route clustering based on spatial proximity with a demand-aware sequential insertion heuristic to optimize both distance and makespan while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route centers for clustering\n    route_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n        else:\n            route_centers.append(np.zeros(2))\n\n    # Cluster routes based on spatial proximity\n    if len(new_solution) > 1:\n        # Find the most isolated route\n        max_dist = -1\n        isolated_idx = 0\n        for i in range(len(new_solution)):\n            min_dist = min([np.linalg.norm(route_centers[i] - route_centers[j])\n                          for j in range(len(new_solution)) if j != i])\n            if min_dist > max_dist:\n                max_dist = min_dist\n                isolated_idx = i\n\n        isolated_route = new_solution[isolated_idx]\n        customers = isolated_route[1:-1]\n\n        # Create new solution without the isolated route\n        new_solution.pop(isolated_idx)\n\n        # Attempt to reinsert customers into nearby routes\n        for customer in customers:\n            best_improvement = 0\n            best_insert_pos = None\n            best_route_idx = None\n\n            for route_idx, route in enumerate(new_solution):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position\n                for pos in range(1, len(route)):\n                    # Calculate insertion cost\n                    old_dist = distance_matrix[route[pos-1], route[pos]]\n                    new_dist = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n                        best_route_idx = route_idx\n\n            # Perform the best insertion if found\n            if best_route_idx is not None:\n                route = new_solution[best_route_idx]\n                new_route = np.concatenate([\n                    route[:best_insert_pos],\n                    [customer],\n                    route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_route\n\n        # If any customers couldn't be inserted, create a new route\n        if len(new_solution) < len(base_solution):\n            remaining_customers = []\n            for route in base_solution:\n                if len(route) > 2:\n                    remaining_customers.extend(route[1:-1])\n\n            if remaining_customers:\n                new_route = np.concatenate([[0], remaining_customers, [0]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9220103985383832,
            1.0114791989326477
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines route splitting with demand-aware route merging and insertion, prioritizing solutions with balanced distance and makespan to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        if len(split_route) > 4:\n            split_pos = random.randint(2, len(split_route) - 3)\n            first_part = split_route[:split_pos + 1]\n            second_part = split_route[split_pos:]\n\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[split_route_idx] = first_part\n                new_solution.insert(split_route_idx + 1, second_part)\n\n                merge_candidate = random.choice([i for i in range(len(new_solution)) if i != split_route_idx and i != split_route_idx + 1])\n                candidate_route = new_solution[merge_candidate]\n                combined_route = np.concatenate([candidate_route[:-1], new_solution[split_route_idx + 1][1:]])\n\n                if check_capacity(combined_route):\n                    new_solution[merge_candidate] = combined_route\n                    new_solution.pop(split_route_idx + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.809739586151478,
            0.03508865833282471
        ]
    }
]