[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm implements a novel \"route clustering and sequential insertion\" approach that combines adaptive route clustering based on spatial proximity with a demand-aware sequential insertion heuristic to optimize both distance and makespan while maintaining capacity constraints.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route centers for clustering\n    route_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n        else:\n            route_centers.append(np.zeros(2))\n\n    # Cluster routes based on spatial proximity\n    if len(new_solution) > 1:\n        # Find the most isolated route\n        max_dist = -1\n        isolated_idx = 0\n        for i in range(len(new_solution)):\n            min_dist = min([np.linalg.norm(route_centers[i] - route_centers[j])\n                          for j in range(len(new_solution)) if j != i])\n            if min_dist > max_dist:\n                max_dist = min_dist\n                isolated_idx = i\n\n        isolated_route = new_solution[isolated_idx]\n        customers = isolated_route[1:-1]\n\n        # Create new solution without the isolated route\n        new_solution.pop(isolated_idx)\n\n        # Attempt to reinsert customers into nearby routes\n        for customer in customers:\n            best_improvement = 0\n            best_insert_pos = None\n            best_route_idx = None\n\n            for route_idx, route in enumerate(new_solution):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position\n                for pos in range(1, len(route)):\n                    # Calculate insertion cost\n                    old_dist = distance_matrix[route[pos-1], route[pos]]\n                    new_dist = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n                        best_route_idx = route_idx\n\n            # Perform the best insertion if found\n            if best_route_idx is not None:\n                route = new_solution[best_route_idx]\n                new_route = np.concatenate([\n                    route[:best_insert_pos],\n                    [customer],\n                    route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_route\n\n        # If any customers couldn't be inserted, create a new route\n        if len(new_solution) < len(base_solution):\n            remaining_customers = []\n            for route in base_solution:\n                if len(route) > 2:\n                    remaining_customers.extend(route[1:-1])\n\n            if remaining_customers:\n                new_route = np.concatenate([[0], remaining_customers, [0]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm implements a novel \"demand-aware route merging and split\" approach that combines adaptive route clustering based on demand similarity with a spatial-aware split heuristic to optimize both distance and makespan while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Calculate demand profiles for each route\n    route_demands = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_demands.append(np.sum(demand[route[1:-1]]))\n        else:\n            route_demands.append(0)\n\n    # Find two most similar routes based on demand\n    min_diff = float('inf')\n    pair = (0, 1)\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            diff = abs(route_demands[i] - route_demands[j])\n            if diff < min_diff:\n                min_diff = diff\n                pair = (i, j)\n\n    route1, route2 = pair\n    route1_customers = new_solution[route1][1:-1]\n    route2_customers = new_solution[route2][1:-1]\n\n    # Attempt to merge the two routes\n    combined_customers = np.concatenate([route1_customers, route2_customers])\n    combined_demand = np.sum(demand[combined_customers])\n\n    if combined_demand <= capacity:\n        new_route = np.concatenate([[0], combined_customers, [0]])\n        new_solution.pop(max(route1, route2))\n        new_solution.pop(min(route1, route2))\n        new_solution.append(new_route)\n    else:\n        # If merge fails, split the larger route\n        larger_route = route1 if route_demands[route1] > route_demands[route2] else route2\n        customers = new_solution[larger_route][1:-1]\n\n        # Split customers into two groups based on spatial proximity\n        if len(customers) > 1:\n            coords_subset = coords[customers]\n            center = np.mean(coords_subset, axis=0)\n            left_group = []\n            right_group = []\n\n            for i, customer in enumerate(customers):\n                if coords_subset[i, 0] < center[0]:\n                    left_group.append(customer)\n                else:\n                    right_group.append(customer)\n\n            # Create new routes from the groups\n            new_solution.pop(larger_route)\n            if len(left_group) > 0:\n                left_demand = np.sum(demand[left_group])\n                if left_demand <= capacity:\n                    new_route = np.concatenate([[0], left_group, [0]])\n                    new_solution.append(new_route)\n            if len(right_group) > 0:\n                right_demand = np.sum(demand[right_group])\n                if right_demand <= capacity:\n                    new_route = np.concatenate([[0], right_group, [0]])\n                    new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.4479683138332643,
            0.222367525100708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Calculate demand profiles for each route\n    route_demands = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_demands.append(np.sum(demand[route[1:-1]]))\n        else:\n            route_demands.append(0)\n\n    # Find two most similar routes based on demand\n    min_diff = float('inf')\n    pair = (0, 1)\n    for i in range(len(new_solution)):\n        for j in range(i+1, len(new_solution)):\n            diff = abs(route_demands[i] - route_demands[j])\n            if diff < min_diff:\n                min_diff = diff\n                pair = (i, j)\n\n    route1, route2 = pair\n    route1_customers = new_solution[route1][1:-1]\n    route2_customers = new_solution[route2][1:-1]\n\n    # Attempt to merge the two routes\n    combined_customers = np.concatenate([route1_customers, route2_customers])\n    combined_demand = np.sum(demand[combined_customers])\n\n    if combined_demand <= capacity:\n        new_route = np.concatenate([[0], combined_customers, [0]])\n        new_solution.pop(max(route1, route2))\n        new_solution.pop(min(route1, route2))\n        new_solution.append(new_route)\n    else:\n        # If merge fails, split the larger route\n        larger_route = route1 if route_demands[route1] > route_demands[route2] else route2\n        customers = new_solution[larger_route][1:-1]\n\n        # Split customers into two groups based on spatial proximity\n        if len(customers) > 1:\n            coords_subset = coords[customers]\n            center = np.mean(coords_subset, axis=0)\n            left_group = []\n            right_group = []\n\n            for i, customer in enumerate(customers):\n                if coords_subset[i, 0] < center[0]:\n                    left_group.append(customer)\n                else:\n                    right_group.append(customer)\n\n            # Create new routes from the groups\n            new_solution.pop(larger_route)\n            if len(left_group) > 0:\n                left_demand = np.sum(demand[left_group])\n                if left_demand <= capacity:\n                    new_route = np.concatenate([[0], left_group, [0]])\n                    new_solution.append(new_route)\n            if len(right_group) > 0:\n                right_demand = np.sum(demand[right_group])\n                if right_demand <= capacity:\n                    new_route = np.concatenate([[0], right_group, [0]])\n                    new_solution.append(new_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm implements a novel \"route clustering and sequential insertion\" approach that combines adaptive route clustering based on spatial proximity with a demand-aware sequential insertion heuristic to optimize both distance and makespan while maintaining capacity constraints.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route centers for clustering\n    route_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n        else:\n            route_centers.append(np.zeros(2))\n\n    # Cluster routes based on spatial proximity\n    if len(new_solution) > 1:\n        # Find the most isolated route\n        max_dist = -1\n        isolated_idx = 0\n        for i in range(len(new_solution)):\n            min_dist = min([np.linalg.norm(route_centers[i] - route_centers[j])\n                          for j in range(len(new_solution)) if j != i])\n            if min_dist > max_dist:\n                max_dist = min_dist\n                isolated_idx = i\n\n        isolated_route = new_solution[isolated_idx]\n        customers = isolated_route[1:-1]\n\n        # Create new solution without the isolated route\n        new_solution.pop(isolated_idx)\n\n        # Attempt to reinsert customers into nearby routes\n        for customer in customers:\n            best_improvement = 0\n            best_insert_pos = None\n            best_route_idx = None\n\n            for route_idx, route in enumerate(new_solution):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position\n                for pos in range(1, len(route)):\n                    # Calculate insertion cost\n                    old_dist = distance_matrix[route[pos-1], route[pos]]\n                    new_dist = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n                        best_route_idx = route_idx\n\n            # Perform the best insertion if found\n            if best_route_idx is not None:\n                route = new_solution[best_route_idx]\n                new_route = np.concatenate([\n                    route[:best_insert_pos],\n                    [customer],\n                    route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_route\n\n        # If any customers couldn't be inserted, create a new route\n        if len(new_solution) < len(base_solution):\n            remaining_customers = []\n            for route in base_solution:\n                if len(route) > 2:\n                    remaining_customers.extend(route[1:-1])\n\n            if remaining_customers:\n                new_route = np.concatenate([[0], remaining_customers, [0]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm implements a novel \"route clustering and sequential insertion\" approach that combines adaptive route clustering based on spatial proximity with a demand-aware sequential insertion heuristic to optimize both distance and makespan while maintaining capacity constraints.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route centers for clustering\n    route_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n        else:\n            route_centers.append(np.zeros(2))\n\n    # Cluster routes based on spatial proximity\n    if len(new_solution) > 1:\n        # Find the most isolated route\n        max_dist = -1\n        isolated_idx = 0\n        for i in range(len(new_solution)):\n            min_dist = min([np.linalg.norm(route_centers[i] - route_centers[j])\n                          for j in range(len(new_solution)) if j != i])\n            if min_dist > max_dist:\n                max_dist = min_dist\n                isolated_idx = i\n\n        isolated_route = new_solution[isolated_idx]\n        customers = isolated_route[1:-1]\n\n        # Create new solution without the isolated route\n        new_solution.pop(isolated_idx)\n\n        # Attempt to reinsert customers into nearby routes\n        for customer in customers:\n            best_improvement = 0\n            best_insert_pos = None\n            best_route_idx = None\n\n            for route_idx, route in enumerate(new_solution):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position\n                for pos in range(1, len(route)):\n                    # Calculate insertion cost\n                    old_dist = distance_matrix[route[pos-1], route[pos]]\n                    new_dist = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n                        best_route_idx = route_idx\n\n            # Perform the best insertion if found\n            if best_route_idx is not None:\n                route = new_solution[best_route_idx]\n                new_route = np.concatenate([\n                    route[:best_insert_pos],\n                    [customer],\n                    route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_route\n\n        # If any customers couldn't be inserted, create a new route\n        if len(new_solution) < len(base_solution):\n            remaining_customers = []\n            for route in base_solution:\n                if len(route) > 2:\n                    remaining_customers.extend(route[1:-1])\n\n            if remaining_customers:\n                new_route = np.concatenate([[0], remaining_customers, [0]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm implements a hybrid \"route fragmentation and adaptive reinsertion\" approach that combines spatial decomposition with demand-aware fragmentation to create smaller route segments, then intelligently reinserts these segments into existing routes or forms new routes to improve both distance and makespan while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Fragment routes into smaller segments\n    fragmented_segments = []\n    for route in new_solution:\n        if len(route) > 3:  # Only fragment routes with more than 2 customers\n            customers = route[1:-1]\n            # Split route into segments of 2-3 customers\n            for i in range(0, len(customers), 2):\n                segment = customers[i:i+2]\n                if len(segment) > 0:\n                    fragmented_segments.append(segment)\n\n    # Step 2: Remove original fragmented routes\n    new_solution = [route for route in new_solution if len(route) <= 3]\n\n    # Step 3: Reinsert segments with adaptive strategy\n    for segment in fragmented_segments:\n        segment_demand = sum(demand[segment])\n        best_insertion = None\n        best_score = float('inf')\n\n        # Try inserting into existing routes\n        for route_idx, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + segment_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost (distance + makespan impact)\n                old_dist = distance_matrix[route[pos-1], route[pos]]\n                new_dist = (distance_matrix[route[pos-1], segment[0]] +\n                           sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) +\n                           distance_matrix[segment[-1], route[pos]])\n\n                current_makespan = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                new_makespan = (sum(distance_matrix[route[i], route[i+1]] for i in range(pos-1)) +\n                               distance_matrix[route[pos-1], segment[0]] +\n                               sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) +\n                               distance_matrix[segment[-1], route[pos]] +\n                               sum(distance_matrix[route[i], route[i+1]] for i in range(pos, len(route)-1)))\n\n                # Score combines distance and makespan impact\n                score = (new_dist - old_dist) + 0.5 * (new_makespan - current_makespan)\n\n                if score < best_score:\n                    best_score = score\n                    best_insertion = (route_idx, pos)\n\n        # Perform the best insertion\n        if best_insertion is not None:\n            route_idx, pos = best_insertion\n            route = new_solution[route_idx]\n            new_route = np.concatenate([\n                route[:pos],\n                segment,\n                route[pos:]\n            ])\n            new_solution[route_idx] = new_route\n        else:\n            # Create new route if no suitable insertion found\n            new_route = np.concatenate([[0], segment, [0]])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n\n    # Step 4: Merge small routes if possible\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            if len(new_solution[i]) <= 3:  # Small route\n                for j in range(len(new_solution)):\n                    if i != j and len(new_solution[j]) > 3:  # Larger route\n                        route_i = new_solution[i][1:-1]\n                        route_j = new_solution[j][1:-1]\n\n                        if sum(demand[route_i]) + sum(demand[route_j]) <= capacity:\n                            # Try to merge\n                            merged_route = np.concatenate([[0], route_i, route_j, [0]])\n                            new_solution[j] = merged_route\n                            new_solution.pop(i)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.3823242885175507,
            4.937159329652786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Fragment routes into smaller segments\n    fragmented_segments = []\n    for route in new_solution:\n        if len(route) > 3:  # Only fragment routes with more than 2 customers\n            customers = route[1:-1]\n            # Split route into segments of 2-3 customers\n            for i in range(0, len(customers), 2):\n                segment = customers[i:i+2]\n                if len(segment) > 0:\n                    fragmented_segments.append(segment)\n\n    # Step 2: Remove original fragmented routes\n    new_solution = [route for route in new_solution if len(route) <= 3]\n\n    # Step 3: Reinsert segments with adaptive strategy\n    for segment in fragmented_segments:\n        segment_demand = sum(demand[segment])\n        best_insertion = None\n        best_score = float('inf')\n\n        # Try inserting into existing routes\n        for route_idx, route in enumerate(new_solution):\n            if sum(demand[route[1:-1]]) + segment_demand > capacity:\n                continue\n\n            # Evaluate all possible insertion positions\n            for pos in range(1, len(route)):\n                # Calculate insertion cost (distance + makespan impact)\n                old_dist = distance_matrix[route[pos-1], route[pos]]\n                new_dist = (distance_matrix[route[pos-1], segment[0]] +\n                           sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) +\n                           distance_matrix[segment[-1], route[pos]])\n\n                current_makespan = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n                new_makespan = (sum(distance_matrix[route[i], route[i+1]] for i in range(pos-1)) +\n                               distance_matrix[route[pos-1], segment[0]] +\n                               sum(distance_matrix[segment[i], segment[i+1]] for i in range(len(segment)-1)) +\n                               distance_matrix[segment[-1], route[pos]] +\n                               sum(distance_matrix[route[i], route[i+1]] for i in range(pos, len(route)-1)))\n\n                # Score combines distance and makespan impact\n                score = (new_dist - old_dist) + 0.5 * (new_makespan - current_makespan)\n\n                if score < best_score:\n                    best_score = score\n                    best_insertion = (route_idx, pos)\n\n        # Perform the best insertion\n        if best_insertion is not None:\n            route_idx, pos = best_insertion\n            route = new_solution[route_idx]\n            new_route = np.concatenate([\n                route[:pos],\n                segment,\n                route[pos:]\n            ])\n            new_solution[route_idx] = new_route\n        else:\n            # Create new route if no suitable insertion found\n            new_route = np.concatenate([[0], segment, [0]])\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(new_route)\n\n    # Step 4: Merge small routes if possible\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            if len(new_solution[i]) <= 3:  # Small route\n                for j in range(len(new_solution)):\n                    if i != j and len(new_solution[j]) > 3:  # Larger route\n                        route_i = new_solution[i][1:-1]\n                        route_j = new_solution[j][1:-1]\n\n                        if sum(demand[route_i]) + sum(demand[route_j]) <= capacity:\n                            # Try to merge\n                            merged_route = np.concatenate([[0], route_i, route_j, [0]])\n                            new_solution[j] = merged_route\n                            new_solution.pop(i)\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines route splitting with demand-aware route merging and insertion, prioritizing solutions with balanced distance and makespan to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        if len(split_route) > 4:\n            split_pos = random.randint(2, len(split_route) - 3)\n            first_part = split_route[:split_pos + 1]\n            second_part = split_route[split_pos:]\n\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[split_route_idx] = first_part\n                new_solution.insert(split_route_idx + 1, second_part)\n\n                merge_candidate = random.choice([i for i in range(len(new_solution)) if i != split_route_idx and i != split_route_idx + 1])\n                candidate_route = new_solution[merge_candidate]\n                combined_route = np.concatenate([candidate_route[:-1], new_solution[split_route_idx + 1][1:]])\n\n                if check_capacity(combined_route):\n                    new_solution[merge_candidate] = combined_route\n                    new_solution.pop(split_route_idx + 1)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines route splitting with demand-aware route merging and insertion, prioritizing solutions with balanced distance and makespan to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        split_route_idx = random.randint(0, len(new_solution) - 1)\n        split_route = new_solution[split_route_idx]\n        if len(split_route) > 4:\n            split_pos = random.randint(2, len(split_route) - 3)\n            first_part = split_route[:split_pos + 1]\n            second_part = split_route[split_pos:]\n\n            def check_capacity(route):\n                return sum(demand[route[1:-1]]) <= capacity\n\n            if check_capacity(first_part) and check_capacity(second_part):\n                new_solution[split_route_idx] = first_part\n                new_solution.insert(split_route_idx + 1, second_part)\n\n                merge_candidate = random.choice([i for i in range(len(new_solution)) if i != split_route_idx and i != split_route_idx + 1])\n                candidate_route = new_solution[merge_candidate]\n                combined_route = np.concatenate([candidate_route[:-1], new_solution[split_route_idx + 1][1:]])\n\n                if check_capacity(combined_route):\n                    new_solution[merge_candidate] = combined_route\n                    new_solution.pop(split_route_idx + 1)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{A novel hybrid local search operator that combines route reversal with demand-balanced route swapping and insertion, prioritizing solutions with low makespan while maintaining feasibility by carefully balancing demand redistribution and distance optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Prioritize low makespan\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Randomly select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Reverse one of the routes\n        reversed_route = np.concatenate([[0], route1[1:-1][::-1], [0]])\n\n        def check_capacity(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if check_capacity(reversed_route):\n            new_solution[route1_idx] = reversed_route\n\n            # Attempt to redistribute demand between the two routes\n            if len(route1) > 3 and len(route2) > 3:\n                # Randomly select a customer from each route to swap\n                customer1_idx = random.randint(1, len(route1) - 2)\n                customer2_idx = random.randint(1, len(route2) - 2)\n\n                customer1 = route1[customer1_idx]\n                customer2 = route2[customer2_idx]\n\n                # Check if swapping these customers would maintain capacity\n                new_route1 = np.concatenate([route1[:customer1_idx], [customer2], route1[customer1_idx + 1:]])\n                new_route2 = np.concatenate([route2[:customer2_idx], [customer1], route2[customer2_idx + 1:]])\n\n                if check_capacity(new_route1) and check_capacity(new_route2):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.38560264645778086,
            0.14094513654708862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Prioritize low makespan\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Randomly select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Reverse one of the routes\n        reversed_route = np.concatenate([[0], route1[1:-1][::-1], [0]])\n\n        def check_capacity(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if check_capacity(reversed_route):\n            new_solution[route1_idx] = reversed_route\n\n            # Attempt to redistribute demand between the two routes\n            if len(route1) > 3 and len(route2) > 3:\n                # Randomly select a customer from each route to swap\n                customer1_idx = random.randint(1, len(route1) - 2)\n                customer2_idx = random.randint(1, len(route2) - 2)\n\n                customer1 = route1[customer1_idx]\n                customer2 = route2[customer2_idx]\n\n                # Check if swapping these customers would maintain capacity\n                new_route1 = np.concatenate([route1[:customer1_idx], [customer2], route1[customer1_idx + 1:]])\n                new_route2 = np.concatenate([route2[:customer2_idx], [customer1], route2[customer2_idx + 1:]])\n\n                if check_capacity(new_route1) and check_capacity(new_route2):\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm implements a novel \"route clustering and sequential insertion\" approach that combines adaptive route clustering based on spatial proximity with a demand-aware sequential insertion heuristic to optimize both distance and makespan while maintaining capacity constraints.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route centers for clustering\n    route_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n        else:\n            route_centers.append(np.zeros(2))\n\n    # Cluster routes based on spatial proximity\n    if len(new_solution) > 1:\n        # Find the most isolated route\n        max_dist = -1\n        isolated_idx = 0\n        for i in range(len(new_solution)):\n            min_dist = min([np.linalg.norm(route_centers[i] - route_centers[j])\n                          for j in range(len(new_solution)) if j != i])\n            if min_dist > max_dist:\n                max_dist = min_dist\n                isolated_idx = i\n\n        isolated_route = new_solution[isolated_idx]\n        customers = isolated_route[1:-1]\n\n        # Create new solution without the isolated route\n        new_solution.pop(isolated_idx)\n\n        # Attempt to reinsert customers into nearby routes\n        for customer in customers:\n            best_improvement = 0\n            best_insert_pos = None\n            best_route_idx = None\n\n            for route_idx, route in enumerate(new_solution):\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find the best insertion position\n                for pos in range(1, len(route)):\n                    # Calculate insertion cost\n                    old_dist = distance_matrix[route[pos-1], route[pos]]\n                    new_dist = (distance_matrix[route[pos-1], customer] +\n                               distance_matrix[customer, route[pos]])\n\n                    improvement = old_dist - new_dist\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insert_pos = pos\n                        best_route_idx = route_idx\n\n            # Perform the best insertion if found\n            if best_route_idx is not None:\n                route = new_solution[best_route_idx]\n                new_route = np.concatenate([\n                    route[:best_insert_pos],\n                    [customer],\n                    route[best_insert_pos:]\n                ])\n                new_solution[best_route_idx] = new_route\n\n        # If any customers couldn't be inserted, create a new route\n        if len(new_solution) < len(base_solution):\n            remaining_customers = []\n            for route in base_solution:\n                if len(route) > 2:\n                    remaining_customers.extend(route[1:-1])\n\n            if remaining_customers:\n                new_route = np.concatenate([[0], remaining_customers, [0]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution.append(new_route)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm implements a novel \"route merging and demand-balanced splitting\" approach that adaptively merges routes based on spatial proximity and demand balance, followed by a capacity-constrained route splitting heuristic to optimize both distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route characteristics\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n    # Find the most underutilized route (low load relative to distance)\n    if len(new_solution) > 1:\n        underutilization = [route_distances[i] / (route_loads[i] + 1e-6) for i in range(len(new_solution))]\n        underutilized_idx = np.argmin(underutilization)\n        underutilized_route = new_solution[underutilized_idx]\n\n        # Find the most compatible route to merge with\n        best_merge_idx = -1\n        best_merge_score = -1\n        for i in range(len(new_solution)):\n            if i == underutilized_idx:\n                continue\n\n            # Calculate compatibility score (spatial proximity and demand balance)\n            current_route = new_solution[i]\n            spatial_score = np.linalg.norm(coords[underutilized_route[1]] - coords[current_route[1]])\n            demand_score = abs(route_loads[i] - route_loads[underutilized_idx])\n\n            compatibility = -spatial_score - 0.5 * demand_score\n            if compatibility > best_merge_score:\n                best_merge_score = compatibility\n                best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Merge the underutilized route into the most compatible route\n            target_route = new_solution[best_merge_idx]\n            merged_route = np.concatenate([target_route[:-1], underutilized_route[1:-1], [0]])\n\n            # Check capacity constraint\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[best_merge_idx] = merged_route\n                new_solution.pop(underutilized_idx)\n\n                # Attempt to split the merged route if it's too long\n                if len(merged_route) > 10:  # Arbitrary threshold for splitting\n                    split_pos = len(merged_route) // 2\n                    first_half = np.concatenate([merged_route[:split_pos], [0]])\n                    second_half = np.concatenate([[0], merged_route[split_pos:-1], [0]])\n\n                    if (sum(demand[first_half[1:-1]]) <= capacity and\n                        sum(demand[second_half[1:-1]]) <= capacity):\n                        new_solution[best_merge_idx] = first_half\n                        new_solution.insert(best_merge_idx + 1, second_half)\n\n    return new_solution\n\n",
        "score": [
            -0.4716925478391628,
            3.396079033613205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route characteristics\n    route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n    route_distances = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n    # Find the most underutilized route (low load relative to distance)\n    if len(new_solution) > 1:\n        underutilization = [route_distances[i] / (route_loads[i] + 1e-6) for i in range(len(new_solution))]\n        underutilized_idx = np.argmin(underutilization)\n        underutilized_route = new_solution[underutilized_idx]\n\n        # Find the most compatible route to merge with\n        best_merge_idx = -1\n        best_merge_score = -1\n        for i in range(len(new_solution)):\n            if i == underutilized_idx:\n                continue\n\n            # Calculate compatibility score (spatial proximity and demand balance)\n            current_route = new_solution[i]\n            spatial_score = np.linalg.norm(coords[underutilized_route[1]] - coords[current_route[1]])\n            demand_score = abs(route_loads[i] - route_loads[underutilized_idx])\n\n            compatibility = -spatial_score - 0.5 * demand_score\n            if compatibility > best_merge_score:\n                best_merge_score = compatibility\n                best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Merge the underutilized route into the most compatible route\n            target_route = new_solution[best_merge_idx]\n            merged_route = np.concatenate([target_route[:-1], underutilized_route[1:-1], [0]])\n\n            # Check capacity constraint\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[best_merge_idx] = merged_route\n                new_solution.pop(underutilized_idx)\n\n                # Attempt to split the merged route if it's too long\n                if len(merged_route) > 10:  # Arbitrary threshold for splitting\n                    split_pos = len(merged_route) // 2\n                    first_half = np.concatenate([merged_route[:split_pos], [0]])\n                    second_half = np.concatenate([[0], merged_route[split_pos:-1], [0]])\n\n                    if (sum(demand[first_half[1:-1]]) <= capacity and\n                        sum(demand[second_half[1:-1]]) <= capacity):\n                        new_solution[best_merge_idx] = first_half\n                        new_solution.insert(best_merge_idx + 1, second_half)\n\n    return new_solution\n\n"
    }
]