[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm employs a combination of adaptive route splitting and intelligent customer redistribution, where it selectively splits longer routes to improve makespan while redistributing customers to shorter routes to optimize total distance, all while maintaining vehicle capacity constraints and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (descending)\n    sorted_indices = np.argsort(route_lengths)[::-1]\n    longest_route_idx = sorted_indices[0]\n    shortest_route_idx = sorted_indices[-1]\n\n    # Split the longest route if it's too long\n    longest_route = new_solution[longest_route_idx]\n    if len(longest_route) > 3:  # Ensure there are enough customers to split\n        # Find the best split point\n        best_split_pos = -1\n        min_split_cost = float('inf')\n\n        for pos in range(2, len(longest_route)-1):\n            # Calculate the cost of splitting at this position\n            first_part = longest_route[:pos+1]\n            second_part = longest_route[pos:]\n\n            first_demand = sum(demand[first_part[1:-1]])\n            second_demand = sum(demand[second_part[1:-1]])\n\n            if first_demand <= capacity and second_demand <= capacity:\n                # Calculate the increase in total distance\n                first_length = sum(distance_matrix[first_part[i], first_part[i+1]] for i in range(len(first_part)-1))\n                second_length = sum(distance_matrix[second_part[i], second_part[i+1]] for i in range(len(second_part)-1))\n                original_length = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(len(longest_route)-1))\n\n                split_cost = first_length + second_length - original_length\n\n                if split_cost < min_split_cost:\n                    min_split_cost = split_cost\n                    best_split_pos = pos\n\n        if best_split_pos != -1:\n            # Perform the split\n            first_part = longest_route[:best_split_pos+1]\n            second_part = longest_route[best_split_pos:]\n\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n\n            # Update route lengths and demands\n            route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Redistribute customers from the longest route to shorter routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_redistribute = longest_route[1:-1]\n    for customer in customers_to_redistribute:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.786068044171699,
            0.5910958349704742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (descending)\n    sorted_indices = np.argsort(route_lengths)[::-1]\n    longest_route_idx = sorted_indices[0]\n    shortest_route_idx = sorted_indices[-1]\n\n    # Split the longest route if it's too long\n    longest_route = new_solution[longest_route_idx]\n    if len(longest_route) > 3:  # Ensure there are enough customers to split\n        # Find the best split point\n        best_split_pos = -1\n        min_split_cost = float('inf')\n\n        for pos in range(2, len(longest_route)-1):\n            # Calculate the cost of splitting at this position\n            first_part = longest_route[:pos+1]\n            second_part = longest_route[pos:]\n\n            first_demand = sum(demand[first_part[1:-1]])\n            second_demand = sum(demand[second_part[1:-1]])\n\n            if first_demand <= capacity and second_demand <= capacity:\n                # Calculate the increase in total distance\n                first_length = sum(distance_matrix[first_part[i], first_part[i+1]] for i in range(len(first_part)-1))\n                second_length = sum(distance_matrix[second_part[i], second_part[i+1]] for i in range(len(second_part)-1))\n                original_length = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(len(longest_route)-1))\n\n                split_cost = first_length + second_length - original_length\n\n                if split_cost < min_split_cost:\n                    min_split_cost = split_cost\n                    best_split_pos = pos\n\n        if best_split_pos != -1:\n            # Perform the split\n            first_part = longest_route[:best_split_pos+1]\n            second_part = longest_route[best_split_pos:]\n\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n\n            # Update route lengths and demands\n            route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n            route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Redistribute customers from the longest route to shorter routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_redistribute = longest_route[1:-1]\n    for customer in customers_to_redistribute:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The algorithm selects a solution with the lowest makespan from the archive to target makespan optimization, then applies a hybrid local search combining route merging and customer reinsertion with capacity checks to balance the total distance while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the shortest route\n    shortest_route_idx = np.argmin([sum(demand[route[1:-1]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Try to merge the shortest route with another route\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            if i == shortest_route_idx:\n                continue\n            target_route = new_solution[i]\n            combined_demand = sum(demand[shortest_route[1:-1]]) + sum(demand[target_route[1:-1]])\n\n            if combined_demand <= capacity:\n                # Calculate best merge position\n                min_increase = float('inf')\n                best_pos = 1\n                for pos in range(1, len(target_route)):\n                    increase = (distance_matrix[target_route[pos-1]][shortest_route[1]] +\n                              distance_matrix[shortest_route[-2]][target_route[pos]] -\n                              distance_matrix[target_route[pos-1]][target_route[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Merge the routes\n                merged_route = np.concatenate([\n                    target_route[:best_pos],\n                    shortest_route[1:-1],\n                    target_route[best_pos:]\n                ])\n                new_solution[i] = merged_route\n                del new_solution[shortest_route_idx]\n                break\n\n    # Reinsert customers from the merged route if capacity is exceeded\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            customers = route[1:-1].copy()\n            new_solution.remove(route)\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    temp_route = new_solution[i]\n                    if sum(demand[temp_route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(temp_route)):\n                            increase = (distance_matrix[temp_route[pos-1]][customer] +\n                                      distance_matrix[customer][temp_route[pos]] -\n                                      distance_matrix[temp_route[pos-1]][temp_route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(temp_route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.3435794880803669,
            3.87631618976593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the shortest route\n    shortest_route_idx = np.argmin([sum(demand[route[1:-1]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Try to merge the shortest route with another route\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)):\n            if i == shortest_route_idx:\n                continue\n            target_route = new_solution[i]\n            combined_demand = sum(demand[shortest_route[1:-1]]) + sum(demand[target_route[1:-1]])\n\n            if combined_demand <= capacity:\n                # Calculate best merge position\n                min_increase = float('inf')\n                best_pos = 1\n                for pos in range(1, len(target_route)):\n                    increase = (distance_matrix[target_route[pos-1]][shortest_route[1]] +\n                              distance_matrix[shortest_route[-2]][target_route[pos]] -\n                              distance_matrix[target_route[pos-1]][target_route[pos]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n                # Merge the routes\n                merged_route = np.concatenate([\n                    target_route[:best_pos],\n                    shortest_route[1:-1],\n                    target_route[best_pos:]\n                ])\n                new_solution[i] = merged_route\n                del new_solution[shortest_route_idx]\n                break\n\n    # Reinsert customers from the merged route if capacity is exceeded\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            customers = route[1:-1].copy()\n            new_solution.remove(route)\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    temp_route = new_solution[i]\n                    if sum(demand[temp_route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(temp_route)):\n                            increase = (distance_matrix[temp_route[pos-1]][customer] +\n                                      distance_matrix[customer][temp_route[pos]] -\n                                      distance_matrix[temp_route[pos-1]][temp_route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(temp_route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm implements a hybrid local search that combines route balancing with strategic customer swapping, where it selectively redistributes customers between routes to improve both total distance and makespan, while ensuring capacity constraints are met through adaptive demand reallocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Balance the longest route by swapping customers with other routes\n    longest_route = new_solution[longest_route_idx]\n    for customer in longest_route[1:-1]:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                for pos in range(1, len(route)):\n                    # Calculate the score as a weighted combination of distance increase and makespan improvement\n                    distance_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                    new_makespan = max(route_lengths[i] + distance_increase, route_lengths[longest_route_idx] - distance_matrix[longest_route[np.where(longest_route == customer)[0][0]-1], customer] - distance_matrix[customer, longest_route[np.where(longest_route == customer)[0][0]+1]])\n                    score = 0.7 * distance_increase + 0.3 * (new_makespan - route_lengths[longest_route_idx])\n\n                    if score < best_score:\n                        best_score = score\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the swap\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    # Recalculate route lengths for the new solution\n    new_route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n    # Further optimize by merging routes if beneficial\n    if len(new_solution) > 1:\n        # Find the pair of routes with the smallest combined distance when merged\n        min_increase = float('inf')\n        best_merge_pair = None\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if route_demands[i] + route_demands[j] <= capacity:\n                    # Calculate the best merge distance increase\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    first_customer1 = route1[1]\n                    last_customer1 = route1[-2]\n                    first_customer2 = route2[1]\n                    last_customer2 = route2[-2]\n\n                    # Try merging route1 into route2\n                    increase1 = (distance_matrix[last_customer1][first_customer2] -\n                               distance_matrix[last_customer1][0] - distance_matrix[0][first_customer2])\n                    # Try merging route2 into route1\n                    increase2 = (distance_matrix[last_customer2][first_customer1] -\n                               distance_matrix[last_customer2][0] - distance_matrix[0][first_customer1])\n\n                    if min(increase1, increase2) < min_increase:\n                        min_increase = min(increase1, increase2)\n                        best_merge_pair = (i, j) if increase1 < increase2 else (j, i)\n\n        if best_merge_pair and min_increase < 0:  # Only merge if it improves the solution\n            i, j = best_merge_pair\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7340503661022062,
            2.619242340326309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Balance the longest route by swapping customers with other routes\n    longest_route = new_solution[longest_route_idx]\n    for customer in longest_route[1:-1]:\n        best_route_idx = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                for pos in range(1, len(route)):\n                    # Calculate the score as a weighted combination of distance increase and makespan improvement\n                    distance_increase = (distance_matrix[route[pos-1]][customer] +\n                                       distance_matrix[customer][route[pos]] -\n                                       distance_matrix[route[pos-1]][route[pos]])\n                    new_makespan = max(route_lengths[i] + distance_increase, route_lengths[longest_route_idx] - distance_matrix[longest_route[np.where(longest_route == customer)[0][0]-1], customer] - distance_matrix[customer, longest_route[np.where(longest_route == customer)[0][0]+1]])\n                    score = 0.7 * distance_increase + 0.3 * (new_makespan - route_lengths[longest_route_idx])\n\n                    if score < best_score:\n                        best_score = score\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the swap\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    # Recalculate route lengths for the new solution\n    new_route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n\n    # Further optimize by merging routes if beneficial\n    if len(new_solution) > 1:\n        # Find the pair of routes with the smallest combined distance when merged\n        min_increase = float('inf')\n        best_merge_pair = None\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if route_demands[i] + route_demands[j] <= capacity:\n                    # Calculate the best merge distance increase\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    first_customer1 = route1[1]\n                    last_customer1 = route1[-2]\n                    first_customer2 = route2[1]\n                    last_customer2 = route2[-2]\n\n                    # Try merging route1 into route2\n                    increase1 = (distance_matrix[last_customer1][first_customer2] -\n                               distance_matrix[last_customer1][0] - distance_matrix[0][first_customer2])\n                    # Try merging route2 into route1\n                    increase2 = (distance_matrix[last_customer2][first_customer1] -\n                               distance_matrix[last_customer2][0] - distance_matrix[0][first_customer1])\n\n                    if min(increase1, increase2) < min_increase:\n                        min_increase = min(increase1, increase2)\n                        best_merge_pair = (i, j) if increase1 < increase2 else (j, i)\n\n        if best_merge_pair and min_increase < 0:  # Only merge if it improves the solution\n            i, j = best_merge_pair\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    return new_solution\n\n"
    }
]