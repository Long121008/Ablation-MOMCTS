[
    {
        "algorithm": "{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.9709121946153363,
            3.5719566345214844
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    }
]