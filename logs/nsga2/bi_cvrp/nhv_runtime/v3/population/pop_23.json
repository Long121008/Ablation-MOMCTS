[
    {
        "algorithm": "{This algorithm combines route reversal with strategic customer reallocation, where it reverses the longest route to potentially reduce makespan while reallocating customers to other routes to improve total distance, all while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route by makespan (route length)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Reverse the longest route to potentially reduce makespan\n    reversed_route = np.concatenate([[0], longest_route[1:-1][::-1], [0]])\n    new_solution[longest_route_idx] = reversed_route\n\n    # Reallocate customers from the reversed route to other routes if possible\n    customers_to_reallocate = reversed_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the reversed route\n            reversed_route = reversed_route[reversed_route != customer]\n            new_solution[longest_route_idx] = reversed_route\n\n    return new_solution\n\n",
        "score": [
            -0.9633913391139032,
            3.335506021976471
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    }
]