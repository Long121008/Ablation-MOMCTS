[
    {
        "algorithm": "{The algorithm selects the solution with the highest makespan from the archive to target load balancing, then applies a hybrid local search combining route merging and customer reinsertion with capacity checks to reduce the longest route while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to merge with another route if possible\n    for i in range(len(new_solution)):\n        if i == longest_route_idx:\n            continue\n        candidate_route = new_solution[i]\n        # Check if merging is feasible\n        if sum(demand[longest_route[1:-1]]) + sum(demand[candidate_route[1:-1]]) <= capacity:\n            # Merge routes\n            merged_route = np.concatenate([longest_route[:-1], candidate_route[1:]])\n            new_solution[longest_route_idx] = merged_route\n            del new_solution[i]\n            break\n\n    # If no merge, try reinserting customers from the longest route\n    if len(new_solution) == len(base_solution):\n        customers = longest_route[1:-1]\n        if len(customers) > 0:\n            # Remove the longest route\n            del new_solution[longest_route_idx]\n            # Try to reinsert customers into other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    route = new_solution[i]\n                    # Check capacity constraint\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find the best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.4976945596722278,
            0.5176630914211273
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine route merging and customer reinsertion with capacity checks\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i][1:-1]  # Exclude depot\n        route_j = new_solution[j][1:-1]  # Exclude depot\n\n        # Check if merging is feasible (total demand <= capacity)\n        total_demand = np.sum(demand[route_i]) + np.sum(demand[route_j])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([[0], route_i, route_j, [0]])\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n            # Reinsert customers from the merged route to balance makespan\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reinsert the customer (minimizing makespan increase)\n                    best_route_idx = -1\n                    min_makespan_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != i:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[l], temp_route[l+1]] for l in range(len(temp_route)-1))\n                                makespan_increase = temp_route_length - sum(distance_matrix[new_solution[k][l], new_solution[k][l+1]] for l in range(len(new_solution[k])-1))\n                                if makespan_increase < min_makespan_increase:\n                                    min_makespan_increase = makespan_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reinsert customer into the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[i] = np.concatenate([new_solution[i][:idx], new_solution[i][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.750383966834802,
            0.849029541015625
        ]
    }
]