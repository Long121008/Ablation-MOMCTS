[
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    }
]