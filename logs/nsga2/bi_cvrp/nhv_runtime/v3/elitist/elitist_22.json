[
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    }
]