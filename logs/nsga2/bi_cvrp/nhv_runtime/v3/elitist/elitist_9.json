[
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest makespan from the archive to target makespan optimization, then applies a hybrid local search combining route merging and customer reallocation with capacity checks to balance the total distance while maintaining feasibility by intelligently redistributing customers between routes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the shortest route\n    shortest_route_idx = np.argmin([sum(demand[route[1:-1]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Try to merge the shortest route with another route\n    if len(new_solution) > 1:\n        # Find the most compatible route to merge with\n        min_distance_increase = float('inf')\n        best_merge_idx = -1\n\n        for i in range(len(new_solution)):\n            if i == shortest_route_idx:\n                continue\n            current_route = new_solution[i]\n\n            # Calculate potential distance increase if merged\n            distance_increase = (distance_matrix[shortest_route[-2]][current_route[1]] -\n                               distance_matrix[shortest_route[-2]][0] -\n                               distance_matrix[0][current_route[1]])\n\n            if distance_increase < min_distance_increase and sum(demand[shortest_route[1:-1]]) + sum(demand[current_route[1:-1]]) <= capacity:\n                min_distance_increase = distance_increase\n                best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[best_merge_idx][:-1], shortest_route[1:]])\n            new_solution[best_merge_idx] = merged_route\n            del new_solution[shortest_route_idx]\n        else:\n            # If no feasible merge, try to reallocate customers to other routes\n            for customer in shortest_route[1:-1]:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == shortest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original shortest route if it was merged\n    if len(new_solution) < len(base_solution):\n        del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8619832495869599,
            0.2959425449371338
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines adaptive route merging with demand-aware customer redistribution to optimize both total distance and makespan by strategically consolidating routes and reallocating customers while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive Route Merging: Merge routes that are too short to reduce the number of vehicles\n    if len(new_solution) > 1:\n        # Select the shortest route\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best route to merge with (minimizing total distance increase)\n        best_merge_idx = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == shortest_route_idx:\n                continue\n\n            # Check if merging is feasible\n            merged_route = np.concatenate([new_solution[i][:-1], shortest_route, [0]])\n            merged_demand = np.sum(demand[merged_route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase\n                original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                merged_length = sum(distance_matrix[merged_route[j], merged_route[j+1]] for j in range(len(merged_route)-1))\n                distance_increase = merged_length - original_length\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[best_merge_idx][:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            del new_solution[shortest_route_idx]\n\n            # Demand-aware Customer Redistribution: Move customers between routes to improve makespan\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing makespan increase)\n                    best_route_idx = -1\n                    min_makespan_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != best_merge_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                makespan_increase = temp_route_length - original_route_length\n                                if makespan_increase < min_makespan_increase:\n                                    min_makespan_increase = makespan_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[best_merge_idx] = np.concatenate([new_solution[best_merge_idx][:idx], new_solution[best_merge_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8329126989771625,
            0.21655187010765076
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with adaptive customer reallocation, where routes are strategically divided based on demand balance and customer reinsertion prioritizes minimizing the maximum route length (makespan) while considering the total distance impact.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Route Splitting with Adaptive Reallocation\n    if len(new_solution) > 1:\n        # Select the longest route to split\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to balance demand\n        best_split = -1\n        min_demand_diff = float('inf')\n\n        for i in range(1, len(longest_route)):\n            left_demand = np.sum(demand[longest_route[:i]])\n            right_demand = np.sum(demand[longest_route[i:]])\n            demand_diff = abs(left_demand - right_demand)\n\n            if demand_diff < min_demand_diff and left_demand <= capacity and right_demand <= capacity:\n                min_demand_diff = demand_diff\n                best_split = i\n\n        if best_split != -1:\n            # Split the route\n            left_route = np.concatenate([[0], longest_route[:best_split], [0]])\n            right_route = np.concatenate([[0], longest_route[best_split:], [0]])\n\n            # Replace the original route with the two new routes\n            new_solution[longest_route_idx] = left_route\n            new_solution.append(right_route)\n\n            # Reallocate customers between the new routes to minimize makespan\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reinsert the customer (minimizing makespan)\n                    best_route_idx = -1\n                    min_makespan = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[l], temp_route[l+1]] for l in range(len(temp_route)-1))\n                                if temp_route_length < min_makespan:\n                                    min_makespan = temp_route_length\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reinsert customer into the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8689666108990866,
            1.3052009046077728
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines adaptive route splitting with demand-aware customer reallocation to balance the trade-off between total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive Route Splitting: Split routes that are too long to balance makespan\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx][1:-1]  # Exclude depot\n\n        # Find the best split point to minimize makespan increase\n        best_split = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(1, len(longest_route)):\n            # Split the route into two parts\n            part1 = longest_route[:i]\n            part2 = longest_route[i:]\n\n            # Check capacity constraints\n            demand1 = np.sum(demand[part1])\n            demand2 = np.sum(demand[part2])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                # Calculate makespan increase\n                route1 = np.concatenate([[0], part1, [0]])\n                route2 = np.concatenate([[0], part2, [0]])\n                route1_length = sum(distance_matrix[route1[i], route1[i+1]] for i in range(len(route1)-1))\n                route2_length = sum(distance_matrix[route2[i], route2[i+1]] for i in range(len(route2)-1))\n                original_length = sum(distance_matrix[new_solution[longest_route_idx][i], new_solution[longest_route_idx][i+1]] for i in range(len(new_solution[longest_route_idx])-1))\n                makespan_increase = max(route1_length, route2_length) - original_length\n\n                if makespan_increase < min_makespan_increase:\n                    min_makespan_increase = makespan_increase\n                    best_split = i\n\n        if best_split != -1:\n            # Perform the split\n            part1 = longest_route[:best_split]\n            part2 = longest_route[best_split:]\n            new_solution[longest_route_idx] = np.concatenate([[0], part1, [0]])\n            new_solution.append(np.concatenate([[0], part2, [0]]))\n\n            # Demand-aware Customer Reallocation: Move customers between routes to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reallocate\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n\n                    # Find the best route to reallocate the customer (minimizing total distance increase)\n                    best_route_idx = -1\n                    min_distance_increase = float('inf')\n\n                    for k in range(len(new_solution)):\n                        if k != longest_route_idx:  # Skip the current route\n                            temp_route = np.concatenate([new_solution[k][:-1], [customer], [0]])\n                            temp_demand = np.sum(demand[temp_route[1:-1]])\n                            if temp_demand <= capacity:\n                                temp_route_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                                original_route_length = sum(distance_matrix[new_solution[k][i], new_solution[k][i+1]] for i in range(len(new_solution[k])-1))\n                                distance_increase = temp_route_length - original_route_length\n                                if distance_increase < min_distance_increase:\n                                    min_distance_increase = distance_increase\n                                    best_route_idx = k\n\n                    if best_route_idx != -1:\n                        # Reallocate customer to the best route\n                        new_solution[best_route_idx] = np.concatenate([new_solution[best_route_idx][:-1], [customer], [0]])\n                        # Remove customer from the original route\n                        new_solution[longest_route_idx] = np.concatenate([new_solution[longest_route_idx][:idx], new_solution[longest_route_idx][idx+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8798348685122871,
            1.671868234872818
        ]
    }
]