[
    {
        "algorithm": "{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.9709121946153363,
            3.5719566345214844
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.9709121946153363,
            3.5719566345214844
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.9709121946153363,
            3.5719566345214844
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.9709121946153363,
            3.5719566345214844
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines route reversal with strategic customer reallocation, where it reverses the longest route to potentially reduce makespan while reallocating customers to other routes to improve total distance, all while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route by makespan (route length)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Reverse the longest route to potentially reduce makespan\n    reversed_route = np.concatenate([[0], longest_route[1:-1][::-1], [0]])\n    new_solution[longest_route_idx] = reversed_route\n\n    # Reallocate customers from the reversed route to other routes if possible\n    customers_to_reallocate = reversed_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the reversed route\n            reversed_route = reversed_route[reversed_route != customer]\n            new_solution[longest_route_idx] = reversed_route\n\n    return new_solution\n\n",
        "score": [
            -0.9633913391139032,
            3.335506021976471
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines strategic customer reallocation with adaptive route merging, where it selectively merges shorter routes to reduce total distance while redistributing customers from longer routes to balance makespan, all while ensuring capacity constraints are met.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate route lengths and demands\n    route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    route_demands = [sum(demand[route[1:-1]]) for route in new_solution]\n\n    # Sort routes by length (ascending)\n    sorted_indices = np.argsort(route_lengths)\n    shortest_route_idx = sorted_indices[0]\n    longest_route_idx = sorted_indices[-1]\n\n    # Merge the shortest route into the longest route if possible\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) > 2:  # Ensure there are customers to merge\n        if route_demands[longest_route_idx] + route_demands[shortest_route_idx] <= capacity:\n            # Find the best insertion position for merging\n            best_pos = 1\n            min_distance_increase = float('inf')\n\n            for pos in range(1, len(longest_route)):\n                # Calculate distance increase if shortest route is inserted here\n                prev_node = longest_route[pos-1]\n                next_node = longest_route[pos]\n                first_customer = shortest_route[1]\n                last_customer = shortest_route[-2]\n\n                increase = (distance_matrix[prev_node][first_customer] +\n                           distance_matrix[last_customer][next_node] -\n                           distance_matrix[prev_node][next_node])\n                if increase < min_distance_increase:\n                    min_distance_increase = increase\n                    best_pos = pos\n\n            # Insert the shortest route into the longest route\n            new_longest_route = np.concatenate([\n                longest_route[:best_pos],\n                shortest_route[1:-1],\n                longest_route[best_pos:]\n            ])\n            new_solution[longest_route_idx] = new_longest_route\n            del new_solution[shortest_route_idx]\n\n    # Reallocate customers from the longest route to other routes if possible\n    longest_route = new_solution[longest_route_idx]\n    customers_to_reallocate = longest_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the longest route\n            longest_route = longest_route[longest_route != customer]\n            new_solution[longest_route_idx] = longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.9709121946153363,
            3.5719566345214844
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines route reversal with strategic customer reallocation, where it reverses the longest route to potentially reduce makespan while reallocating customers to other routes to improve total distance, all while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route by makespan (route length)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Reverse the longest route to potentially reduce makespan\n    reversed_route = np.concatenate([[0], longest_route[1:-1][::-1], [0]])\n    new_solution[longest_route_idx] = reversed_route\n\n    # Reallocate customers from the reversed route to other routes if possible\n    customers_to_reallocate = reversed_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the reversed route\n            reversed_route = reversed_route[reversed_route != customer]\n            new_solution[longest_route_idx] = reversed_route\n\n    return new_solution\n\n",
        "score": [
            -0.9633913391139032,
            3.335506021976471
        ]
    },
    {
        "algorithm": "{This algorithm combines route reversal with strategic customer reallocation, where it reverses the longest route to potentially reduce makespan while reallocating customers to other routes to improve total distance, all while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route by makespan (route length)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Reverse the longest route to potentially reduce makespan\n    reversed_route = np.concatenate([[0], longest_route[1:-1][::-1], [0]])\n    new_solution[longest_route_idx] = reversed_route\n\n    # Reallocate customers from the reversed route to other routes if possible\n    customers_to_reallocate = reversed_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the reversed route\n            reversed_route = reversed_route[reversed_route != customer]\n            new_solution[longest_route_idx] = reversed_route\n\n    return new_solution\n\n",
        "score": [
            -0.9633913391139032,
            3.335506021976471
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{This algorithm combines route reversal with strategic customer reallocation, where it reverses the longest route to potentially reduce makespan while reallocating customers to other routes to improve total distance, all while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route by makespan (route length)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Reverse the longest route to potentially reduce makespan\n    reversed_route = np.concatenate([[0], longest_route[1:-1][::-1], [0]])\n    new_solution[longest_route_idx] = reversed_route\n\n    # Reallocate customers from the reversed route to other routes if possible\n    customers_to_reallocate = reversed_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the reversed route\n            reversed_route = reversed_route[reversed_route != customer]\n            new_solution[longest_route_idx] = reversed_route\n\n    return new_solution\n\n",
        "score": [
            -0.9633913391139032,
            3.335506021976471
        ]
    },
    {
        "algorithm": "{This algorithm combines route reversal with strategic customer reallocation, where it reverses the longest route to potentially reduce makespan while reallocating customers to other routes to improve total distance, all while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route by makespan (route length)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Reverse the longest route to potentially reduce makespan\n    reversed_route = np.concatenate([[0], longest_route[1:-1][::-1], [0]])\n    new_solution[longest_route_idx] = reversed_route\n\n    # Reallocate customers from the reversed route to other routes if possible\n    customers_to_reallocate = reversed_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the reversed route\n            reversed_route = reversed_route[reversed_route != customer]\n            new_solution[longest_route_idx] = reversed_route\n\n    return new_solution\n\n",
        "score": [
            -0.9633913391139032,
            3.335506021976471
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{This algorithm combines route reversal with strategic customer reallocation, where it reverses the longest route to potentially reduce makespan while reallocating customers to other routes to improve total distance, all while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route by makespan (route length)\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Reverse the longest route to potentially reduce makespan\n    reversed_route = np.concatenate([[0], longest_route[1:-1][::-1], [0]])\n    new_solution[longest_route_idx] = reversed_route\n\n    # Reallocate customers from the reversed route to other routes if possible\n    customers_to_reallocate = reversed_route[1:-1]\n    for customer in customers_to_reallocate:\n        best_route_idx = -1\n        best_pos = -1\n        min_distance_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n            route = new_solution[i]\n            current_demand = sum(demand[route[1:-1]])\n\n            if current_demand + demand[customer] <= capacity:\n                # Find the best insertion position in this route\n                for pos in range(1, len(route)):\n                    # Calculate distance increase if customer is inserted here\n                    increase = (distance_matrix[route[pos-1]][customer] +\n                               distance_matrix[customer][route[pos]] -\n                               distance_matrix[route[pos-1]][route[pos]])\n                    if increase < min_distance_increase:\n                        min_distance_increase = increase\n                        best_route_idx = i\n                        best_pos = pos\n\n        if best_route_idx != -1:\n            # Insert the customer into the best route and position\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_pos, customer)\n            # Remove the customer from the reversed route\n            reversed_route = reversed_route[reversed_route != customer]\n            new_solution[longest_route_idx] = reversed_route\n\n    return new_solution\n\n",
        "score": [
            -0.9633913391139032,
            3.335506021976471
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that combines demand-aware route merging with adaptive customer insertion to optimize the balance between total distance and makespan while maintaining feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Demand-aware Route Merging: Merge routes that can be combined without exceeding capacity\n    if len(new_solution) > 1:\n        # Select the shortest route (potential candidate for merging)\n        shortest_route_idx = np.argmin([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        shortest_route = new_solution[shortest_route_idx][1:-1]  # Exclude depot\n        shortest_route_demand = np.sum(demand[shortest_route])\n\n        # Find the best route to merge with (minimizing makespan increase)\n        best_merge_idx = -1\n        min_makespan_increase = float('inf')\n\n        for i in range(len(new_solution)):\n            if i != shortest_route_idx:\n                candidate_route = new_solution[i][1:-1]\n                candidate_demand = np.sum(demand[candidate_route])\n\n                if shortest_route_demand + candidate_demand <= capacity:\n                    # Calculate makespan increase if merged\n                    merged_route = np.concatenate([[0], candidate_route, shortest_route, [0]])\n                    merged_route_length = sum(distance_matrix[merged_route[i], merged_route[i+1]] for i in range(len(merged_route)-1))\n                    original_length = sum(distance_matrix[new_solution[i][j], new_solution[i][j+1]] for j in range(len(new_solution[i])-1))\n                    makespan_increase = merged_route_length - original_length\n\n                    if makespan_increase < min_makespan_increase:\n                        min_makespan_increase = makespan_increase\n                        best_merge_idx = i\n\n        if best_merge_idx != -1:\n            # Perform the merge\n            merged_route = np.concatenate([[0], new_solution[best_merge_idx][1:-1], shortest_route, [0]])\n            new_solution[best_merge_idx] = merged_route\n            new_solution.pop(shortest_route_idx)\n\n            # Adaptive Customer Insertion: Reinsert customers to improve total distance\n            for route in new_solution:\n                if len(route) > 3:  # If route has more than just depot and one customer\n                    # Randomly select a customer to reinsert\n                    idx = np.random.randint(1, len(route)-1)\n                    customer = route[idx]\n                    current_demand = np.sum(demand[route[1:-1]])\n\n                    # Remove customer from the route\n                    temp_route = np.concatenate([route[:idx], route[idx+1:]])\n                    temp_demand = current_demand - demand[customer]\n\n                    # Find the best position to reinsert the customer (minimizing total distance increase)\n                    best_pos = -1\n                    min_distance_increase = float('inf')\n\n                    for i in range(1, len(temp_route)):\n                        # Insert customer at position i\n                        candidate_route = np.concatenate([temp_route[:i], [customer], temp_route[i:]])\n                        candidate_demand = temp_demand + demand[customer]\n                        if candidate_demand <= capacity:\n                            candidate_length = sum(distance_matrix[candidate_route[i], candidate_route[i+1]] for i in range(len(candidate_route)-1))\n                            original_length = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n                            distance_increase = candidate_length - original_length\n                            if distance_increase < min_distance_increase:\n                                min_distance_increase = distance_increase\n                                best_pos = i\n\n                    if best_pos != -1:\n                        # Reinsert customer at the best position\n                        new_solution[best_merge_idx] = np.concatenate([temp_route[:best_pos], [customer], temp_route[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9298636305249092,
            0.20271551609039307
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution with the lowest total distance from the archive to target distance optimization, then applies a hybrid local search combining route splitting and customer reallocation with capacity checks to balance the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Identify the longest route\n    longest_route_idx = np.argmax([sum(demand[route[1:-1]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route\n    if len(longest_route) > 3:  # More than just depot to customer to depot\n        customers = longest_route[1:-1]\n        split_pos = len(customers) // 2\n        first_part = np.concatenate([[0], customers[:split_pos], [0]])\n        second_part = np.concatenate([[0], customers[split_pos:], [0]])\n\n        # Check capacity constraints\n        if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx + 1, second_part)\n        else:\n            # Try to reallocate customers to other routes\n            for customer in customers:\n                inserted = False\n                for i in range(len(new_solution)):\n                    if i == longest_route_idx:\n                        continue\n                    route = new_solution[i]\n                    if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                        # Find best insertion position\n                        min_increase = float('inf')\n                        best_pos = 1\n                        for pos in range(1, len(route)):\n                            increase = (distance_matrix[route[pos-1]][customer] +\n                                      distance_matrix[customer][route[pos]] -\n                                      distance_matrix[route[pos-1]][route[pos]])\n                            if increase < min_increase:\n                                min_increase = increase\n                                best_pos = pos\n                        # Insert the customer\n                        new_route = np.insert(route, best_pos, customer)\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    # Create a new route if no feasible insertion found\n                    new_solution.append(np.array([0, customer, 0]))\n\n    # Remove the original longest route if it was split\n    if len(new_solution) > len(base_solution):\n        del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8320163637019589,
            0.07372406125068665
        ]
    }
]