[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route-splitting and route-merging with demand-aware customer reallocation to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random position with high demand concentration\n        split_pos = random.randint(1, len(route) - 2)\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity * 0.7:  # Only split if route is significantly over capacity\n            # Find split point with balanced demand\n            cumulative_demand = 0\n            for i in range(1, len(route) - 1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > total_demand / 2:\n                    split_pos = i\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Demand-aware reallocation within route\n            shuffled_nodes = route[1:-1].copy()\n            random.shuffle(shuffled_nodes)\n            new_route = [0]\n            current_load = 0\n            for node in shuffled_nodes:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    # Create new route if capacity exceeded\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n                    new_route = [0, node]\n                    current_load = demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    # Attempt route merging to reduce makespan\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if combined_load <= capacity:\n            # Calculate distance savings\n            original_dist = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] +\n                            distance_matrix[route2[-2], 0] + distance_matrix[0, route1[1]])\n            merged_dist = (distance_matrix[route1[-2], route2[1]] +\n                          distance_matrix[route2[-2], route1[1]] +\n                          distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]])\n            if merged_dist < original_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            56.92510321885821,
            4.950226713172887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random position with high demand concentration\n        split_pos = random.randint(1, len(route) - 2)\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity * 0.7:  # Only split if route is significantly over capacity\n            # Find split point with balanced demand\n            cumulative_demand = 0\n            for i in range(1, len(route) - 1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > total_demand / 2:\n                    split_pos = i\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Demand-aware reallocation within route\n            shuffled_nodes = route[1:-1].copy()\n            random.shuffle(shuffled_nodes)\n            new_route = [0]\n            current_load = 0\n            for node in shuffled_nodes:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    # Create new route if capacity exceeded\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n                    new_route = [0, node]\n                    current_load = demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    # Attempt route merging to reduce makespan\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if combined_load <= capacity:\n            # Calculate distance savings\n            original_dist = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] +\n                            distance_matrix[route2[-2], 0] + distance_matrix[0, route1[1]])\n            merged_dist = (distance_matrix[route1[-2], route2[1]] +\n                          distance_matrix[route2[-2], route1[1]] +\n                          distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]])\n            if merged_dist < original_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route-splitting and route-merging with demand-aware customer reallocation to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random position with high demand concentration\n        split_pos = random.randint(1, len(route) - 2)\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity * 0.7:  # Only split if route is significantly over capacity\n            # Find split point with balanced demand\n            cumulative_demand = 0\n            for i in range(1, len(route) - 1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > total_demand / 2:\n                    split_pos = i\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Demand-aware reallocation within route\n            shuffled_nodes = route[1:-1].copy()\n            random.shuffle(shuffled_nodes)\n            new_route = [0]\n            current_load = 0\n            for node in shuffled_nodes:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    # Create new route if capacity exceeded\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n                    new_route = [0, node]\n                    current_load = demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    # Attempt route merging to reduce makespan\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if combined_load <= capacity:\n            # Calculate distance savings\n            original_dist = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] +\n                            distance_matrix[route2[-2], 0] + distance_matrix[0, route1[1]])\n            merged_dist = (distance_matrix[route1[-2], route2[1]] +\n                          distance_matrix[route2[-2], route1[1]] +\n                          distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]])\n            if merged_dist < original_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            56.92510321885821,
            4.950226713172887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random position with high demand concentration\n        split_pos = random.randint(1, len(route) - 2)\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity * 0.7:  # Only split if route is significantly over capacity\n            # Find split point with balanced demand\n            cumulative_demand = 0\n            for i in range(1, len(route) - 1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > total_demand / 2:\n                    split_pos = i\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Demand-aware reallocation within route\n            shuffled_nodes = route[1:-1].copy()\n            random.shuffle(shuffled_nodes)\n            new_route = [0]\n            current_load = 0\n            for node in shuffled_nodes:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    # Create new route if capacity exceeded\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n                    new_route = [0, node]\n                    current_load = demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    # Attempt route merging to reduce makespan\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if combined_load <= capacity:\n            # Calculate distance savings\n            original_dist = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] +\n                            distance_matrix[route2[-2], 0] + distance_matrix[0, route1[1]])\n            merged_dist = (distance_matrix[route1[-2], route2[1]] +\n                          distance_matrix[route2[-2], route1[1]] +\n                          distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]])\n            if merged_dist < original_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route-splitting and route-merging with demand-aware customer reallocation to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random position with high demand concentration\n        split_pos = random.randint(1, len(route) - 2)\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity * 0.7:  # Only split if route is significantly over capacity\n            # Find split point with balanced demand\n            cumulative_demand = 0\n            for i in range(1, len(route) - 1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > total_demand / 2:\n                    split_pos = i\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Demand-aware reallocation within route\n            shuffled_nodes = route[1:-1].copy()\n            random.shuffle(shuffled_nodes)\n            new_route = [0]\n            current_load = 0\n            for node in shuffled_nodes:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    # Create new route if capacity exceeded\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n                    new_route = [0, node]\n                    current_load = demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    # Attempt route merging to reduce makespan\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if combined_load <= capacity:\n            # Calculate distance savings\n            original_dist = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] +\n                            distance_matrix[route2[-2], 0] + distance_matrix[0, route1[1]])\n            merged_dist = (distance_matrix[route1[-2], route2[1]] +\n                          distance_matrix[route2[-2], route1[1]] +\n                          distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]])\n            if merged_dist < original_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            56.92510321885821,
            4.950226713172887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random position with high demand concentration\n        split_pos = random.randint(1, len(route) - 2)\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity * 0.7:  # Only split if route is significantly over capacity\n            # Find split point with balanced demand\n            cumulative_demand = 0\n            for i in range(1, len(route) - 1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > total_demand / 2:\n                    split_pos = i\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Demand-aware reallocation within route\n            shuffled_nodes = route[1:-1].copy()\n            random.shuffle(shuffled_nodes)\n            new_route = [0]\n            current_load = 0\n            for node in shuffled_nodes:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    # Create new route if capacity exceeded\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n                    new_route = [0, node]\n                    current_load = demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    # Attempt route merging to reduce makespan\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if combined_load <= capacity:\n            # Calculate distance savings\n            original_dist = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] +\n                            distance_matrix[route2[-2], 0] + distance_matrix[0, route1[1]])\n            merged_dist = (distance_matrix[route1[-2], route2[1]] +\n                          distance_matrix[route2[-2], route1[1]] +\n                          distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]])\n            if merged_dist < original_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and low makespan, then applies a hybrid local search combining route segment swaps and capacity-aware insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n",
        "score": [
            34.12927292928261,
            4.547996049453083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and low makespan, then applies a hybrid local search combining route segment swaps and capacity-aware insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n",
        "score": [
            34.12927292928261,
            4.547996049453083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and low makespan, then applies a hybrid local search combining route segment swaps and capacity-aware insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n",
        "score": [
            34.12927292928261,
            4.547996049453083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion, and adaptive 2-opt with capacity-aware swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes for merging\n        route_indices = list(range(len(new_solution)))\n        random.shuffle(route_indices)\n        route1_idx, route2_idx = route_indices[:2]\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution = np.delete(new_solution, [route1_idx, route2_idx], axis=0)\n            new_solution = np.append(new_solution, [merged_route], axis=0)\n        else:\n            # Step 2: Apply adaptive 2-opt with capacity constraints\n            for _ in range(2):  # Perform 2 swaps\n                for route in new_solution:\n                    if len(route) > 3:\n                        # Select two non-depot nodes\n                        i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                        # Check capacity feasibility\n                        segment = route[i:j+1]\n                        if sum(demand[segment[1:-1]]) <= capacity:\n                            # Reverse the segment\n                            route[i:j+1] = route[i:j+1][::-1]\n\n        # Step 3: Reinsertion heuristic\n        for route in new_solution:\n            if len(route) > 3:\n                # Remove a random customer\n                idx = random.randint(1, len(route)-2)\n                customer = route[idx]\n                # Remove customer from route\n                route = np.delete(route, idx)\n                # Find best insertion position in the same route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    # Insert customer at position pos\n                    new_route = np.insert(route, pos, customer)\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                # Insert at best position\n                route = np.insert(route, best_pos, customer)\n\n    return new_solution\n\n",
        "score": [
            52.644548519145474,
            6.153748613035552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search\n    if len(new_solution) > 1:\n        # Step 1: Randomly select two routes for merging\n        route_indices = list(range(len(new_solution)))\n        random.shuffle(route_indices)\n        route1_idx, route2_idx = route_indices[:2]\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes\n            merged_route = np.concatenate((route1[:-1], route2[1:]))\n            new_solution = np.delete(new_solution, [route1_idx, route2_idx], axis=0)\n            new_solution = np.append(new_solution, [merged_route], axis=0)\n        else:\n            # Step 2: Apply adaptive 2-opt with capacity constraints\n            for _ in range(2):  # Perform 2 swaps\n                for route in new_solution:\n                    if len(route) > 3:\n                        # Select two non-depot nodes\n                        i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                        # Check capacity feasibility\n                        segment = route[i:j+1]\n                        if sum(demand[segment[1:-1]]) <= capacity:\n                            # Reverse the segment\n                            route[i:j+1] = route[i:j+1][::-1]\n\n        # Step 3: Reinsertion heuristic\n        for route in new_solution:\n            if len(route) > 3:\n                # Remove a random customer\n                idx = random.randint(1, len(route)-2)\n                customer = route[idx]\n                # Remove customer from route\n                route = np.delete(route, idx)\n                # Find best insertion position in the same route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    # Insert customer at position pos\n                    new_route = np.insert(route, pos, customer)\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        cost = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                # Insert at best position\n                route = np.insert(route, best_pos, customer)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion with demand-aware repositioning, and a novel \"demand-weighted detour\" operator to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n        # Step 2: Customer reinsertion with demand-aware repositioning\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select a random customer to reposition\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n            # Remove customer from route\n            route = np.delete(route, cust_idx)\n            # Find the best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if pos == 1:\n                    segment_demand = np.sum(demand[route[pos:cust_idx+1]])\n                else:\n                    segment_demand = np.sum(demand[route[1:pos]]) + demand[customer] + np.sum(demand[route[pos:cust_idx+1]])\n                if segment_demand > capacity:\n                    continue\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer at best position\n            route = np.insert(route, best_pos, customer)\n\n        # Step 3: Demand-weighted detour operator (novel operator)\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select two random customers\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Calculate demand of the segment between i and j\n            segment_demand = np.sum(demand[route[i:j+1]])\n            # Calculate detour cost\n            prev_i = route[i-1]\n            next_i = route[i]\n            prev_j = route[j]\n            next_j = route[j+1]\n            original_cost = distance_matrix[prev_i, next_i] + distance_matrix[prev_j, next_j]\n            detour_cost = distance_matrix[prev_i, prev_j] + distance_matrix[next_i, next_j]\n            if detour_cost < original_cost and segment_demand <= capacity:\n                # Reverse the segment\n                route[i:j+1] = route[j:i-1:-1]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure feasibility (in case of any errors in the above steps)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            31.540135285188768,
            3.443251715263501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n        # Step 2: Customer reinsertion with demand-aware repositioning\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select a random customer to reposition\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n            # Remove customer from route\n            route = np.delete(route, cust_idx)\n            # Find the best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if pos == 1:\n                    segment_demand = np.sum(demand[route[pos:cust_idx+1]])\n                else:\n                    segment_demand = np.sum(demand[route[1:pos]]) + demand[customer] + np.sum(demand[route[pos:cust_idx+1]])\n                if segment_demand > capacity:\n                    continue\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer at best position\n            route = np.insert(route, best_pos, customer)\n\n        # Step 3: Demand-weighted detour operator (novel operator)\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select two random customers\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Calculate demand of the segment between i and j\n            segment_demand = np.sum(demand[route[i:j+1]])\n            # Calculate detour cost\n            prev_i = route[i-1]\n            next_i = route[i]\n            prev_j = route[j]\n            next_j = route[j+1]\n            original_cost = distance_matrix[prev_i, next_i] + distance_matrix[prev_j, next_j]\n            detour_cost = distance_matrix[prev_i, prev_j] + distance_matrix[next_i, next_j]\n            if detour_cost < original_cost and segment_demand <= capacity:\n                # Reverse the segment\n                route[i:j+1] = route[j:i-1:-1]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure feasibility (in case of any errors in the above steps)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion with demand-aware repositioning, and a novel \"demand-weighted detour\" operator to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n        # Step 2: Customer reinsertion with demand-aware repositioning\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select a random customer to reposition\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n            # Remove customer from route\n            route = np.delete(route, cust_idx)\n            # Find the best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if pos == 1:\n                    segment_demand = np.sum(demand[route[pos:cust_idx+1]])\n                else:\n                    segment_demand = np.sum(demand[route[1:pos]]) + demand[customer] + np.sum(demand[route[pos:cust_idx+1]])\n                if segment_demand > capacity:\n                    continue\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer at best position\n            route = np.insert(route, best_pos, customer)\n\n        # Step 3: Demand-weighted detour operator (novel operator)\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select two random customers\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Calculate demand of the segment between i and j\n            segment_demand = np.sum(demand[route[i:j+1]])\n            # Calculate detour cost\n            prev_i = route[i-1]\n            next_i = route[i]\n            prev_j = route[j]\n            next_j = route[j+1]\n            original_cost = distance_matrix[prev_i, next_i] + distance_matrix[prev_j, next_j]\n            detour_cost = distance_matrix[prev_i, prev_j] + distance_matrix[next_i, next_j]\n            if detour_cost < original_cost and segment_demand <= capacity:\n                # Reverse the segment\n                route[i:j+1] = route[j:i-1:-1]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure feasibility (in case of any errors in the above steps)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            31.540135285188768,
            3.443251715263501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n        # Step 2: Customer reinsertion with demand-aware repositioning\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select a random customer to reposition\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n            # Remove customer from route\n            route = np.delete(route, cust_idx)\n            # Find the best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if pos == 1:\n                    segment_demand = np.sum(demand[route[pos:cust_idx+1]])\n                else:\n                    segment_demand = np.sum(demand[route[1:pos]]) + demand[customer] + np.sum(demand[route[pos:cust_idx+1]])\n                if segment_demand > capacity:\n                    continue\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer at best position\n            route = np.insert(route, best_pos, customer)\n\n        # Step 3: Demand-weighted detour operator (novel operator)\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select two random customers\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Calculate demand of the segment between i and j\n            segment_demand = np.sum(demand[route[i:j+1]])\n            # Calculate detour cost\n            prev_i = route[i-1]\n            next_i = route[i]\n            prev_j = route[j]\n            next_j = route[j+1]\n            original_cost = distance_matrix[prev_i, next_i] + distance_matrix[prev_j, next_j]\n            detour_cost = distance_matrix[prev_i, prev_j] + distance_matrix[next_i, next_j]\n            if detour_cost < original_cost and segment_demand <= capacity:\n                # Reverse the segment\n                route[i:j+1] = route[j:i-1:-1]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure feasibility (in case of any errors in the above steps)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the lowest makespan and total distance, then applies a hybrid local search combining route merging, customer reinsertion with demand-aware repositioning, and a novel \"demand-weighted detour\" operator to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n        # Step 2: Customer reinsertion with demand-aware repositioning\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select a random customer to reposition\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n            # Remove customer from route\n            route = np.delete(route, cust_idx)\n            # Find the best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if pos == 1:\n                    segment_demand = np.sum(demand[route[pos:cust_idx+1]])\n                else:\n                    segment_demand = np.sum(demand[route[1:pos]]) + demand[customer] + np.sum(demand[route[pos:cust_idx+1]])\n                if segment_demand > capacity:\n                    continue\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer at best position\n            route = np.insert(route, best_pos, customer)\n\n        # Step 3: Demand-weighted detour operator (novel operator)\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select two random customers\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Calculate demand of the segment between i and j\n            segment_demand = np.sum(demand[route[i:j+1]])\n            # Calculate detour cost\n            prev_i = route[i-1]\n            next_i = route[i]\n            prev_j = route[j]\n            next_j = route[j+1]\n            original_cost = distance_matrix[prev_i, next_i] + distance_matrix[prev_j, next_j]\n            detour_cost = distance_matrix[prev_i, prev_j] + distance_matrix[next_i, next_j]\n            if detour_cost < original_cost and segment_demand <= capacity:\n                # Reverse the segment\n                route[i:j+1] = route[j:i-1:-1]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure feasibility (in case of any errors in the above steps)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n",
        "score": [
            31.540135285188768,
            3.443251715263501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        new_solution = [route.copy() for route in solution]\n\n        # Step 1: Route merging (if two routes can be combined without exceeding capacity)\n        if len(new_solution) > 1:\n            for i in range(len(new_solution)):\n                for j in range(i + 1, len(new_solution)):\n                    route1 = new_solution[i]\n                    route2 = new_solution[j]\n                    if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                        # Merge route2 into route1\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n        # Step 2: Customer reinsertion with demand-aware repositioning\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select a random customer to reposition\n            cust_idx = random.randint(1, len(route) - 2)\n            customer = route[cust_idx]\n            # Remove customer from route\n            route = np.delete(route, cust_idx)\n            # Find the best insertion position considering demand and distance\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                if pos == 1:\n                    segment_demand = np.sum(demand[route[pos:cust_idx+1]])\n                else:\n                    segment_demand = np.sum(demand[route[1:pos]]) + demand[customer] + np.sum(demand[route[pos:cust_idx+1]])\n                if segment_demand > capacity:\n                    continue\n                # Calculate insertion cost\n                prev_node = route[pos-1]\n                next_node = route[pos]\n                cost = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            # Insert customer at best position\n            route = np.insert(route, best_pos, customer)\n\n        # Step 3: Demand-weighted detour operator (novel operator)\n        for route in new_solution:\n            if len(route) <= 3:\n                continue\n            # Select two random customers\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n            # Calculate demand of the segment between i and j\n            segment_demand = np.sum(demand[route[i:j+1]])\n            # Calculate detour cost\n            prev_i = route[i-1]\n            next_i = route[i]\n            prev_j = route[j]\n            next_j = route[j+1]\n            original_cost = distance_matrix[prev_i, next_i] + distance_matrix[prev_j, next_j]\n            detour_cost = distance_matrix[prev_i, prev_j] + distance_matrix[next_i, next_j]\n            if detour_cost < original_cost and segment_demand <= capacity:\n                # Reverse the segment\n                route[i:j+1] = route[j:i-1:-1]\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Ensure feasibility (in case of any errors in the above steps)\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # If infeasible, revert to original route\n            new_solution = selected_solution.copy()\n            break\n\n    return new_solution\n\n"
    }
]