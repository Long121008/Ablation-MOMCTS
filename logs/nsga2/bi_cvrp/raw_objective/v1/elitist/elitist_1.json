[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and low makespan, then applies a hybrid local search combining route segment swaps and capacity-aware insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n",
        "score": [
            34.12927292928261,
            4.547996049453083
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route-splitting and route-merging with demand-aware customer reallocation to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: route-splitting and demand-aware reallocation\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route at a random position with high demand concentration\n        split_pos = random.randint(1, len(route) - 2)\n        total_demand = sum(demand[node] for node in route[1:-1])\n        if total_demand > capacity * 0.7:  # Only split if route is significantly over capacity\n            # Find split point with balanced demand\n            cumulative_demand = 0\n            for i in range(1, len(route) - 1):\n                cumulative_demand += demand[route[i]]\n                if cumulative_demand > total_demand / 2:\n                    split_pos = i\n                    break\n\n            # Create two new routes\n            new_route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n            # Check capacity feasibility\n            if (sum(demand[node] for node in new_route1[1:-1]) <= capacity and\n                sum(demand[node] for node in new_route2[1:-1]) <= capacity):\n                new_solution.extend([new_route1, new_route2])\n            else:\n                new_solution.append(route.copy())\n        else:\n            # Demand-aware reallocation within route\n            shuffled_nodes = route[1:-1].copy()\n            random.shuffle(shuffled_nodes)\n            new_route = [0]\n            current_load = 0\n            for node in shuffled_nodes:\n                if current_load + demand[node] <= capacity:\n                    new_route.append(node)\n                    current_load += demand[node]\n                else:\n                    # Create new route if capacity exceeded\n                    new_route.append(0)\n                    new_solution.append(np.array(new_route))\n                    new_route = [0, node]\n                    current_load = demand[node]\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    # Attempt route merging to reduce makespan\n    if len(new_solution) > 1:\n        i = random.randint(0, len(new_solution) - 2)\n        j = i + 1\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n        combined_load = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n        if combined_load <= capacity:\n            # Calculate distance savings\n            original_dist = (distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]] +\n                            distance_matrix[route2[-2], 0] + distance_matrix[0, route1[1]])\n            merged_dist = (distance_matrix[route1[-2], route2[1]] +\n                          distance_matrix[route2[-2], route1[1]] +\n                          distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]])\n            if merged_dist < original_dist:\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                del new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            56.92510321885821,
            4.950226713172887
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and low makespan, then applies a hybrid local search combining route segment swaps and capacity-aware insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine route segment swap and capacity-aware insertion\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two routes to swap segments\n    if len(new_solution) >= 2:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Ensure routes are long enough to swap segments\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segments to swap (avoid depot nodes)\n            seg1_start = random.randint(1, len(route1) - 3)\n            seg1_end = random.randint(seg1_start + 1, len(route1) - 2)\n            seg2_start = random.randint(1, len(route2) - 3)\n            seg2_end = random.randint(seg2_start + 1, len(route2) - 2)\n\n            # Extract segments\n            seg1 = route1[seg1_start:seg1_end]\n            seg2 = route2[seg2_start:seg2_end]\n\n            # Check capacity constraints\n            route1_demand = np.sum(demand[route1])\n            route2_demand = np.sum(demand[route2])\n            seg1_demand = np.sum(demand[seg1])\n            seg2_demand = np.sum(demand[seg2])\n\n            if (route1_demand - seg1_demand + seg2_demand <= capacity and\n                route2_demand - seg2_demand + seg1_demand <= capacity):\n\n                # Perform the swap\n                new_route1 = np.concatenate([route1[:seg1_start], seg2, route1[seg1_end:]])\n                new_route2 = np.concatenate([route2[:seg2_start], seg1, route2[seg2_end:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Step 2: Capacity-aware insertion (if any route is over capacity)\n    for i, route in enumerate(new_solution):\n        route_demand = np.sum(demand[route[1:-1]])  # Exclude depot nodes\n        if route_demand > capacity:\n            # Find customers to remove to restore feasibility\n            customers = route[1:-1]\n            random.shuffle(customers)\n            for customer in customers:\n                if route_demand <= capacity:\n                    break\n                route_demand -= demand[customer]\n                # Remove the customer from the route\n                new_solution[i] = np.delete(new_solution[i], np.where(new_solution[i] == customer))\n\n    return new_solution\n\n",
        "score": [
            34.12927292928261,
            4.547996049453083
        ]
    }
]