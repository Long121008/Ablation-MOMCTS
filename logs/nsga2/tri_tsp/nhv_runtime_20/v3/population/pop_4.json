[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a multi-objective-aware segment inversion with a probabilistic node reinsertion strategy, where segments are inverted based on objective imbalance and nodes are reinserted at positions that potentially improve multiple objectives simultaneously, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective-aware segment inversion\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    max_obj = max(obj1, obj2, obj3)\n    min_obj = min(obj1, obj2, obj3)\n\n    if max_obj / min_obj > 1.2:  # Significant imbalance\n        # Invert a segment based on the most imbalanced objective\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.6:\n        # Select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Calculate potential insertion positions based on all objectives\n        potential_positions = []\n        for pos in range(n):\n            if pos != k:\n                # Calculate total improvement across all objectives\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n                original_cost = (distance_matrix_1[prev_node, new_solution[k]] +\n                                distance_matrix_1[new_solution[k], next_node] +\n                                distance_matrix_2[prev_node, new_solution[k]] +\n                                distance_matrix_2[new_solution[k], next_node] +\n                                distance_matrix_3[prev_node, new_solution[k]] +\n                                distance_matrix_3[new_solution[k], next_node])\n\n                new_cost = (distance_matrix_1[prev_node, node] +\n                           distance_matrix_1[node, next_node] +\n                           distance_matrix_2[prev_node, node] +\n                           distance_matrix_2[node, next_node] +\n                           distance_matrix_3[prev_node, node] +\n                           distance_matrix_3[node, next_node])\n\n                potential_positions.append((pos, original_cost - new_cost))\n\n        # Sort by improvement and select top 3 positions\n        potential_positions.sort(key=lambda x: x[1], reverse=True)\n        top_positions = [pos for pos, _ in potential_positions[:3]]\n\n        if top_positions:\n            new_pos = random.choice(top_positions)\n            new_solution = np.delete(new_solution, k)\n            if new_pos > k:\n                new_pos -= 1\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7962119688266205,
            2.1493786692619326
        ]
    }
]