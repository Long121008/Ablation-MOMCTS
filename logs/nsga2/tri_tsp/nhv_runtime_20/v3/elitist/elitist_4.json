[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a multi-objective-aware segment inversion with a probabilistic node reinsertion strategy, where segments are inverted based on objective imbalance and nodes are reinserted at positions that potentially improve multiple objectives simultaneously, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective-aware segment inversion\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    max_obj = max(obj1, obj2, obj3)\n    min_obj = min(obj1, obj2, obj3)\n\n    if max_obj / min_obj > 1.2:  # Significant imbalance\n        # Invert a segment based on the most imbalanced objective\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.6:\n        # Select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Calculate potential insertion positions based on all objectives\n        potential_positions = []\n        for pos in range(n):\n            if pos != k:\n                # Calculate total improvement across all objectives\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n                original_cost = (distance_matrix_1[prev_node, new_solution[k]] +\n                                distance_matrix_1[new_solution[k], next_node] +\n                                distance_matrix_2[prev_node, new_solution[k]] +\n                                distance_matrix_2[new_solution[k], next_node] +\n                                distance_matrix_3[prev_node, new_solution[k]] +\n                                distance_matrix_3[new_solution[k], next_node])\n\n                new_cost = (distance_matrix_1[prev_node, node] +\n                           distance_matrix_1[node, next_node] +\n                           distance_matrix_2[prev_node, node] +\n                           distance_matrix_2[node, next_node] +\n                           distance_matrix_3[prev_node, node] +\n                           distance_matrix_3[node, next_node])\n\n                potential_positions.append((pos, original_cost - new_cost))\n\n        # Sort by improvement and select top 3 positions\n        potential_positions.sort(key=lambda x: x[1], reverse=True)\n        top_positions = [pos for pos, _ in potential_positions[:3]]\n\n        if top_positions:\n            new_pos = random.choice(top_positions)\n            new_solution = np.delete(new_solution, k)\n            if new_pos > k:\n                new_pos -= 1\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7962119688266205,
            2.1493786692619326
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a multi-objective-aware node exchange strategy with a probabilistic segment rotation operator to generate diverse neighbors by selectively swapping nodes based on their potential to improve different objectives while maintaining feasibility and exploring the objective space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple node swap for very small instances\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-objective-aware node exchange\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Select nodes based on objective improvement potential\n            if obj1 > obj2 and obj1 > obj3:\n                # Swap nodes to potentially improve first objective\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Swap nodes to potentially improve second objective\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap nodes to potentially improve third objective\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Probabilistic segment rotation based on objective diversity\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            rotation = random.randint(1, len(segment)-1)\n            new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7936938508391373,
            1.6824421286582947
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a multi-objective-aware segment inversion with a probabilistic node reinsertion strategy, where segments are inverted based on objective imbalance and nodes are reinserted at positions that potentially improve multiple objectives simultaneously, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective-aware segment inversion\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    max_obj = max(obj1, obj2, obj3)\n    min_obj = min(obj1, obj2, obj3)\n\n    if max_obj / min_obj > 1.2:  # Significant imbalance\n        # Invert a segment based on the most imbalanced objective\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.6:\n        # Select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Calculate potential insertion positions based on all objectives\n        potential_positions = []\n        for pos in range(n):\n            if pos != k:\n                # Calculate total improvement across all objectives\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n                original_cost = (distance_matrix_1[prev_node, new_solution[k]] +\n                                distance_matrix_1[new_solution[k], next_node] +\n                                distance_matrix_2[prev_node, new_solution[k]] +\n                                distance_matrix_2[new_solution[k], next_node] +\n                                distance_matrix_3[prev_node, new_solution[k]] +\n                                distance_matrix_3[new_solution[k], next_node])\n\n                new_cost = (distance_matrix_1[prev_node, node] +\n                           distance_matrix_1[node, next_node] +\n                           distance_matrix_2[prev_node, node] +\n                           distance_matrix_2[node, next_node] +\n                           distance_matrix_3[prev_node, node] +\n                           distance_matrix_3[node, next_node])\n\n                potential_positions.append((pos, original_cost - new_cost))\n\n        # Sort by improvement and select top 3 positions\n        potential_positions.sort(key=lambda x: x[1], reverse=True)\n        top_positions = [pos for pos, _ in potential_positions[:3]]\n\n        if top_positions:\n            new_pos = random.choice(top_positions)\n            new_solution = np.delete(new_solution, k)\n            if new_pos > k:\n                new_pos -= 1\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7962119688266205,
            2.1493786692619326
        ]
    },
    {
        "algorithm": "{A novel tri-objective local search algorithm that selects a solution from the archive based on its dominance in the objective space and applies a hybrid operator combining multi-objective-aware node swapping with a probabilistic segment reversal strategy to generate high-quality neighbors while maintaining feasibility and diversity in the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple node swap for very small instances\n        if n > 1:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-objective-aware node swapping\n        if random.random() < 0.7:\n            # Identify the objective with the highest value\n            obj1, obj2, obj3 = archive[selected_idx][1]\n            if obj1 > obj2 and obj1 > obj3:\n                # Swap nodes to potentially improve first objective\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Swap nodes to potentially improve second objective\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap nodes to potentially improve third objective\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Probabilistic segment reversal based on objective diversity\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7796940418970368,
            1.4372786998748779
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search combining 3-opt and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt to reverse the middle segment\n    if j - i > 1 and k - j > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Swap nodes at positions j and k\n    if k < n:\n        new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7264363348834688,
            1.2179297804832458
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects a solution from the archive based on Pareto dominance and applies a multi-objective-aware segment reversal operator combined with a probabilistic node insertion strategy to generate high-quality neighbors while ensuring feasibility and diversity in the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple node insertion for very small instances\n        if n > 1:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n    else:\n        # Multi-objective-aware segment reversal\n        if random.random() < 0.6:\n            # Select segment based on objective improvement potential\n            obj1, obj2, obj3 = archive[selected_idx][1]\n            if obj1 > obj2 and obj1 > obj3:\n                # Reverse segment to potentially improve first objective\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Reverse segment to potentially improve second objective\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # Reverse segment to potentially improve third objective\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Probabilistic node insertion based on objective diversity\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7892218452928199,
            1.6370792746543885
        ]
    },
    {
        "algorithm": "{This novel algorithm combines a multi-objective-aware node exchange strategy with a probabilistic segment rotation operator to generate diverse neighbors by selectively swapping nodes based on their potential to improve different objectives while maintaining feasibility and exploring the objective space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple node swap for very small instances\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-objective-aware node exchange\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Select nodes based on objective improvement potential\n            if obj1 > obj2 and obj1 > obj3:\n                # Swap nodes to potentially improve first objective\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Swap nodes to potentially improve second objective\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap nodes to potentially improve third objective\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Probabilistic segment rotation based on objective diversity\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            rotation = random.randint(1, len(segment)-1)\n            new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7936938508391373,
            1.6824421286582947
        ]
    },
    {
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects a solution from the archive based on objective diversity and applies a hybrid 2-opt and edge-swap operator, combined with a probabilistic multi-objective neighborhood exploration strategy, to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for very small instances\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or edge-swap based on objective diversity\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge-swap move\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7889967151711788,
            1.5882617592811585
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects a solution from the archive based on Pareto dominance and applies a multi-objective-aware segment reversal operator combined with a probabilistic node insertion strategy to generate high-quality neighbors while ensuring feasibility and diversity in the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple node insertion for very small instances\n        if n > 1:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n    else:\n        # Multi-objective-aware segment reversal\n        if random.random() < 0.6:\n            # Select segment based on objective improvement potential\n            obj1, obj2, obj3 = archive[selected_idx][1]\n            if obj1 > obj2 and obj1 > obj3:\n                # Reverse segment to potentially improve first objective\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Reverse segment to potentially improve second objective\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # Reverse segment to potentially improve third objective\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Probabilistic node insertion based on objective diversity\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7892218452928199,
            1.6370792746543885
        ]
    },
    {
        "algorithm": "{A novel tri-objective local search algorithm that intelligently selects a solution from the archive based on objective diversity and applies a hybrid 2-opt and edge-swap operator, combined with a probabilistic multi-objective neighborhood exploration strategy, to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for very small instances\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Decide between 2-opt or edge-swap based on objective diversity\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge-swap move\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7889967151711788,
            1.5882617592811585
        ]
    }
]