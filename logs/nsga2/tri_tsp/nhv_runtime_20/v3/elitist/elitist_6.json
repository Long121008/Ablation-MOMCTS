[
    {
        "algorithm": "{This novel algorithm employs a multi-objective-aware segment relocation strategy combined with a probabilistic 2-opt operator to generate diverse neighbors by selectively moving segments based on their potential to improve different objectives while maintaining feasibility and exploring the objective space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 2-opt for very small instances\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective-aware segment relocation\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.6:\n            # Relocate a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n            else:\n                # Focus on improving third objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n        else:\n            # Probabilistic 2-opt operator\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8246541809430937,
            1.7876460194587707
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective-aware segment relocation strategy combined with a probabilistic 2-opt operator to generate diverse neighbors by selectively moving segments based on their potential to improve different objectives while maintaining feasibility and exploring the objective space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 2-opt for very small instances\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective-aware segment relocation\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.6:\n            # Relocate a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n            else:\n                # Focus on improving third objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n        else:\n            # Probabilistic 2-opt operator\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8246541809430937,
            1.7876460194587707
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid of multi-objective-aware edge exchange and probabilistic segment inversion, dynamically balancing between exploiting high-potential edges and exploring diverse segment configurations to navigate the Pareto front more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for very small instances\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid edge exchange and segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Multi-objective-aware edge exchange\n            worst_obj = np.argmax([obj1, obj2, obj3])\n            if worst_obj == 0:\n                # Try to improve first objective by exchanging edges\n                i = random.randint(0, n-2)\n                j = random.randint(i+1, n-1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif worst_obj == 1:\n                # Try to improve second objective by exchanging edges\n                i = random.randint(0, n-2)\n                j = random.randint(i+1, n-1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Try to improve third objective by exchanging edges\n                i = random.randint(0, n-2)\n                j = random.randint(i+1, n-1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Probabilistic segment inversion\n            segment_length = random.randint(2, min(5, n//2))\n            i = random.randint(0, n - segment_length)\n            new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7893926859028475,
            1.4427825331687927
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective-aware segment inversion strategy combined with a probabilistic objective-weighted node insertion operator to generate diverse neighbors by flipping segments based on their potential to improve different objectives while maintaining feasibility and exploring the objective space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            weights = [obj1, obj2, obj3]\n            chosen_obj = random.choices([0, 1, 2], weights=weights)[0]\n            if chosen_obj == 0:\n                i, j = random.sample(range(n), 2)\n                if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif chosen_obj == 1:\n                i, j = random.sample(range(n), 2)\n                if distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                i, j = random.sample(range(n), 2)\n                if distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7991757436292384,
            1.6517740726470946
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective-aware segment relocation strategy combined with a probabilistic 2-opt operator to generate diverse neighbors by selectively moving segments based on their potential to improve different objectives while maintaining feasibility and exploring the objective space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 2-opt for very small instances\n        if n > 1:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective-aware segment relocation\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.6:\n            # Relocate a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n            else:\n                # Focus on improving third objective\n                segment_length = random.randint(2, min(5, n//2))\n                i = random.randint(0, n - segment_length)\n                j = random.randint(0, n - segment_length)\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n        else:\n            # Probabilistic 2-opt operator\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8246541809430937,
            1.7876460194587707
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective-aware node swap and insertion strategy that dynamically balances the three objectives by prioritizing swaps that simultaneously improve the two most imbalanced objectives, followed by strategic node insertions that enhance the least improved objective, with all operations validated for feasibility through a novel circular validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    objectives = [obj1, obj2, obj3]\n    sorted_objs = sorted(objectives)\n    worst_obj = objectives.index(sorted_objs[-1])\n    middle_obj = objectives.index(sorted_objs[1])\n\n    # Multi-objective-aware node swap\n    if sorted_objs[-1] / sorted_objs[0] > 1.1:\n        i, j = random.sample(range(n), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    # Dynamic node insertion based on least improved objective\n    if random.random() < 0.7:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        potential_positions = []\n        for pos in range(n):\n            if pos != k:\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n                original_cost = 0\n                new_cost = 0\n\n                if worst_obj == 0:\n                    original_cost += distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n                    new_cost += distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                elif worst_obj == 1:\n                    original_cost += distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n                    new_cost += distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                else:\n                    original_cost += distance_matrix_3[prev_node, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n                    new_cost += distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n                potential_positions.append((pos, original_cost - new_cost))\n\n        potential_positions.sort(key=lambda x: x[1], reverse=True)\n        top_positions = [pos for pos, _ in potential_positions[:2]]\n\n        if top_positions:\n            new_pos = random.choice(top_positions)\n            new_solution = np.delete(new_solution, k)\n            if new_pos > k:\n                new_pos -= 1\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Circular validation for feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        for i in range(n):\n            if new_solution[i] != i and random.random() < 0.3:\n                j = (i + 1) % n\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7617701942049617,
            1.3369285345077515
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{A novel tri-objective local search algorithm that selects a solution from the archive based on its dominance in the objective space and applies a hybrid operator combining multi-objective-aware node swapping with a probabilistic segment reversal strategy to generate high-quality neighbors while maintaining feasibility and diversity in the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple node swap for very small instances\n        if n > 1:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-objective-aware node swapping\n        if random.random() < 0.7:\n            # Identify the objective with the highest value\n            obj1, obj2, obj3 = archive[selected_idx][1]\n            if obj1 > obj2 and obj1 > obj3:\n                # Swap nodes to potentially improve first objective\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Swap nodes to potentially improve second objective\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap nodes to potentially improve third objective\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Probabilistic segment reversal based on objective diversity\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7796940418970368,
            1.4372786998748779
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search combining 3-opt and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt to reverse the middle segment\n    if j - i > 1 and k - j > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Swap nodes at positions j and k\n    if k < n:\n        new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7264363348834688,
            1.2179297804832458
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt within the segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6397416737521138,
            0.9267171859741211
        ]
    }
]