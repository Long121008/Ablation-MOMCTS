[
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific node swapping with a probabilistic 4-opt operator to generate diverse neighbors by adaptively swapping nodes based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        if n > 2:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            segment3 = new_solution[k+1:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3, new_solution[l+1:]])\n    else:\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            if obj1 > obj2 and obj1 > obj3:\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif obj2 > obj1 and obj2 > obj3:\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            segment3 = new_solution[k+1:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3, new_solution[l+1:]])\n\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7440169324499242,
            1.2734417200088501
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective-aware segment relocation with adaptive 2-opt and probabilistic edge exchange to generate diverse neighbors by intelligently relocating segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 2-opt for very small instances\n        if n > 1:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective-aware segment relocation\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.6:\n            # Relocate a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j, k = sorted(random.sample(range(n), 3))\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j, k = sorted(random.sample(range(n), 3))\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n            else:\n                # Focus on improving third objective\n                i, j, k = sorted(random.sample(range(n), 3))\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n        elif random.random() < 0.8:\n            # Adaptive 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Probabilistic edge exchange\n            i, j = random.sample(range(n), 2)\n            new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7573885333774432,
            1.2917455196380616
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    }
]