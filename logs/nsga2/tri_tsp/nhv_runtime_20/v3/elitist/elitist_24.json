[
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid of objective-weighted node relocation with adaptive segment rotation, where nodes are relocated based on their contribution to each objective's improvement while segments are rotated probabilistically to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best overall objective balance\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    obj1, obj2, obj3 = archive[selected_idx][1]\n\n    n = len(new_solution)\n\n    # Calculate objective weights\n    total_obj = obj1 + obj2 + obj3\n    weight1 = obj1 / total_obj\n    weight2 = obj2 / total_obj\n    weight3 = obj3 / total_obj\n\n    # Select a node to relocate based on objective weights\n    if random.random() < 0.7:\n        # Relocate a node to improve the worst objective\n        worst_obj = max(obj1, obj2, obj3)\n        if worst_obj == obj1:\n            candidate_nodes = np.argsort([distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)])\n        elif worst_obj == obj2:\n            candidate_nodes = np.argsort([distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)])\n        else:\n            candidate_nodes = np.argsort([distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)])\n\n        node_to_move = candidate_nodes[0]\n        insert_pos = random.randint(0, n-1)\n\n        # Perform relocation\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Rotate a segment to balance objectives\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[i:j+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8030897205391831,
            1.287675678730011
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-aware segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance, and swaps are performed with probabilities proportional to the objective differences, ensuring balanced exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                swap_prob = min(1.0, (diff1 + diff2 + diff3) / 10.0)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7902382938868626,
            0.28546746969223025
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid segment exchange with adaptive dominance-based swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, but with a focus on the worst-performing objective to balance optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Identify the worst objective for each solution\n    worst_obj1 = max(obj1_1, obj2_1, obj3_1)\n    worst_obj2 = max(obj1_2, obj2_2, obj3_2)\n\n    # Determine segment exchange based on worst objective\n    if worst_obj1 > worst_obj2:\n        exchange_point = int(len(sol1) * 0.3)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.7)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6988340321239128,
            0.22127557992935182
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This algorithm uses a dominance-based segment exchange with adaptive probabilistic swaps, where segments are exchanged based on objective dominance and swaps are performed with probabilities inversely proportional to the objective differences, ensuring balanced exploration of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Calculate dominance scores\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Determine segment exchange based on dominance\n    if dominance1 > dominance2:\n        exchange_point = int(len(sol1) * 0.4)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    elif dominance2 > dominance1:\n        exchange_point = int(len(sol1) * 0.6)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n    else:\n        exchange_point = int(len(sol1) * 0.5)\n        new_solution = np.concatenate([sol1[:exchange_point], sol2[exchange_point:]])\n\n    # Apply probabilistic swaps based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.4:  # 40% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate objective differences\n                diff1 = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n                diff2 = abs(distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n                diff3 = abs(distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n                # Calculate swap probability based on objective differences\n                swap_prob = 1.0 / (1.0 + diff1 + diff2 + diff3)\n\n                if random.random() < swap_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7330828644537613,
            0.26986863613128664
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    }
]