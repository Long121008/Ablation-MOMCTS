[
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective crossover-based perturbation that combines segments from different solutions in the archive with a probabilistic node swap operator to generate neighbors that balance exploration and exploitation across all three objectives by adaptively selecting crossover points and swap probabilities based on objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Determine crossover points based on objective dominance\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Calculate dominance scores\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Select crossover point based on dominance\n    if dominance1 > dominance2:\n        crossover_point = int(len(sol1) * 0.3)\n    elif dominance2 > dominance1:\n        crossover_point = int(len(sol1) * 0.7)\n    else:\n        crossover_point = int(len(sol1) * 0.5)\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([sol1[:crossover_point], sol2[crossover_point:]])\n\n    # Apply probabilistic node swap based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate potential improvement in objectives\n                current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                current_obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                # Swap if at least one objective improves\n                if (new_obj1 < current_obj1) or (new_obj2 < current_obj2) or (new_obj3 < current_obj3):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        # If not feasible, fall back to a simple swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.720484889566133,
            0.3407354116439819
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective crossover-based perturbation that combines segments from different solutions in the archive with a probabilistic node swap operator to generate neighbors that balance exploration and exploitation across all three objectives by adaptively selecting crossover points and swap probabilities based on objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Determine crossover points based on objective dominance\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Calculate dominance scores\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Select crossover point based on dominance\n    if dominance1 > dominance2:\n        crossover_point = int(len(sol1) * 0.3)\n    elif dominance2 > dominance1:\n        crossover_point = int(len(sol1) * 0.7)\n    else:\n        crossover_point = int(len(sol1) * 0.5)\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([sol1[:crossover_point], sol2[crossover_point:]])\n\n    # Apply probabilistic node swap based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate potential improvement in objectives\n                current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                current_obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                # Swap if at least one objective improves\n                if (new_obj1 < current_obj1) or (new_obj2 < current_obj2) or (new_obj3 < current_obj3):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        # If not feasible, fall back to a simple swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.720484889566133,
            0.3407354116439819
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective adaptive segment exchange strategy that dynamically selects and exchanges segments based on the current objective dominance, combining probabilistic 2-opt and 4-opt moves with a novel segment inversion operator to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    obj1, obj2, obj3 = archive[selected_idx][1]\n\n    if n < 5:\n        # Simple 2-opt for very small instances\n        if n > 1:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Adaptive segment exchange strategy\n        if random.random() < 0.6:\n            # Determine which objective to prioritize\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 4-opt operator\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            segment3 = new_solution[k+1:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3, new_solution[l+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7294757570229432,
            1.2750949621200562
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a multi-objective crossover-based perturbation that combines segments from different solutions in the archive with a probabilistic node swap operator to generate neighbors that balance exploration and exploitation across all three objectives by adaptively selecting crossover points and swap probabilities based on objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two solutions from the archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1 = archive[idx1][0]\n    sol2 = archive[idx2][0]\n\n    # Determine crossover points based on objective dominance\n    obj1_1, obj2_1, obj3_1 = archive[idx1][1]\n    obj1_2, obj2_2, obj3_2 = archive[idx2][1]\n\n    # Calculate dominance scores\n    dominance1 = (obj1_1 < obj1_2) + (obj2_1 < obj2_2) + (obj3_1 < obj3_2)\n    dominance2 = (obj1_2 < obj1_1) + (obj2_2 < obj2_1) + (obj3_2 < obj3_1)\n\n    # Select crossover point based on dominance\n    if dominance1 > dominance2:\n        crossover_point = int(len(sol1) * 0.3)\n    elif dominance2 > dominance1:\n        crossover_point = int(len(sol1) * 0.7)\n    else:\n        crossover_point = int(len(sol1) * 0.5)\n\n    # Create new solution by combining segments\n    new_solution = np.concatenate([sol1[:crossover_point], sol2[crossover_point:]])\n\n    # Apply probabilistic node swap based on objective differences\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, len(new_solution)-1)\n            if i != j:\n                # Calculate potential improvement in objectives\n                current_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                current_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                current_obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%len(new_solution)]]\n\n                # Swap if at least one objective improves\n                if (new_obj1 < current_obj1) or (new_obj2 < current_obj2) or (new_obj3 < current_obj3):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != len(new_solution) or not np.array_equal(np.sort(new_solution), np.arange(len(new_solution))):\n        # If not feasible, fall back to a simple swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.720484889566133,
            0.3407354116439819
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid approach combining objective-specific segment inversion with a probabilistic 3-opt operator to generate diverse neighbors by adaptively inverting segments based on their objective improvement potential while maintaining feasibility and exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple 3-opt for very small instances\n        if n > 2:\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n    else:\n        # Objective-specific segment inversion\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        if random.random() < 0.7:\n            # Invert a segment to potentially improve the dominant objective\n            if obj1 > obj2 and obj1 > obj3:\n                # Focus on improving first objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            elif obj2 > obj1 and obj2 > obj3:\n                # Focus on improving second objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                # Focus on improving third objective\n                i, j = sorted(random.sample(range(n), 2))\n                segment = new_solution[i:j+1]\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            # Probabilistic 3-opt operator\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599848867867624,
            1.3249224543571472
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search combining 3-opt and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt to reverse the middle segment\n    if j - i > 1 and k - j > 1:\n        segment = new_solution[i:j+1]\n        segment = np.concatenate([segment[:1], segment[1:][::-1]])\n        new_solution[i:j+1] = segment\n\n    # Swap nodes at positions j and k\n    if k < n:\n        new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7264363348834688,
            1.2179297804832458
        ]
    }
]