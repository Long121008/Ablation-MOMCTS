[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This new algorithm employs a multi-objective edge-based crossover operator that intelligently combines segments from two randomly selected solutions in the archive, using a dominance-aware selection mechanism to prioritize edges that improve at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        raise ValueError(\"Archive must contain at least two solutions\")\n\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n    obj1, obj2, obj3 = archive[idx1][1]\n    obj21, obj22, obj23 = archive[idx2][1]\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n    visited = set()\n\n    # Select starting node from first solution\n    start_node = sol1[0]\n    new_solution[0] = start_node\n    visited.add(start_node)\n\n    # Build new solution by alternating between solutions\n    for i in range(1, n):\n        if i % 2 == 0:\n            # Try to add next node from first solution\n            for node in sol1:\n                if node not in visited:\n                    # Check if adding this edge improves at least one objective\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] < distance_matrix_1[last_node, sol2[np.where(sol2 == node)[0][0]-1 if np.where(sol2 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_2[last_node, node] < distance_matrix_2[last_node, sol2[np.where(sol2 == node)[0][0]-1 if np.where(sol2 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_3[last_node, node] < distance_matrix_3[last_node, sol2[np.where(sol2 == node)[0][0]-1 if np.where(sol2 == node)[0][0] > 0 else -1]]):\n                        new_solution[i] = node\n                        visited.add(node)\n                        break\n        else:\n            # Try to add next node from second solution\n            for node in sol2:\n                if node not in visited:\n                    # Check if adding this edge improves at least one objective\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] < distance_matrix_1[last_node, sol1[np.where(sol1 == node)[0][0]-1 if np.where(sol1 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_2[last_node, node] < distance_matrix_2[last_node, sol1[np.where(sol1 == node)[0][0]-1 if np.where(sol1 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_3[last_node, node] < distance_matrix_3[last_node, sol1[np.where(sol1 == node)[0][0]-1 if np.where(sol1 == node)[0][0] > 0 else -1]]):\n                        new_solution[i] = node\n                        visited.add(node)\n                        break\n\n    # Ensure all nodes are visited\n    remaining_nodes = [node for node in range(n) if node not in visited]\n    if remaining_nodes:\n        for i in range(n):\n            if new_solution[i] == 0:\n                new_solution[i] = remaining_nodes.pop(0)\n                if not remaining_nodes:\n                    break\n\n    # Close the tour\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6706436675888735,
            1.2162272930145264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        raise ValueError(\"Archive must contain at least two solutions\")\n\n    idx1, idx2 = np.random.choice(len(archive), 2, replace=False)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n    obj1, obj2, obj3 = archive[idx1][1]\n    obj21, obj22, obj23 = archive[idx2][1]\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n    visited = set()\n\n    # Select starting node from first solution\n    start_node = sol1[0]\n    new_solution[0] = start_node\n    visited.add(start_node)\n\n    # Build new solution by alternating between solutions\n    for i in range(1, n):\n        if i % 2 == 0:\n            # Try to add next node from first solution\n            for node in sol1:\n                if node not in visited:\n                    # Check if adding this edge improves at least one objective\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] < distance_matrix_1[last_node, sol2[np.where(sol2 == node)[0][0]-1 if np.where(sol2 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_2[last_node, node] < distance_matrix_2[last_node, sol2[np.where(sol2 == node)[0][0]-1 if np.where(sol2 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_3[last_node, node] < distance_matrix_3[last_node, sol2[np.where(sol2 == node)[0][0]-1 if np.where(sol2 == node)[0][0] > 0 else -1]]):\n                        new_solution[i] = node\n                        visited.add(node)\n                        break\n        else:\n            # Try to add next node from second solution\n            for node in sol2:\n                if node not in visited:\n                    # Check if adding this edge improves at least one objective\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] < distance_matrix_1[last_node, sol1[np.where(sol1 == node)[0][0]-1 if np.where(sol1 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_2[last_node, node] < distance_matrix_2[last_node, sol1[np.where(sol1 == node)[0][0]-1 if np.where(sol1 == node)[0][0] > 0 else -1]] or\n                        distance_matrix_3[last_node, node] < distance_matrix_3[last_node, sol1[np.where(sol1 == node)[0][0]-1 if np.where(sol1 == node)[0][0] > 0 else -1]]):\n                        new_solution[i] = node\n                        visited.add(node)\n                        break\n\n    # Ensure all nodes are visited\n    remaining_nodes = [node for node in range(n) if node not in visited]\n    if remaining_nodes:\n        for i in range(n):\n            if new_solution[i] == 0:\n                new_solution[i] = remaining_nodes.pop(0)\n                if not remaining_nodes:\n                    break\n\n    # Close the tour\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new algorithm employs a multi-objective adaptive edge-swapping strategy that dynamically evaluates and swaps edges based on their cumulative improvement potential across all three objectives, using a hybrid of dominance-based selection and objective-weighted probability to prioritize edges that show the most balanced improvement across all dimensions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    candidates = []\n    for i in range(n - 1):\n        a, b = new_solution[i], new_solution[i+1]\n        for j in range(i+2, n-1):\n            c, d = new_solution[j], new_solution[j+1]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n            weighted_delta = delta1 * obj_weights[0] + delta2 * obj_weights[1] + delta3 * obj_weights[2]\n            candidates.append((weighted_delta, i, j))\n\n    if not candidates:\n        return new_solution\n\n    candidates.sort(key=lambda x: x[0])\n    best_delta, i, j = candidates[0]\n\n    if best_delta < 0:\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.700633000796574,
            2.4868159651756288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    candidates = []\n    for i in range(n - 1):\n        a, b = new_solution[i], new_solution[i+1]\n        for j in range(i+2, n-1):\n            c, d = new_solution[j], new_solution[j+1]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n            weighted_delta = delta1 * obj_weights[0] + delta2 * obj_weights[1] + delta3 * obj_weights[2]\n            candidates.append((weighted_delta, i, j))\n\n    if not candidates:\n        return new_solution\n\n    candidates.sort(key=lambda x: x[0])\n    best_delta, i, j = candidates[0]\n\n    if best_delta < 0:\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This new algorithm employs a multi-objective hybrid crossover operator that combines segments from multiple elite solutions in the archive, using a dominance-based selection mechanism to ensure the new solution inherits the best characteristics across all three objectives while maintaining feasibility through a specialized repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_indices = np.random.choice(len(archive), size=min(3, len(archive)), replace=False)\n    elite_solutions = [archive[i][0] for i in selected_indices]\n    n = len(elite_solutions[0])\n\n    new_solution = np.zeros(n, dtype=int)\n    used_nodes = set()\n\n    for i in range(n):\n        candidate_nodes = []\n        for sol in elite_solutions:\n            node = sol[i]\n            if node not in used_nodes:\n                candidate_nodes.append(node)\n\n        if not candidate_nodes:\n            remaining_nodes = [node for node in range(n) if node not in used_nodes]\n            node = np.random.choice(remaining_nodes)\n        else:\n            node = np.random.choice(candidate_nodes)\n\n        new_solution[i] = node\n        used_nodes.add(node)\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.7164901450223152,
            0.9922717213630676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_indices = np.random.choice(len(archive), size=min(3, len(archive)), replace=False)\n    elite_solutions = [archive[i][0] for i in selected_indices]\n    n = len(elite_solutions[0])\n\n    new_solution = np.zeros(n, dtype=int)\n    used_nodes = set()\n\n    for i in range(n):\n        candidate_nodes = []\n        for sol in elite_solutions:\n            node = sol[i]\n            if node not in used_nodes:\n                candidate_nodes.append(node)\n\n        if not candidate_nodes:\n            remaining_nodes = [node for node in range(n) if node not in used_nodes]\n            node = np.random.choice(remaining_nodes)\n        else:\n            node = np.random.choice(candidate_nodes)\n\n        new_solution[i] = node\n        used_nodes.add(node)\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This new algorithm employs a hybrid of dominance-based segment selection and adaptive 2-opt moves, where segments are chosen based on their potential for multi-objective improvement, and 2-opt exchanges are performed with probability proportional to the segment's contribution to each objective, ensuring feasibility while promoting diverse exploration in all three objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its crowding distance (promising for improvement)\n    crowding_distances = [archive[i][2] if len(archive[i]) > 2 else 1.0 for i in range(len(archive))]\n    selected_idx = np.random.choice(len(archive), p=np.array(crowding_distances)/sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment based on its contribution to each objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    # Perform a 2-opt move with probability proportional to segment's contribution\n    if np.random.rand() < 0.7:\n        # Choose which objective to prioritize for the move\n        obj_choice = np.random.choice([0, 1, 2], p=obj_weights)\n        if obj_choice == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_choice == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the best 2-opt move in the selected objective space\n        best_gain = 0\n        best_i, best_j = -1, -1\n        for i in range(n-1):\n            for j in range(i+2, n):\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n                current_cost = dist_matrix[a,b] + dist_matrix[c,d]\n                new_cost = dist_matrix[a,c] + dist_matrix[b,d]\n                gain = current_cost - new_cost\n                if gain > best_gain:\n                    best_gain = gain\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Perform the 2-opt move\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7377192626852671,
            1.0518113374710083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its crowding distance (promising for improvement)\n    crowding_distances = [archive[i][2] if len(archive[i]) > 2 else 1.0 for i in range(len(archive))]\n    selected_idx = np.random.choice(len(archive), p=np.array(crowding_distances)/sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment based on its contribution to each objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    # Perform a 2-opt move with probability proportional to segment's contribution\n    if np.random.rand() < 0.7:\n        # Choose which objective to prioritize for the move\n        obj_choice = np.random.choice([0, 1, 2], p=obj_weights)\n        if obj_choice == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_choice == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the best 2-opt move in the selected objective space\n        best_gain = 0\n        best_i, best_j = -1, -1\n        for i in range(n-1):\n            for j in range(i+2, n):\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n                current_cost = dist_matrix[a,b] + dist_matrix[c,d]\n                new_cost = dist_matrix[a,c] + dist_matrix[b,d]\n                gain = current_cost - new_cost\n                if gain > best_gain:\n                    best_gain = gain\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Perform the 2-opt move\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{The new algorithm employs an adaptive multi-segment inversion operator that probabilistically selects and inverts multiple non-overlapping segments based on their potential to improve all three objectives, followed by a targeted node swap step that prioritizes nodes with the highest individual improvement potential across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0 and len(set(segment)) == len(segment):\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(3):\n        i = np.random.choice(n)\n        neighbors = [new_solution[(i-1)%n], new_solution[(i+1)%n]]\n        best_j = -1\n        best_imp = 0\n\n        for j in neighbors:\n            if j == i:\n                continue\n            imp1 = (distance_matrix_1[new_solution[i-1], j] + distance_matrix_1[j, new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], j] + distance_matrix_2[j, new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], j] + distance_matrix_3[j, new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n            total_imp = imp1 + imp2 + imp3\n            if total_imp < best_imp:\n                best_imp = total_imp\n                best_j = j\n\n        if best_j != -1:\n            j_idx = np.where(new_solution == best_j)[0][0]\n            new_solution[i], new_solution[j_idx] = new_solution[j_idx], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7969970449077535,
            1.518163800239563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0 and len(set(segment)) == len(segment):\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(3):\n        i = np.random.choice(n)\n        neighbors = [new_solution[(i-1)%n], new_solution[(i+1)%n]]\n        best_j = -1\n        best_imp = 0\n\n        for j in neighbors:\n            if j == i:\n                continue\n            imp1 = (distance_matrix_1[new_solution[i-1], j] + distance_matrix_1[j, new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], j] + distance_matrix_2[j, new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], j] + distance_matrix_3[j, new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n            total_imp = imp1 + imp2 + imp3\n            if total_imp < best_imp:\n                best_imp = total_imp\n                best_j = j\n\n        if best_j != -1:\n            j_idx = np.where(new_solution == best_j)[0][0]\n            new_solution[i], new_solution[j_idx] = new_solution[j_idx], new_solution[i]\n\n    return new_solution\n\n"
    }
]