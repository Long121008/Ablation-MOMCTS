[
    {
        "algorithm": "{The new algorithm combines objective-aware selection with a multi-objective edge swap operator that dynamically prioritizes objectives based on their relative improvement potential and applies a sequence of edge swaps to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Perform multi-objective edge swaps\n    for _ in range(2):  # Number of swaps to perform\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:  # Only accept if at least one objective improves\n            # Perform the edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8105122162404218,
            2.554188632965088
        ]
    },
    {
        "algorithm": "{The new algorithm employs a dynamic objective-weighted 2-opt* operator that adaptively selects segments based on their potential to improve multiple objectives, followed by a probabilistic edge insertion step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Dynamic 2-opt* operator with objective weighting\n    for _ in range(3):\n        # Select two distinct segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n             distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n             distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]] +\n             distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]])\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            # Perform the 2-opt* operation\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Probabilistic edge insertion for further refinement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and j != (i+1)%n:\n            # Calculate potential improvement\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                # Perform the edge insertion\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], [new_solution[j]], new_solution[i:j]])\n\n    return new_solution\n\n",
        "score": [
            -0.616468218701707,
            0.9766801118850708
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-aware selection with a multi-objective edge swap operator that dynamically prioritizes objectives based on their relative improvement potential and applies a sequence of edge swaps to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Perform multi-objective edge swaps\n    for _ in range(2):  # Number of swaps to perform\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:  # Only accept if at least one objective improves\n            # Perform the edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8105122162404218,
            2.554188632965088
        ]
    },
    {
        "algorithm": "{The new algorithm employs a dynamic objective-weighted 2-opt* operator that adaptively selects segments based on their potential to improve multiple objectives, followed by a probabilistic edge insertion step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Dynamic 2-opt* operator with objective weighting\n    for _ in range(3):\n        # Select two distinct segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n             distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n             distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]] +\n             distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]])\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            # Perform the 2-opt* operation\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Probabilistic edge insertion for further refinement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and j != (i+1)%n:\n            # Calculate potential improvement\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                # Perform the edge insertion\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], [new_solution[j]], new_solution[i:j]])\n\n    return new_solution\n\n",
        "score": [
            -0.616468218701707,
            0.9766801118850708
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-aware selection with a multi-objective edge swap operator that dynamically prioritizes objectives based on their relative improvement potential and applies a sequence of edge swaps to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Perform multi-objective edge swaps\n    for _ in range(2):  # Number of swaps to perform\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:  # Only accept if at least one objective improves\n            # Perform the edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8105122162404218,
            2.554188632965088
        ]
    },
    {
        "algorithm": "{This algorithm combines a multi-objective path reversal operator with dynamic objective prioritization, where it selectively reverses segments of the tour based on their potential to improve the least improved objective, while maintaining feasibility through careful segment selection and boundary checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Identify the least improved objective\n    least_improved = np.argmin(obj_weights)\n\n    # Perform path reversal based on the least improved objective\n    for _ in range(2):  # Number of reversals to perform\n        # Select a random segment to reverse\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(6, n))\n        end = (start + length) % n\n\n        if start < end:\n            # Reverse the segment\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Handle circular reversal\n            segment = np.concatenate((new_solution[start:], new_solution[:end]))\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    return new_solution\n\n",
        "score": [
            -0.7553432920031857,
            1.6500617504119872
        ]
    },
    {
        "algorithm": "{The new algorithm combines multi-objective adaptive selection with a hybrid local search that dynamically prioritizes objectives based on their relative improvement potential and applies a sequence of edge swaps and node insertions to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Perform hybrid local search\n    for _ in range(3):  # Number of operations to perform\n        operation = np.random.choice(['swap', 'insert'])\n\n        if operation == 'swap':\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n\n            # Calculate potential improvement for each objective\n            improvements = [\n                (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n                (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n                (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n                (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n            ]\n\n            # Weighted improvement score\n            weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n            if weighted_improvement < 0:  # Only accept if at least one objective improves\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'insert':\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n\n            # Calculate potential improvement for each objective\n            improvements = [\n                (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n                (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n                (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n                (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n            ]\n\n            # Weighted improvement score\n            weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n            if weighted_improvement < 0:  # Only accept if at least one objective improves\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7908408397737935,
            2.0616236209869383
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-aware selection with a multi-objective edge swap operator that dynamically prioritizes objectives based on their relative improvement potential and applies a sequence of edge swaps to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Perform multi-objective edge swaps\n    for _ in range(2):  # Number of swaps to perform\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:  # Only accept if at least one objective improves\n            # Perform the edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8105122162404218,
            2.554188632965088
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on its diversity and applies a multi-objective crossover operator that combines segments from different solutions while ensuring feasibility, then performs a sequence of objective-aware edge insertions to further improve the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution (not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply multi-objective crossover with another random solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Determine crossover points\n        n = len(new_solution)\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n\n        # Create a new solution by combining segments from both solutions\n        new_solution = np.concatenate([\n            new_solution[:start],\n            other_solution[start:end],\n            new_solution[end:]\n        ])\n\n        # Remove duplicates and fill missing nodes\n        missing_nodes = set(base_solution) - set(new_solution)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n        # Ensure feasibility by removing extra nodes\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n\n    # Perform objective-aware edge insertions\n    n = len(new_solution)\n    for _ in range(3):  # Number of insertions to perform\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(imp < 0 for imp in improvements):\n            # Perform the edge insertion\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7048508650408577,
            1.21216059923172
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with highest sum of normalized values\n    obj_values = np.array([obj for _, obj in archive])\n    normalized_obj = (obj_values - obj_values.min(axis=0)) / (obj_values.max(axis=0) - obj_values.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge swap operator\n    n = len(new_solution)\n    for _ in range(5):  # Limit iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid start-end swap\n\n        # Calculate change in all objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                     distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7319517281006799,
            1.627416455745697
        ]
    },
    {
        "algorithm": "{The new algorithm combines objective-aware selection with a multi-objective edge swap operator that dynamically prioritizes objectives based on their relative improvement potential and applies a sequence of edge swaps to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Perform multi-objective edge swaps\n    for _ in range(2):  # Number of swaps to perform\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]),\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:  # Only accept if at least one objective improves\n            # Perform the edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8105122162404218,
            2.554188632965088
        ]
    }
]