[
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective segment relocation heuristic that dynamically selects and relocates segments of the tour based on their potential to improve all three objectives simultaneously, followed by a probabilistic segment inversion step to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Multi-objective segment relocation heuristic\n    for _ in range(3):\n        # Select a segment to relocate\n        seg_start = np.random.randint(n)\n        seg_length = np.random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Select a new position to insert the segment\n        insert_pos = np.random.randint(n)\n\n        # Calculate potential improvement for each objective\n        if seg_end > seg_start:\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            remaining = new_solution[seg_end:seg_start]\n\n        # Calculate improvement from removing the segment\n        prev_node = remaining[-1] if len(remaining) > 0 else remaining[0]\n        next_node = remaining[0] if len(remaining) > 0 else remaining[-1]\n\n        imp1_remove = distance_matrix_1[prev_node, next_node] - (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node])\n        imp2_remove = distance_matrix_2[prev_node, next_node] - (distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n        imp3_remove = distance_matrix_3[prev_node, next_node] - (distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node])\n\n        # Calculate improvement from inserting the segment\n        new_prev = new_solution[insert_pos-1]\n        new_next = new_solution[insert_pos]\n\n        imp1_insert = (distance_matrix_1[new_prev, segment[0]] + distance_matrix_1[segment[-1], new_next]) - distance_matrix_1[new_prev, new_next]\n        imp2_insert = (distance_matrix_2[new_prev, segment[0]] + distance_matrix_2[segment[-1], new_next]) - distance_matrix_2[new_prev, new_next]\n        imp3_insert = (distance_matrix_3[new_prev, segment[0]] + distance_matrix_3[segment[-1], new_next]) - distance_matrix_3[new_prev, new_next]\n\n        # Total improvement\n        imp1 = imp1_remove + imp1_insert\n        imp2 = imp2_remove + imp2_insert\n        imp3 = imp3_remove + imp3_insert\n\n        # Weighted improvement score\n        weighted_improvement = obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3\n\n        if weighted_improvement < 0:\n            # Perform the segment relocation\n            if seg_end > seg_start:\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    new_solution[seg_end:],\n                    segment,\n                    new_solution[seg_start:seg_end]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[seg_end:seg_start],\n                    segment,\n                    new_solution[:seg_end],\n                    new_solution[seg_start:]\n                ])\n\n    # Probabilistic segment inversion for further refinement\n    for _ in range(2):\n        seg_start = np.random.randint(n)\n        seg_length = np.random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Calculate potential improvement\n        if seg_end > seg_start:\n            segment = new_solution[seg_start:seg_end]\n            prev_node = new_solution[seg_start-1]\n            next_node = new_solution[seg_end]\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            prev_node = new_solution[seg_start-1]\n            next_node = new_solution[seg_end]\n\n        imp1 = (distance_matrix_1[prev_node, segment[-1]] + distance_matrix_1[segment[0], next_node]) - \\\n               (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node])\n        imp2 = (distance_matrix_2[prev_node, segment[-1]] + distance_matrix_2[segment[0], next_node]) - \\\n               (distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n        imp3 = (distance_matrix_3[prev_node, segment[-1]] + distance_matrix_3[segment[0], next_node]) - \\\n               (distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node])\n\n        if imp1 < 0 or imp2 < 0 or imp3 < 0:\n            # Perform the segment inversion\n            if seg_end > seg_start:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                inverted = new_solution[seg_start:][::-1]\n                inverted = np.concatenate([inverted, new_solution[:seg_end][::-1]])\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    inverted,\n                    new_solution[seg_end:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.5321732387046367,
            0.7754739999771119
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective node insertion heuristic that dynamically selects nodes based on their potential to improve all three objectives simultaneously, followed by a probabilistic edge reversal step to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Multi-objective node insertion heuristic\n    for _ in range(3):\n        # Select a node to remove and a position to insert\n        node_idx = np.random.randint(n)\n        insert_pos = np.random.randint(n)\n\n        # Calculate potential improvement for each objective\n        node = new_solution[node_idx]\n        prev_node = new_solution[node_idx-1]\n        next_node = new_solution[(node_idx+1)%n]\n\n        # Remove node from current position\n        imp1_remove = distance_matrix_1[prev_node, next_node] - (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node])\n        imp2_remove = distance_matrix_2[prev_node, next_node] - (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n        imp3_remove = distance_matrix_3[prev_node, next_node] - (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n        # Insert node at new position\n        new_prev = new_solution[insert_pos-1]\n        new_next = new_solution[insert_pos]\n        imp1_insert = (distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]) - distance_matrix_1[new_prev, new_next]\n        imp2_insert = (distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]) - distance_matrix_2[new_prev, new_next]\n        imp3_insert = (distance_matrix_3[new_prev, node] + distance_matrix_3[node, new_next]) - distance_matrix_3[new_prev, new_next]\n\n        # Total improvement\n        imp1 = imp1_remove + imp1_insert\n        imp2 = imp2_remove + imp2_insert\n        imp3 = imp3_remove + imp3_insert\n\n        # Weighted improvement score\n        weighted_improvement = obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3\n\n        if weighted_improvement < 0:\n            # Perform the node insertion\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:],\n                [new_solution[node_idx]]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [node],\n                new_solution[insert_pos:]\n            ])\n\n    # Probabilistic edge reversal for further refinement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and j != (i+1)%n:\n            # Calculate potential improvement\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                # Perform the edge reversal\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7299375511166266,
            0.8020505785942078
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective segment relocation heuristic that dynamically selects and relocates segments of the tour based on their potential to improve all three objectives simultaneously, followed by a probabilistic segment inversion step to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Multi-objective segment relocation heuristic\n    for _ in range(3):\n        # Select a segment to relocate\n        seg_start = np.random.randint(n)\n        seg_length = np.random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Select a new position to insert the segment\n        insert_pos = np.random.randint(n)\n\n        # Calculate potential improvement for each objective\n        if seg_end > seg_start:\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            remaining = new_solution[seg_end:seg_start]\n\n        # Calculate improvement from removing the segment\n        prev_node = remaining[-1] if len(remaining) > 0 else remaining[0]\n        next_node = remaining[0] if len(remaining) > 0 else remaining[-1]\n\n        imp1_remove = distance_matrix_1[prev_node, next_node] - (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node])\n        imp2_remove = distance_matrix_2[prev_node, next_node] - (distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n        imp3_remove = distance_matrix_3[prev_node, next_node] - (distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node])\n\n        # Calculate improvement from inserting the segment\n        new_prev = new_solution[insert_pos-1]\n        new_next = new_solution[insert_pos]\n\n        imp1_insert = (distance_matrix_1[new_prev, segment[0]] + distance_matrix_1[segment[-1], new_next]) - distance_matrix_1[new_prev, new_next]\n        imp2_insert = (distance_matrix_2[new_prev, segment[0]] + distance_matrix_2[segment[-1], new_next]) - distance_matrix_2[new_prev, new_next]\n        imp3_insert = (distance_matrix_3[new_prev, segment[0]] + distance_matrix_3[segment[-1], new_next]) - distance_matrix_3[new_prev, new_next]\n\n        # Total improvement\n        imp1 = imp1_remove + imp1_insert\n        imp2 = imp2_remove + imp2_insert\n        imp3 = imp3_remove + imp3_insert\n\n        # Weighted improvement score\n        weighted_improvement = obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3\n\n        if weighted_improvement < 0:\n            # Perform the segment relocation\n            if seg_end > seg_start:\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    new_solution[seg_end:],\n                    segment,\n                    new_solution[seg_start:seg_end]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[seg_end:seg_start],\n                    segment,\n                    new_solution[:seg_end],\n                    new_solution[seg_start:]\n                ])\n\n    # Probabilistic segment inversion for further refinement\n    for _ in range(2):\n        seg_start = np.random.randint(n)\n        seg_length = np.random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Calculate potential improvement\n        if seg_end > seg_start:\n            segment = new_solution[seg_start:seg_end]\n            prev_node = new_solution[seg_start-1]\n            next_node = new_solution[seg_end]\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n            prev_node = new_solution[seg_start-1]\n            next_node = new_solution[seg_end]\n\n        imp1 = (distance_matrix_1[prev_node, segment[-1]] + distance_matrix_1[segment[0], next_node]) - \\\n               (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node])\n        imp2 = (distance_matrix_2[prev_node, segment[-1]] + distance_matrix_2[segment[0], next_node]) - \\\n               (distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n        imp3 = (distance_matrix_3[prev_node, segment[-1]] + distance_matrix_3[segment[0], next_node]) - \\\n               (distance_matrix_3[prev_node, segment[0]] + distance_matrix_3[segment[-1], next_node])\n\n        if imp1 < 0 or imp2 < 0 or imp3 < 0:\n            # Perform the segment inversion\n            if seg_end > seg_start:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                inverted = new_solution[seg_start:][::-1]\n                inverted = np.concatenate([inverted, new_solution[:seg_end][::-1]])\n                new_solution = np.concatenate([\n                    new_solution[:seg_start],\n                    inverted,\n                    new_solution[seg_end:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.5321732387046367,
            0.7754739999771119
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective node insertion heuristic that dynamically selects nodes based on their potential to improve all three objectives simultaneously, followed by a probabilistic edge reversal step to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Multi-objective node insertion heuristic\n    for _ in range(3):\n        # Select a node to remove and a position to insert\n        node_idx = np.random.randint(n)\n        insert_pos = np.random.randint(n)\n\n        # Calculate potential improvement for each objective\n        node = new_solution[node_idx]\n        prev_node = new_solution[node_idx-1]\n        next_node = new_solution[(node_idx+1)%n]\n\n        # Remove node from current position\n        imp1_remove = distance_matrix_1[prev_node, next_node] - (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node])\n        imp2_remove = distance_matrix_2[prev_node, next_node] - (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n        imp3_remove = distance_matrix_3[prev_node, next_node] - (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n\n        # Insert node at new position\n        new_prev = new_solution[insert_pos-1]\n        new_next = new_solution[insert_pos]\n        imp1_insert = (distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]) - distance_matrix_1[new_prev, new_next]\n        imp2_insert = (distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]) - distance_matrix_2[new_prev, new_next]\n        imp3_insert = (distance_matrix_3[new_prev, node] + distance_matrix_3[node, new_next]) - distance_matrix_3[new_prev, new_next]\n\n        # Total improvement\n        imp1 = imp1_remove + imp1_insert\n        imp2 = imp2_remove + imp2_insert\n        imp3 = imp3_remove + imp3_insert\n\n        # Weighted improvement score\n        weighted_improvement = obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3\n\n        if weighted_improvement < 0:\n            # Perform the node insertion\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:],\n                [new_solution[node_idx]]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [node],\n                new_solution[insert_pos:]\n            ])\n\n    # Probabilistic edge reversal for further refinement\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and j != (i+1)%n:\n            # Calculate potential improvement\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                # Perform the edge reversal\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7299375511166266,
            0.8020505785942078
        ]
    },
    {
        "algorithm": "{This new algorithm employs a Pareto-optimality-aware segment reversal operator that dynamically balances objective improvements by prioritizing segments with the highest combined improvement potential across all three objectives, followed by a multi-segment reversal to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Perform multi-segment reversal\n    for _ in range(3):  # Number of segments to reverse\n        # Randomly select a segment\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n))\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate potential improvement for each objective\n        improvements = [\n            sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(start, end)) -\n            sum(distance_matrix_1[segment[(i-1)%length], segment[i]] for i in range(length)),\n            sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(start, end)) -\n            sum(distance_matrix_2[segment[(i-1)%length], segment[i]] for i in range(length)),\n            sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(start, end)) -\n            sum(distance_matrix_3[segment[(i-1)%length], segment[i]] for i in range(length))\n        ]\n\n        # Weighted improvement score\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:  # Only accept if at least one objective improves\n            # Perform the segment reversal\n            if start < end:\n                new_solution[start:end] = segment[::-1]\n            else:\n                reversed_segment = segment[::-1]\n                new_solution[start:] = reversed_segment[:n-start]\n                new_solution[:end] = reversed_segment[n-start:]\n\n    return new_solution\n\n",
        "score": [
            -0.7539085179287297,
            1.5529474377632142
        ]
    },
    {
        "algorithm": "{This algorithm combines a multi-objective path reversal operator with dynamic objective prioritization, where it selectively reverses segments of the tour based on their potential to improve the least improved objective, while maintaining feasibility through careful segment selection and boundary checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Identify the least improved objective\n    least_improved = np.argmin(obj_weights)\n\n    # Perform path reversal based on the least improved objective\n    for _ in range(2):  # Number of reversals to perform\n        # Select a random segment to reverse\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(6, n))\n        end = (start + length) % n\n\n        if start < end:\n            # Reverse the segment\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Handle circular reversal\n            segment = np.concatenate((new_solution[start:], new_solution[:end]))\n            reversed_segment = segment[::-1]\n            new_solution[start:] = reversed_segment[:n-start]\n            new_solution[:end] = reversed_segment[n-start:]\n\n    return new_solution\n\n",
        "score": [
            -0.7553432920031857,
            1.6500617504119872
        ]
    }
]