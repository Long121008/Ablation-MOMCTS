[
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dynamic multi-objective route inversion strategy that selectively inverts segments of the tour based on their objective contributions, using weighted probability to prioritize segments that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.712972644146611,
            0.17441778182983397
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective segment relocation operator that adaptively selects and moves segments of the tour between randomly chosen positions, followed by a probabilistic 2-opt step to refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[k]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[k]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[k]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution = np.concatenate((new_solution[:i], new_solution[k:], segment, new_solution[i:k]))\n\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n               (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n               (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n               (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if imp1 < 0 or imp2 < 0 or imp3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7813655665191035,
            1.2976598620414734
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dynamic multi-objective route inversion strategy that selectively inverts segments of the tour based on their objective contributions, using weighted probability to prioritize segments that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.712972644146611,
            0.17441778182983397
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment exchange strategy that dynamically selects and exchanges segments of the tour based on their normalized objective contributions, using a weighted probability mechanism to prioritize segments with high potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(3, n // 3)\n    start1 = np.random.randint(0, n - segment_length + 1)\n    end1 = start1 + segment_length\n    start2 = np.random.randint(0, n - segment_length + 1)\n    end2 = start2 + segment_length\n\n    if np.random.rand() < 0.8:\n        temp = new_solution[start1:end1].copy()\n        new_solution[start1:end1] = new_solution[start2:end2]\n        new_solution[start2:end2] = temp\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7298527006052995,
            0.18848638534545897
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and dynamic reassembly strategy that intelligently partitions the tour into contiguous segments based on their contribution to each objective, then performs a weighted segment exchange operation to create diverse high-quality solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segments = []\n    segment_length = max(2, n // 5)\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for _ in range(2):\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if len(segments[i]) > 1 and len(segments[j]) > 1:\n            segments[i], segments[j] = segments[j], segments[i]\n\n    new_solution = np.concatenate(segments)\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7532864062493709,
            0.2872426867485046
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dynamic multi-objective route inversion strategy that selectively inverts segments of the tour based on their objective contributions, using weighted probability to prioritize segments that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.712972644146611,
            0.17441778182983397
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour inversion and weighted segment reassembly strategy that intelligently inverts segments of the tour based on their contribution to each objective, then performs a weighted segment reassembly to create diverse high-quality solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segments = []\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for seg in segments:\n        if len(seg) > 1 and np.random.rand() < 0.3:\n            seg = seg[::-1]\n\n    new_solution = np.concatenate(segments)\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7263224653235864,
            0.18634120225906373
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This algorithm employs an adaptive path inversion and reordering strategy that selectively inverts segments of the tour based on their potential to improve all three objectives, then reorders the segments using a multi-objective insertion heuristic to create diverse high-quality solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        if np.random.rand() < 0.4:\n            if np.random.rand() < 0.5:\n                segments.append(current_segment[::-1])\n            else:\n                segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        if np.random.rand() < 0.5:\n            segments.append(current_segment[::-1])\n        else:\n            segments.append(current_segment)\n\n    new_solution = []\n    while segments:\n        best_seg_idx = 0\n        best_improvement = -float('inf')\n\n        for i in range(len(segments)):\n            seg = segments[i]\n            if not new_solution:\n                prev_node = seg[-1]\n                next_node = seg[0]\n                imp1 = -distance_matrix_1[prev_node, next_node]\n                imp2 = -distance_matrix_2[prev_node, next_node]\n                imp3 = -distance_matrix_3[prev_node, next_node]\n            else:\n                prev_node = new_solution[-1]\n                next_node = seg[0]\n                imp1 = distance_matrix_1[prev_node, next_node] - distance_matrix_1[prev_node, new_solution[0]]\n                imp2 = distance_matrix_2[prev_node, next_node] - distance_matrix_2[prev_node, new_solution[0]]\n                imp3 = distance_matrix_3[prev_node, next_node] - distance_matrix_3[prev_node, new_solution[0]]\n\n            weighted_imp = obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3\n            if weighted_imp > best_improvement:\n                best_improvement = weighted_imp\n                best_seg_idx = i\n\n        new_solution.extend(segments.pop(best_seg_idx))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.7661866453888204,
            0.48955702781677246
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective tour segmentation and dynamic reassembly strategy that intelligently partitions the tour into contiguous segments based on their contribution to each objective, then performs a weighted segment exchange operation to create diverse high-quality solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segments = []\n    segment_length = max(2, n // 5)\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for _ in range(2):\n        i, j = np.random.choice(len(segments), 2, replace=False)\n        if len(segments[i]) > 1 and len(segments[j]) > 1:\n            segments[i], segments[j] = segments[j], segments[i]\n\n    new_solution = np.concatenate(segments)\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7532864062493709,
            0.2872426867485046
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective tour fragmentation and reassembly heuristic that dynamically partitions the tour into segments based on their contribution to each objective, then probabilistically reassembles them in a way that balances objective improvements while maintaining tour feasibility through a novel segment merging strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Dynamic tour fragmentation\n    fragments = []\n    current_fragment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate potential improvement if we split here\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        imp1 = distance_matrix_1[prev_node, next_node]\n        imp2 = distance_matrix_2[prev_node, next_node]\n        imp3 = distance_matrix_3[prev_node, next_node]\n\n        # Split probability based on weighted improvement\n        split_prob = 0.1 + 0.8 * (1 - (obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3) / (max(imp1, imp2, imp3) * sum(obj_weights)))\n        if np.random.random() < split_prob:\n            fragments.append(current_fragment)\n            current_fragment = [next_node]\n        else:\n            current_fragment.append(next_node)\n    fragments.append(current_fragment)\n\n    # Probabilistic reassembly with segment merging\n    np.random.shuffle(fragments)\n    reassembled = []\n    while fragments:\n        if len(fragments) == 1:\n            reassembled.extend(fragments.pop())\n        else:\n            # Select two fragments to merge\n            i, j = np.random.choice(len(fragments), 2, replace=False)\n            frag1, frag2 = fragments[i], fragments[j]\n\n            # Calculate merge potential\n            imp1 = distance_matrix_1[frag1[-1], frag2[0]]\n            imp2 = distance_matrix_2[frag1[-1], frag2[0]]\n            imp3 = distance_matrix_3[frag1[-1], frag2[0]]\n\n            merge_prob = 0.5 + 0.5 * (obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3) / (max(imp1, imp2, imp3) * sum(obj_weights))\n\n            if np.random.random() < merge_prob:\n                # Merge the fragments\n                merged = frag1 + frag2\n                reassembled.extend(merged)\n                fragments.pop(max(i, j))\n                fragments.pop(min(i, j))\n            else:\n                # Add the first fragment and keep the second\n                reassembled.extend(frag1)\n                fragments.pop(i)\n\n    new_solution = np.array(reassembled)\n\n    # Verify the solution is valid\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8477932329426,
            1.3783046007156372
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective segment relocation operator that adaptively selects and relocates segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic 2-opt step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[k-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(k+1)%n]]) -\n            (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[k-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(k+1)%n]]) -\n            (distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[k-1], segment[0]] + distance_matrix_3[segment[-1], new_solution[(k+1)%n]]) -\n            (distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution = np.concatenate((new_solution[:k], segment, new_solution[k:j], new_solution[j+1:]))\n\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7744680225294603,
            1.1764363884925841
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    }
]