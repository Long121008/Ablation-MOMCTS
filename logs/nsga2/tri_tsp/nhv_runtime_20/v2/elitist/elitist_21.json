[
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dynamic objective-aware segment inversion strategy that adaptively selects and inverts segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6848626635898445,
            0.12366429567337037
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective adaptive node swap and insertion strategy that dynamically selects nodes based on their contribution to the three objectives, using a hybrid of dominance-based selection and weighted probability to prioritize nodes that show potential for improvement while maintaining feasibility through a constrained insertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7806327896149363,
            0.23952900171279906
        ]
    },
    {
        "algorithm": "{This new algorithm employs a multi-objective edge-swapping mechanism that selectively swaps edges in the tour based on their combined improvement potential across all three objectives, using a dominance-based selection criterion to prioritize swaps that enhance Pareto efficiency while ensuring feasibility through careful edge validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n\n    if np.random.rand() < 0.7:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7602687437173111,
            0.18041802644729615
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dominance-aware segment inversion strategy that dynamically selects and inverts segments of the tour based on their objective contributions, using a hybrid of crowding distance and objective dominance to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6911468088182258,
            0.16942719221115113
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective tour splitting and merging operator that adaptively partitions the tour into segments, reorders them based on Pareto dominance among objectives, and probabilistically merges segments to create a new solution while maintaining feasibility through a novel segment alignment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        if np.random.rand() < 0.3:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    segments.append(current_segment)\n\n    np.random.shuffle(segments)\n\n    new_solution = []\n    for seg in segments:\n        if np.random.rand() < 0.5:\n            seg = seg[::-1]\n        new_solution.extend(seg)\n\n    new_solution = np.array(new_solution)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8538464254384908,
            1.5939858436584473
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dynamic multi-objective route inversion strategy that selectively inverts segments of the tour based on their objective contributions, using weighted probability to prioritize segments that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.712972644146611,
            0.17441778182983397
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective segment relocation operator that adaptively selects and moves segments of the tour between randomly chosen positions, followed by a probabilistic 2-opt step to refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[k]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[k]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[k]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution = np.concatenate((new_solution[:i], new_solution[k:], segment, new_solution[i:k]))\n\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n               (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n               (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n               (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if imp1 < 0 or imp2 < 0 or imp3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7813655665191035,
            1.2976598620414734
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective segment relocation strategy that dynamically selects and relocates segments of the tour based on their objective contributions, using a hybrid of weighted probability and dominance-based selection to prioritize segments that show potential for improvement across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 3)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.8:\n        segment = new_solution[start:end]\n        new_solution = np.concatenate((new_solution[:start], new_solution[end:], segment))\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.6721210284581501,
            0.09819411039352417
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dynamic multi-objective route inversion strategy that selectively inverts segments of the tour based on their objective contributions, using weighted probability to prioritize segments that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.712972644146611,
            0.17441778182983397
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs a dynamic multi-objective route inversion strategy that selectively inverts segments of the tour based on their objective contributions, using weighted probability to prioritize segments that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if new_solution[-1] != new_solution[0]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.712972644146611,
            0.17441778182983397
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{This new algorithm employs an adaptive multi-objective tour fragmentation and reassembly heuristic that dynamically partitions the tour into segments based on their contribution to each objective, then probabilistically reassembles them in a way that balances objective improvements while maintaining tour feasibility through a novel segment merging strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    # Dynamic tour fragmentation\n    fragments = []\n    current_fragment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate potential improvement if we split here\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        imp1 = distance_matrix_1[prev_node, next_node]\n        imp2 = distance_matrix_2[prev_node, next_node]\n        imp3 = distance_matrix_3[prev_node, next_node]\n\n        # Split probability based on weighted improvement\n        split_prob = 0.1 + 0.8 * (1 - (obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3) / (max(imp1, imp2, imp3) * sum(obj_weights)))\n        if np.random.random() < split_prob:\n            fragments.append(current_fragment)\n            current_fragment = [next_node]\n        else:\n            current_fragment.append(next_node)\n    fragments.append(current_fragment)\n\n    # Probabilistic reassembly with segment merging\n    np.random.shuffle(fragments)\n    reassembled = []\n    while fragments:\n        if len(fragments) == 1:\n            reassembled.extend(fragments.pop())\n        else:\n            # Select two fragments to merge\n            i, j = np.random.choice(len(fragments), 2, replace=False)\n            frag1, frag2 = fragments[i], fragments[j]\n\n            # Calculate merge potential\n            imp1 = distance_matrix_1[frag1[-1], frag2[0]]\n            imp2 = distance_matrix_2[frag1[-1], frag2[0]]\n            imp3 = distance_matrix_3[frag1[-1], frag2[0]]\n\n            merge_prob = 0.5 + 0.5 * (obj_weights[0]*imp1 + obj_weights[1]*imp2 + obj_weights[2]*imp3) / (max(imp1, imp2, imp3) * sum(obj_weights))\n\n            if np.random.random() < merge_prob:\n                # Merge the fragments\n                merged = frag1 + frag2\n                reassembled.extend(merged)\n                fragments.pop(max(i, j))\n                fragments.pop(min(i, j))\n            else:\n                # Add the first fragment and keep the second\n                reassembled.extend(frag1)\n                fragments.pop(i)\n\n    new_solution = np.array(reassembled)\n\n    # Verify the solution is valid\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8477932329426,
            1.3783046007156372
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    },
    {
        "algorithm": "{The new algorithm employs a multi-objective path inversion operator that adaptively selects and inverts segments of the tour based on their potential to improve multiple objectives, followed by a probabilistic node swap step to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    obj_weights = (obj1/total_obj, obj2/total_obj, obj3/total_obj)\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_3[new_solution[i-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(j+1)%n]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        weighted_improvement = sum(w * imp for w, imp in zip(obj_weights, improvements))\n\n        if weighted_improvement < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            imp1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            imp2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            imp3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                   (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if imp1 < 0 or imp2 < 0 or imp3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721053940850467,
            1.7717661261558533
        ]
    }
]