[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the lowest normalized objective value (weighted sum with random weights) and applies a hybrid local search operator that combines 2-opt with a novel multi-objective edge insertion strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.rand(3)\n    normalized_objectives = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmin(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.rand() > 0.5:\n        c, d = np.random.choice(n, size=2, replace=False)\n        c, d = sorted([c, d])\n        new_solution = np.concatenate([\n            new_solution[:c],\n            [new_solution[d]],\n            new_solution[c:d],\n            [new_solution[c]],\n            new_solution[d:]\n        ])\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8074416467613336,
            1.8331016182899476
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the lowest combined objective value (sum of objectives) and applies a novel \"multi-objective 3-opt\" operator that performs three simultaneous edge swaps while considering the trade-off between objectives to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        new_solution[c:],\n        [new_solution[a]]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6616624094204342,
            0.33536109924316404
        ]
    }
]