[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the lowest normalized objective value (weighted sum with random weights) and applies a novel multi-objective segment rotation operator that combines random segment reversal with adaptive edge swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.rand(3)\n    normalized_objectives = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmin(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    if np.random.rand() > 0.3:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        segment = new_solution[a:b]\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.rand() > 0.7:\n        c, d = np.random.choice(n, size=2, replace=False)\n        c, d = sorted([c, d])\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8159470126228555,
            2.9315423727035523
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the lowest combined objective value (sum of objectives) and applies a novel \"multi-objective 3-opt\" operator that performs three simultaneous edge swaps while considering the trade-off between objectives to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        new_solution[c:],\n        [new_solution[a]]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6616624094204342,
            0.33536109924316404
        ]
    }
]