[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the lowest combined objective value (sum of objectives) and applies a novel \"multi-objective 3-opt\" operator that performs three simultaneous edge swaps while considering the trade-off between objectives to generate an improved neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        new_solution[c:],\n        [new_solution[a]]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest diversity score (measured by the spread of objectives) and applies a hybrid \"multi-objective 4-opt\" operator that performs four simultaneous edge swaps while considering the trade-off between objectives to generate an improved neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (spread of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 4-opt move\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Four possible segments to reverse\n    segments = [\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:], [new_solution[a]]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:d], new_solution[d:], [new_solution[a]]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:], [new_solution[a]]]),\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:d], new_solution[d:], [new_solution[a]]])\n    ]\n\n    # Select the best segment based on multi-objective improvement\n    best_segment = segments[0]\n    best_improvement = 0\n\n    for segment in segments:\n        if len(np.unique(segment)) != n:\n            continue\n\n        # Calculate improvement in all three objectives\n        improvement = 0\n        for i in range(n):\n            prev_node = base_solution[i]\n            next_node = base_solution[(i+1)%n]\n\n            prev_node_new = segment[i]\n            next_node_new = segment[(i+1)%n]\n\n            improvement += (distance_matrix_1[prev_node, next_node] - distance_matrix_1[prev_node_new, next_node_new]) + \\\n                          (distance_matrix_2[prev_node, next_node] - distance_matrix_2[prev_node_new, next_node_new]) + \\\n                          (distance_matrix_3[prev_node, next_node] - distance_matrix_3[prev_node_new, next_node_new])\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_segment = segment\n\n    return best_segment if best_improvement > 0 else base_solution\n\n",
        "score": [
            -0.7153256119842155,
            2.6281623959541323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (spread of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 4-opt move\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Four possible segments to reverse\n    segments = [\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:], [new_solution[a]]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c][::-1], new_solution[c:d], new_solution[d:], [new_solution[a]]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:], [new_solution[a]]]),\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c][::-1], new_solution[c:d], new_solution[d:], [new_solution[a]]])\n    ]\n\n    # Select the best segment based on multi-objective improvement\n    best_segment = segments[0]\n    best_improvement = 0\n\n    for segment in segments:\n        if len(np.unique(segment)) != n:\n            continue\n\n        # Calculate improvement in all three objectives\n        improvement = 0\n        for i in range(n):\n            prev_node = base_solution[i]\n            next_node = base_solution[(i+1)%n]\n\n            prev_node_new = segment[i]\n            next_node_new = segment[(i+1)%n]\n\n            improvement += (distance_matrix_1[prev_node, next_node] - distance_matrix_1[prev_node_new, next_node_new]) + \\\n                          (distance_matrix_2[prev_node, next_node] - distance_matrix_2[prev_node_new, next_node_new]) + \\\n                          (distance_matrix_3[prev_node, next_node] - distance_matrix_3[prev_node_new, next_node_new])\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_segment = segment\n\n    return best_segment if best_improvement > 0 else base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the lowest combined objective value (sum of objectives) and applies a novel \"multi-objective 3-opt\" operator that performs three simultaneous edge swaps while considering the trade-off between objectives to generate an improved neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        new_solution[c:],\n        [new_solution[a]]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the lowest normalized objective value (weighted sum with random weights) and applies a novel multi-objective segment rotation operator that combines random segment reversal with adaptive edge swaps to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.rand(3)\n    normalized_objectives = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmin(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    if np.random.rand() > 0.3:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        segment = new_solution[a:b]\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.rand() > 0.7:\n        c, d = np.random.choice(n, size=2, replace=False)\n        c, d = sorted([c, d])\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest crowding distance in objective space (indicating under-explored regions) and applies a novel \"multi-objective segment insertion\" operator that intelligently reinserts a random segment of nodes at a new position while considering the trade-off between objectives to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    segment = new_solution[a:b]\n    remaining = np.delete(new_solution, np.arange(a, b))\n\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6213420198913022,
            2.225866234302521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    segment = new_solution[a:b]\n    remaining = np.delete(new_solution, np.arange(a, b))\n\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the lowest normalized objective value (weighted sum with random weights) and applies a novel multi-objective segment rotation operator that combines random segment reversal with adaptive edge swaps to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.rand(3)\n    normalized_objectives = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmin(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    if np.random.rand() > 0.3:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        segment = new_solution[a:b]\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.rand() > 0.7:\n        c, d = np.random.choice(n, size=2, replace=False)\n        c, d = sorted([c, d])\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the lowest combined objective value (sum of objectives) and applies a novel \"multi-objective 3-opt\" operator that performs three simultaneous edge swaps while considering the trade-off between objectives to generate an improved neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        new_solution[c:],\n        [new_solution[a]]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced objective values (minimizing the variance of objectives) and applies a novel \"multi-objective crossover\" operator that combines segments from two diverse solutions to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmin(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n\n        new_solution[a:b] = other_solution[a:b]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.concatenate([new_solution, [new_solution[0]]])\n\n    return new_solution\n\n",
        "score": [
            -0.6450836484008562,
            1.2856156945228576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmin(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n\n        new_solution[a:b] = other_solution[a:b]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.concatenate([new_solution, [new_solution[0]]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the lowest normalized objective value (weighted sum with random weights) and applies a novel multi-objective segment rotation operator that combines random segment reversal with adaptive edge swaps to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.random.rand(3)\n    normalized_objectives = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmin(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    if np.random.rand() > 0.3:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        segment = new_solution[a:b]\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.rand() > 0.7:\n        c, d = np.random.choice(n, size=2, replace=False)\n        c, d = sorted([c, d])\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the lowest combined objective value (sum of objectives) and applies a novel \"multi-objective 3-opt\" operator that performs three simultaneous edge swaps while considering the trade-off between objectives to generate an improved neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        new_solution[c:],\n        [new_solution[a]]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of Pareto dominance and diversity metrics, then applies a novel \"multi-objective segment inversion with adaptive crossover\" operator that combines segment inversion with crossover from a high-quality reference solution to generate a neighbor solution that balances exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    scores = crowding_distances / (np.sum(objectives, axis=1) + 1e-10)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    reference_solution = archive[np.argmin(np.sum(objectives, axis=1))][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    if np.random.rand() > 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        new_solution[a:b] = reference_solution[a:b]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.rand() > 0.8:\n        c, d = np.random.choice(n, size=2, replace=False)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5983942089040056,
            3.650248384475708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    scores = crowding_distances / (np.sum(objectives, axis=1) + 1e-10)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    reference_solution = archive[np.argmin(np.sum(objectives, axis=1))][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    if np.random.rand() > 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        new_solution[a:b] = reference_solution[a:b]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.rand() > 0.8:\n        c, d = np.random.choice(n, size=2, replace=False)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    }
]