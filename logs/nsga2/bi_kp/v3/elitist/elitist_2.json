[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines adaptive item selection based on objective-specific marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest average objective value\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]) / 2)\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate objective-specific marginal gains\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on objective-specific gains\n    for _ in range(5):\n        # Select objective to focus on (alternate between objectives)\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                # Select items with highest marginal gain for objective 1\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                # Select items with highest marginal gain for objective 2\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.702997689876057,
            -18.622779560065165
        ]
    },
    {
        "algorithm": "{The algorithm selects a diverse solution from the archive and applies a hybrid local search combining probabilistic item flips, guided swaps based on marginal utility, and capacity-aware item additions to explore high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a diverse solution based on objective space coverage\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Probabilistic flips based on marginal utility\n    for idx in range(n_items):\n        if np.random.rand() < 0.2:  # Probability to consider flip\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    marginal_utility1 = value1_lst[idx] / weight_lst[idx]\n                    marginal_utility2 = value2_lst[idx] / weight_lst[idx]\n                    if marginal_utility1 + marginal_utility2 > 0.5 * (np.mean(value1_lst) + np.mean(value2_lst)) / np.mean(weight_lst):\n                        new_solution[idx] = 1\n                        total_weight += weight_lst[idx]\n\n    # Step 2: Guided swap based on multi-objective improvement\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate potential improvement for each possible swap\n        improvements = []\n        for i in in_items:\n            for j in out_items:\n                if (total_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    delta1 = value1_lst[j] - value1_lst[i]\n                    delta2 = value2_lst[j] - value2_lst[i]\n                    improvements.append((delta1 + delta2, i, j))\n\n        if improvements:\n            _, best_i, best_j = max(improvements)\n            new_solution[best_i] = 0\n            new_solution[best_j] = 1\n\n    # Step 3: Add items with high marginal utility if capacity allows\n    if total_weight < capacity * 0.9:  # Only add if not too close to capacity\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Sort by combined marginal utility\n            marginal_utility = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n            sorted_candidates = candidate_items[np.argsort(marginal_utility)[::-1]]\n\n            for item in sorted_candidates:\n                if total_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -19.012667550383224,
            -18.42529038064601
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines adaptive item selection based on objective-specific marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest average objective value\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]) / 2)\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate objective-specific marginal gains\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on objective-specific gains\n    for _ in range(5):\n        # Select objective to focus on (alternate between objectives)\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                # Select items with highest marginal gain for objective 1\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                # Select items with highest marginal gain for objective 2\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.702997689876057,
            -18.622779560065165
        ]
    },
    {
        "algorithm": "{The algorithm selects a diverse solution from the archive and applies a hybrid local search combining probabilistic item flips, guided swaps based on marginal utility, and capacity-aware item additions to explore high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a diverse solution based on objective space coverage\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Probabilistic flips based on marginal utility\n    for idx in range(n_items):\n        if np.random.rand() < 0.2:  # Probability to consider flip\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    marginal_utility1 = value1_lst[idx] / weight_lst[idx]\n                    marginal_utility2 = value2_lst[idx] / weight_lst[idx]\n                    if marginal_utility1 + marginal_utility2 > 0.5 * (np.mean(value1_lst) + np.mean(value2_lst)) / np.mean(weight_lst):\n                        new_solution[idx] = 1\n                        total_weight += weight_lst[idx]\n\n    # Step 2: Guided swap based on multi-objective improvement\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate potential improvement for each possible swap\n        improvements = []\n        for i in in_items:\n            for j in out_items:\n                if (total_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    delta1 = value1_lst[j] - value1_lst[i]\n                    delta2 = value2_lst[j] - value2_lst[i]\n                    improvements.append((delta1 + delta2, i, j))\n\n        if improvements:\n            _, best_i, best_j = max(improvements)\n            new_solution[best_i] = 0\n            new_solution[best_j] = 1\n\n    # Step 3: Add items with high marginal utility if capacity allows\n    if total_weight < capacity * 0.9:  # Only add if not too close to capacity\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Sort by combined marginal utility\n            marginal_utility = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n            sorted_candidates = candidate_items[np.argsort(marginal_utility)[::-1]]\n\n            for item in sorted_candidates:\n                if total_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    total_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -19.012667550383224,
            -18.42529038064601
        ]
    }
]