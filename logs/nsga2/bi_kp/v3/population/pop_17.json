[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a balanced objective score (weighting objective 1 0.6 and objective 2 0.4) and applies a hybrid local search that first focuses on improving objective 1 by adding items with highest marginal gains, then improves objective 2 by swapping items with high value-to-weight ratios, followed by a diversification step that randomly flips items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with balanced objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.718783063027903,
            -19.77003626633874
        ]
    }
]