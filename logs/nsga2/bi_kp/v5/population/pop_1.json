[
    {
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining random item swaps and value-based perturbations to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based perturbations\n    n_items = len(weight_lst)\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Random item swap\n        if random.random() < 0.7:  # 70% chance for swap\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Value-based perturbation\n            # Find items to flip based on highest marginal value\n            current_weight = np.sum(new_solution * weight_lst)\n            for i in range(n_items):\n                if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to remove high-value item\n                        new_solution[i] = 0\n                elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to add high-value item\n                        new_solution[i] = 1\n\n        # Check feasibility\n        if np.sum(new_solution * weight_lst) <= capacity:\n            return new_solution\n\n        new_solution = base_solution.copy()  # Reset if infeasible\n        attempts += 1\n\n    return base_solution  # Fallback to base solution if no valid neighbor found\n\n",
        "score": [
            -18.491002254898,
            -18.26436528182859
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Flip a subset of items based on trade-off between value1 and value2\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Probabilistically remove items with low marginal trade-off\n            if np.random.rand() < 0.3 and (value1_lst[i] / weight_lst[i]) < np.median(value1_lst / weight_lst):\n                new_solution[i] = 0\n        else:\n            # Probabilistically add items with high marginal trade-off\n            if np.random.rand() < 0.5 and (value1_lst[i] / weight_lst[i]) > np.median(value1_lst / weight_lst):\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing the heaviest item if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) > 0:\n            heaviest_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -18.55163409321681,
            -15.932380667449568
        ]
    }
]