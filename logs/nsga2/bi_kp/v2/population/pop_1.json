[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(archive[i][1][0] + archive[i][1][1]) / np.sum(weight_lst[archive[i][0] == 1]) for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a subset of items based on their marginal contribution to both objectives\n    marginal_value1 = value1_lst - np.sum(value1_lst[base_solution == 1]) / np.sum(weight_lst[base_solution == 1]) * weight_lst\n    marginal_value2 = value2_lst - np.sum(value2_lst[base_solution == 1]) / np.sum(weight_lst[base_solution == 1]) * weight_lst\n\n    # Combine marginal contributions and select top candidates\n    combined_marginal = marginal_value1 + marginal_value2\n    candidate_indices = np.argsort(combined_marginal)[-10:]  # Consider top 10 items\n\n    # Randomly flip a subset of candidate items to explore the neighborhood\n    flip_indices = np.random.choice(candidate_indices, size=min(3, len(candidate_indices)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing excess weight if necessary\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_indices = np.where(new_solution == 1)[0]\n        remove_idx = np.random.choice(excess_indices)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -15.718602937065686,
            -15.16051158578668
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on a hybrid of diversity and objective-space coverage, then applies a novel local search operator that combines item swapping and cluster-based flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with high diversity and objective-space coverage\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    base_solution = base_solution.copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: cluster-based flipping with item swapping\n    # First, identify clusters of items that are often included together\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select a cluster of included items to flip\n        cluster_size = min(3, len(included_items))\n        flip_indices = np.random.choice(included_items, size=cluster_size, replace=False)\n\n        # Calculate the total weight of the flipped items\n        total_flipped_weight = np.sum(weight_lst[flip_indices])\n\n        # Calculate the total weight of the new solution if we flip these items\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = current_weight - total_flipped_weight\n\n        # Ensure feasibility: if flipping makes it infeasible, try swapping instead\n        if new_weight <= capacity:\n            new_solution[flip_indices] = 0\n        else:\n            # Swap items between included and excluded\n            swap_candidates = np.concatenate((included_items, excluded_items))\n            if len(swap_candidates) > 1:\n                swap_idx1, swap_idx2 = np.random.choice(swap_candidates, size=2, replace=False)\n                new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n                # Ensure feasibility after swap\n                new_weight = np.sum(weight_lst[new_solution == 1])\n                if new_weight > capacity:\n                    # If swap is infeasible, revert to original solution\n                    new_solution = base_solution.copy()\n    else:\n        # If no items are included or excluded, perform a random flip\n        if len(included_items) > 0:\n            flip_idx = np.random.choice(included_items)\n            new_solution[flip_idx] = 0\n        elif len(excluded_items) > 0:\n            add_idx = np.random.choice(excluded_items)\n            if np.sum(weight_lst[base_solution == 1]) + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -13.878486261107868,
            -13.861738832358068
        ]
    }
]