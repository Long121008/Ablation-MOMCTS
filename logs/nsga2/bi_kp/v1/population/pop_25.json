[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -16.177549555762077,
            -19.8906414813321
        ]
    },
    {
        "algorithm": "{The new algorithm combines the selection of promising solutions based on a weighted objective ratio with a novel local search strategy that probabilistically explores item combinations by considering both value improvements and weight feasibility, while also incorporating a dynamic neighborhood exploration mechanism to balance exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Probabilistic neighborhood exploration\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if random.random() < 0.7:  # Higher probability to remove if it improves both objectives\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment\n    if random.random() < 0.3:  # With 30% probability, perform a larger neighborhood move\n        num_changes = random.randint(2, min(5, n_items))\n        change_indices = random.sample(range(n_items), num_changes)\n        for i in change_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -20.214973955082854,
            -16.047877266262887
        ]
    }
]