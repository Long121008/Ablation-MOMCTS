[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -16.177549555762077,
            -19.8906414813321
        ]
    },
    {
        "algorithm": "{The new algorithm combines the selection of promising solutions based on a weighted objective ratio with a novel local search strategy that probabilistically explores item combinations by considering both value improvements and weight feasibility, while also incorporating a dynamic neighborhood exploration mechanism to balance exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Probabilistic neighborhood exploration\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if random.random() < 0.7:  # Higher probability to remove if it improves both objectives\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment\n    if random.random() < 0.3:  # With 30% probability, perform a larger neighborhood move\n        num_changes = random.randint(2, min(5, n_items))\n        change_indices = random.sample(range(n_items), num_changes)\n        for i in change_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -20.214973955082854,
            -16.047877266262887
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -16.177549555762077,
            -19.8906414813321
        ]
    },
    {
        "algorithm": "{The new algorithm combines the selection of promising solutions based on a weighted objective ratio with a novel local search strategy that probabilistically explores item combinations by considering both value improvements and weight feasibility, while also incorporating a dynamic neighborhood exploration mechanism to balance exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Probabilistic neighborhood exploration\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if random.random() < 0.7:  # Higher probability to remove if it improves both objectives\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment\n    if random.random() < 0.3:  # With 30% probability, perform a larger neighborhood move\n        num_changes = random.randint(2, min(5, n_items))\n        change_indices = random.sample(range(n_items), num_changes)\n        for i in change_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -20.214973955082854,
            -16.047877266262887
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score that prioritizes both values while considering their relative improvements, then applies a novel local search strategy that uses adaptive item swapping and probabilistic item addition to explore the solution space while maintaining feasibility, incorporating a dynamic neighborhood size adjustment that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective score (0.5*value1 + 0.5*value2)\n    combined_scores = [0.5 * v1 + 0.5 * v2 for _, (v1, v2) in archive]\n    max_score = max(combined_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.5 * v1 + 0.5 * v2 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive item swapping strategy\n    for _ in range(min(4, n_items)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight + weight_lst[i] - weight_lst[j]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Probabilistic item addition\n    for _ in range(min(3, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            if random.random() < 0.6:  # Higher probability to add promising items\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Dynamic neighborhood size adjustment\n    neighborhood_size = random.randint(1, min(5, n_items))\n    for _ in range(neighborhood_size):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 1 and random.random() < 0.4:  # Lower probability to remove\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -19.00721048113281,
            -18.704076815972382
        ]
    },
    {
        "algorithm": "{The new algorithm selects promising solutions based on a hybrid objective score combining normalized value ratios and diversity measures, then applies a probabilistic local search with adaptive neighborhood sizes and weight-sensitive item swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate hybrid objective score combining value ratios and diversity\n    total_value1 = sum(v1 for _, (v1, _) in archive)\n    total_value2 = sum(v2 for _, (_, v2) in archive)\n    value_scores = [(0.6 * (v1 / (total_value1 + 1e-10)) + 0.4 * (v2 / (total_value2 + 1e-10))) for _, (v1, v2) in archive]\n\n    # Select top 30% candidates based on hybrid score\n    sorted_indices = sorted(range(len(value_scores)), key=lambda i: -value_scores[i])\n    candidate_indices = sorted_indices[:max(1, len(sorted_indices) // 3)]\n    candidates = [archive[i][0] for i in candidate_indices]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive neighborhood search with weight-sensitive swaps\n    for _ in range(min(7, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            # Higher probability to remove if weight is significant\n            removal_prob = 0.5 if weight_lst[i] > capacity * 0.2 else 0.3\n            if random.random() < removal_prob:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment with value-aware swaps\n    if random.random() < 0.4:\n        num_changes = random.randint(3, min(7, n_items))\n        # Prioritize items with high value-to-weight ratio\n        item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-item_scores)\n        for i in sorted_items[:num_changes]:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -19.383226209854577,
            -18.19527635797244
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -16.177549555762077,
            -19.8906414813321
        ]
    },
    {
        "algorithm": "{The new algorithm combines the selection of promising solutions based on a weighted objective ratio with a novel local search strategy that probabilistically explores item combinations by considering both value improvements and weight feasibility, while also incorporating a dynamic neighborhood exploration mechanism to balance exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Probabilistic neighborhood exploration\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if random.random() < 0.7:  # Higher probability to remove if it improves both objectives\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment\n    if random.random() < 0.3:  # With 30% probability, perform a larger neighborhood move\n        num_changes = random.randint(2, min(5, n_items))\n        change_indices = random.sample(range(n_items), num_changes)\n        for i in change_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -20.214973955082854,
            -16.047877266262887
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -16.177549555762077,
            -19.8906414813321
        ]
    },
    {
        "algorithm": "{The new algorithm combines the selection of promising solutions based on a weighted objective ratio with a novel local search strategy that probabilistically explores item combinations by considering both value improvements and weight feasibility, while also incorporating a dynamic neighborhood exploration mechanism to balance exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Probabilistic neighborhood exploration\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if random.random() < 0.7:  # Higher probability to remove if it improves both objectives\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment\n    if random.random() < 0.3:  # With 30% probability, perform a larger neighborhood move\n        num_changes = random.randint(2, min(5, n_items))\n        change_indices = random.sample(range(n_items), num_changes)\n        for i in change_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -20.214973955082854,
            -16.047877266262887
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 4) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(4, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(4, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping three items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 3:\n        i, j, k = random.sample(range(n_items), 3)\n        if new_solution[i] != new_solution[j] or new_solution[j] != new_solution[k]:\n            if new_solution[i] == 0 and new_solution[j] == 1 and new_solution[k] == 0:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -20.111865292400655,
            -16.420095281339098
        ]
    },
    {
        "algorithm": "{The new algorithm combines the selection of promising solutions based on a weighted objective ratio with a novel local search strategy that probabilistically explores item combinations by considering both value improvements and weight feasibility, while also incorporating a dynamic neighborhood exploration mechanism to balance exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Probabilistic neighborhood exploration\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if random.random() < 0.7:  # Higher probability to remove if it improves both objectives\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment\n    if random.random() < 0.3:  # With 30% probability, perform a larger neighborhood move\n        num_changes = random.randint(2, min(5, n_items))\n        change_indices = random.sample(range(n_items), num_changes)\n        for i in change_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -20.214973955082854,
            -16.047877266262887
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -16.177549555762077,
            -19.8906414813321
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that selects solutions based on a weighted combination of value1 and value2 (with 0.7*value1 and 0.3*value2) and applies a hybrid strategy of random flips, additions, and swaps to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1 + 0.3*value2)\n    weighted_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -19.85998185665816,
            -17.39775012658192
        ]
    },
    {
        "algorithm": "{A novel local search algorithm that selects solutions based on a weighted combination of value1 and value2 (with different weights) and applies a hybrid strategy of random flips, additions, and swaps to generate neighbors while ensuring feasibility, using a dynamic weight adjustment mechanism and a more aggressive exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 4) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(4, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(4, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Additionally, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution) and n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -20.156526203323033,
            -16.284959896844747
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective function (0.7*value1 + 0.3*value2) and applies a novel local search strategy that combines random item swaps with value-based selection to generate feasible neighbors while maintaining diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest hybrid objective (0.7*value1 + 0.3*value2)\n    hybrid_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_hybrid = max(hybrid_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_hybrid]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select 2-4 items to consider for swapping\n    # 2. For each selected item, decide to swap based on value density (value1/weight + value2/weight)\n    if n_items > 0:\n        num_consider = random.randint(2, min(4, n_items))\n        consider_indices = random.sample(range(n_items), num_consider)\n        value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n\n        for i in consider_indices:\n            if random.random() < 0.7:  # 70% chance to consider swapping\n                if new_solution[i] == 1:\n                    # Consider removing item i\n                    if current_weight - weight_lst[i] >= 0:\n                        new_solution[i] = 0\n                        current_weight -= weight_lst[i]\n                else:\n                    # Consider adding item i\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n        # Add one high-value item if possible\n        if random.random() < 0.5:  # 50% chance to add\n            best_candidate = -1\n            best_density = -1\n            for i in range(n_items):\n                if new_solution[i] == 0 and weight_lst[i] <= capacity - current_weight:\n                    if value_density[i] > best_density:\n                        best_density = value_density[i]\n                        best_candidate = i\n            if best_candidate != -1:\n                new_solution[best_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -19.706327123833194,
            -17.824505091890543
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined value1 and value2 (0.6*value1 + 0.4*value2)\n    combined_values = [0.6 * v1 + 0.4 * v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * v1 + 0.4 * v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Apply a secondary local search: swap two randomly selected items if feasible\n    if np.array_equal(new_solution, base_solution):\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            new_weight = current_weight - weight_lst[i] + weight_lst[j] if new_solution[i] == 1 else current_weight + weight_lst[i] - weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -19.448224902166032,
            -18.10980590086126
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score function that prioritizes solutions with high value1 and balanced value2, then applies a hybrid local search strategy that includes random flips, item additions, and swaps to generate a feasible neighbor solution while avoiding standard local search approaches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Apply a secondary local search: swap two randomly selected items if feasible\n    if np.array_equal(new_solution, base_solution):\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            new_weight = current_weight - weight_lst[i] + weight_lst[j] if new_solution[i] == 1 else current_weight + weight_lst[i] - weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -16.555957759797273,
            -19.799321033241775
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted score combining normalized value ratios and applies a hybrid local search strategy with multiple neighborhood exploration steps to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(5, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Apply a secondary local search: swap two randomly selected items if feasible\n    if np.array_equal(new_solution, base_solution):\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            new_weight = current_weight - weight_lst[i] + weight_lst[j] if new_solution[i] == 1 else current_weight + weight_lst[i] - weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply a tertiary local search: remove the least valuable item if solution is unchanged\n    if np.array_equal(new_solution, base_solution):\n        if current_weight > 0:\n            included_indices = np.where(base_solution == 1)[0]\n            if len(included_indices) > 0:\n                # Remove the item with the smallest ratio of (value1 + value2)/weight\n                values_ratio = (value1_lst + value2_lst) / weight_lst\n                least_valuable = included_indices[np.argmin(values_ratio[included_indices])]\n                new_solution[least_valuable] = 0\n\n    return new_solution\n\n",
        "score": [
            -16.990836650622562,
            -19.349874087166853
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic selection based on a moving trade-off between objectives\n    trade_off = 0.5 + 0.3 * (random.random() - 0.5)  # Randomly adjust trade-off between 0.2 and 0.8\n    weighted_values = [trade_off * (v1 / (v2 + 1e-10)) + (1 - trade_off) * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if trade_off * (v1 / (v2 + 1e-10)) + (1 - trade_off) * v2 == max_weighted]\n\n    base_solution = random.choice(candidates).copy() if candidates else archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Greedy local search with probabilistic item swaps\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Probabilistically accept swap based on value improvement\n            if random.random() < 0.7:  # Higher probability for better items\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            # Try removing low-value items with higher probability\n            if new_solution[i] == 1 and random.random() < 0.3:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Final pass to ensure feasibility\n    if current_weight > capacity:\n        # Remove items in order of lowest (value1 + value2) until feasible\n        items_included = np.where(new_solution == 1)[0]\n        combined_values = value1_lst[items_included] + value2_lst[items_included]\n        sorted_indices = np.argsort(combined_values)\n        for idx in sorted_indices:\n            if current_weight <= capacity:\n                break\n            item_idx = items_included[idx]\n            new_solution[item_idx] = 0\n            current_weight -= weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -16.705982198071005,
            -19.74826984053565
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{A new algorithm that prioritizes solutions with high value1-to-value2 ratio (0.7*value1/value2 + 0.3*value2) and applies a hybrid local search strategy combining strategic flips and item swaps, ensuring feasibility while balancing exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value2)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try swapping two items if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                delta = (weight_lst[j] - weight_lst[i]) * (new_solution[i] - new_solution[j])\n                if current_weight + delta <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -16.601509387424983,
            -19.79044321047939
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on a novel weighted objective score (0.7*value1 + 0.3*value2), then applies a hybrid local search strategy that intelligently flips up to 3 items while ensuring feasibility, or adds a single item if no valid flips are possible, and finally performs a targeted swap of items with the highest value-to-weight ratios to further improve the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest weighted objective score (0.7*value1 + 0.3*value2)\n    weighted_scores = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_score = max(weighted_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Apply hybrid local search:\n    # 1. Flip up to 3 items while maintaining feasibility\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # 2. If no valid flips, try adding a single item\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # 3. Perform targeted swaps of items with high value-to-weight ratios\n    if np.array_equal(new_solution, base_solution):\n        value_to_weight = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_indices = np.argsort(value_to_weight)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.767348156630717,
            -17.585858696736373
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamically weighted combination of value1 and value2, then applies a hybrid local search that intelligently combines item swaps and insertions while ensuring feasibility, with a fallback to random item addition if no valid operations exist.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted score (0.6*value1 + 0.4*value2)\n    weighted_scores = [0.6 * v1 + 0.4 * v2 for _, (v1, v2) in archive]\n    max_score = max(weighted_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * v1 + 0.4 * v2 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: try item swaps first\n    if n_items > 1:\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif new_solution[j] == 1 and current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # If no swap worked, try adding a single random item\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # If still no change, try removing a random item\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.45838477187838,
            -18.059268634772565
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance score that considers both objectives, then applies a hybrid local search strategy that intelligently combines item swaps and flips while ensuring feasibility, and if no valid moves exist, attempts to replace a subset of items with a better combination from the remaining ones.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest dominance score (value1 + value2)\n    dominance_scores = [v1 + v2 for _, (v1, v2) in archive]\n    max_score = max(dominance_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Try to swap items between included and excluded items\n    # 2. If no valid swaps, try to flip a subset of items\n    # 3. If still no valid moves, try to replace a subset with better items\n\n    # Step 1: Try swaps between included and excluded items\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        for _ in range(min(3, len(included), len(excluded))):\n            i = random.choice(included)\n            j = random.choice(excluded)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n\n    # Step 2: If no swaps, try flipping a subset of items\n    if np.array_equal(new_solution, base_solution):\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # Step 3: If still no valid moves, try replacing a subset with better items\n    if np.array_equal(new_solution, base_solution):\n        # Find items that could potentially improve both objectives\n        potential_items = []\n        for i in range(n_items):\n            if base_solution[i] == 0 and weight_lst[i] <= capacity - current_weight:\n                potential_items.append(i)\n\n        if potential_items:\n            # Select up to 2 best items based on combined value\n            item_scores = [(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in potential_items]\n            best_items = sorted(zip(potential_items, item_scores), key=lambda x: -x[1])[:2]\n            for i, _ in best_items:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.171893733302802,
            -18.450373338413584
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of value1 and value2 using a novel scoring metric that balances both objectives, then applies a local search strategy that intelligently reorders and flips subsets of items while ensuring feasibility, and if no valid flips exist, attempts to swap items between different positions to create a new solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined score of value1 and value2 (0.5*value1 + 0.5*value2)\n    combined_scores = [0.5 * v1 + 0.5 * v2 for _, (v1, v2) in archive]\n    max_score = max(combined_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.5 * v1 + 0.5 * v2 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to reorder\n    # 2. Flip their inclusion status while ensuring feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_reorder = random.randint(1, min(5, n_items))\n        reorder_indices = random.sample(range(n_items), num_reorder)\n        total_change = 0\n        for i in reorder_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in reorder_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try swapping items between different positions\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n                else:\n                    new_solution[j] = new_solution[i]\n                    new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -18.886081421304514,
            -18.845544957026316
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined score of value1 and value2, then applies a novel local search strategy that intelligently swaps pairs of items while ensuring feasibility, and if no valid swaps exist, attempts to replace a subset of items with new ones based on their marginal utility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined score (0.5*value1 + 0.5*value2)\n    combined_scores = [0.5 * v1 + 0.5 * v2 for _, (v1, v2) in archive]\n    max_score = max(combined_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.5 * v1 + 0.5 * v2 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Apply novel local search strategy: swap pairs of items\n    if n_items >= 2:\n        num_swaps = random.randint(1, min(3, n_items // 2))\n        for _ in range(num_swaps):\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                weight_diff = weight_lst[i] - weight_lst[j]\n                if current_weight + weight_diff <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight += weight_diff\n\n    # If no valid swaps, try replacing a subset of items with new ones\n    if np.array_equal(new_solution, base_solution):\n        num_replacements = random.randint(1, min(3, n_items))\n        replacement_indices = random.sample(range(n_items), num_replacements)\n        total_change = 0\n        for i in replacement_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in replacement_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -19.143235509702592,
            -18.55153139033473
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective value (0.6*value2 + 0.4*value1) and applies a hybrid local search strategy that either flips a subset of items or adds a single item while ensuring feasibility, with a focus on improving both objectives through intelligent random selection and targeted flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value (0.6*value2 + 0.4*value1)\n    combined_values = [0.6 * v2 + 0.4 * v1 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * v2 + 0.4 * v1 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip, prioritizing those that improve both objectives\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single item that improves both objectives\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -18.53236742773936,
            -18.89786394108764
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a base solution from the archive using a weighted score function combining value1 and value2 with different coefficients (0.4 for value1 and 0.6 for value2), then applies a hybrid local search strategy that flips up to 3 random items while ensuring feasibility, and if no flips are possible, attempts to add a single random item if feasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    weighted_values = [0.4 * v1 + 0.6 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.4 * v1 + 0.6 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -18.209257269694184,
            -19.03609815390373
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{A new algorithm that selects the solution with the highest combined score of (0.7 * value2 / (value1 + 1e-10) + 0.3 * value1) and applies a hybrid local search with up to 4 random flips, ensuring feasibility, and tries adding random items if no flips are valid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    weighted_values = [0.7 * (v2 / (v1 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v2 / (v1 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(4, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.98038064510674,
            -16.555277694122072
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that selects a solution from the archive based on a dynamic combination of objective values, then applies a randomized multi-item flip with feasibility checks and a secondary diversification step if no immediate improvement is found.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest dynamic objective combination (0.7*value2 + 0.3*value1)\n    dynamic_scores = [0.7 * v2 + 0.3 * v1 for _, (v1, v2) in archive]\n    max_score = max(dynamic_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v2 + 0.3 * v1 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Apply randomized multi-item flip with feasibility checks\n    if n_items > 0:\n        num_flips = random.randint(2, min(4, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n        else:\n            # If flip is infeasible, try to make it feasible by removing items\n            excess = (current_weight + total_change) - capacity\n            if excess > 0:\n                # Remove items with highest weight until feasible\n                temp_solution = new_solution.copy()\n                sorted_indices = np.argsort(weight_lst[temp_solution == 1])[::-1]\n                for i in sorted_indices:\n                    if weight_lst[i] <= excess:\n                        temp_solution[i] = 0\n                        excess -= weight_lst[i]\n                        if excess <= 0:\n                            break\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n\n    # If no valid flips, try adding a subset of items\n    if np.array_equal(new_solution, base_solution):\n        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        if remaining_capacity > 0:\n            # Select up to 3 items with highest value2/weight ratio\n            ratio = value2_lst / (weight_lst + 1e-10)\n            candidate_items = np.argsort(ratio)[::-1]\n            for i in candidate_items:\n                if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n                    if remaining_capacity <= 0 or len([x for x in new_solution if x == 1]) >= 3:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -17.653109336674245,
            -19.319807238807066
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    }
]