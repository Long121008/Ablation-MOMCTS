[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest weighted sum of values (0.7*value1 + 0.3*value2)\n    weighted_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.46868148635989,
            -17.628236078253344
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score (weighted by the inverse of the current total weight), then applies a hybrid local search combining value-weighted swaps, probabilistic flips with capacity-aware selection, and a diversified randomization step to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized objective score (weighted by inverse of current weight)\n        scores = []\n        for (sol, obj) in archive:\n            current_weight = np.sum(weight_lst[sol == 1])\n            normalized_score = (obj[0] * 0.6 + obj[1] * 0.4) / (1 + current_weight * 0.001)\n            scores.append(normalized_score)\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform value-weighted swaps with capacity consideration\n    for _ in range(min(4, n_items // 2)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select items with probability proportional to their normalized value\n            total_norm_value = np.sum((value1_lst[included] + value2_lst[included]) / (1 + weight_lst[included] * 0.01))\n            if total_norm_value > 0:\n                probs = ((value1_lst[included] + value2_lst[included]) / (1 + weight_lst[included] * 0.01)) / total_norm_value\n                i = np.random.choice(included, p=probs)\n            else:\n                i = random.choice(included)\n\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform probabilistic flips with capacity-aware selection\n    for i in range(n_items):\n        if random.random() < 0.5:  # 50% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item with probability based on value-to-weight ratio\n                value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                removal_prob = 0.2 / (1 + value_ratio * 0.1)\n                if random.random() < removal_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item with probability based on normalized value\n                if current_weight + weight_lst[i] <= capacity:\n                    norm_value = (value1_lst[i] + value2_lst[i]) / (1 + weight_lst[i] * 0.01)\n                    add_prob = min(1.0, norm_value * 0.03)\n                    if random.random() < add_prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 3: Diversified randomization with adaptive intensity\n    if random.random() < 0.3:  # 30% chance to perform randomization\n        k = min(4, n_items // 3)\n        indices = random.sample(range(n_items), k)\n        for i in indices:\n            if random.random() < 0.6 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1 and random.random() < 0.4:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -19.289990973922087,
            -17.64198750765911
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest weighted sum of values (0.7*value1 + 0.3*value2)\n    weighted_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.46868148635989,
            -17.628236078253344
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that balances both objectives more equally, then applies a hybrid local search that combines value-weighted swaps, adaptive flips, and a diversity-preserving randomization step to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized objective score (equal weighting)\n        max_obj1 = max(obj[0] for (sol, obj) in archive)\n        max_obj2 = max(obj[1] for (sol, obj) in archive)\n        scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for (sol, obj) in archive]\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform value-weighted swaps with adaptive selection\n    for _ in range(min(5, n_items // 2)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select items with probability proportional to their normalized combined value\n            total_value = np.sum((value1_lst[included] + value2_lst[included]) / weight_lst[included])\n            if total_value > 0:\n                probs = ((value1_lst[included] + value2_lst[included]) / weight_lst[included]) / total_value\n                i = np.random.choice(included, p=probs)\n            else:\n                i = random.choice(included)\n\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform adaptive flips with value-to-weight ratio consideration\n    for i in range(n_items):\n        if random.random() < 0.5:  # 50% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item with probability based on value-to-weight ratio\n                removal_prob = 0.2 / (1 + (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                if random.random() < removal_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item with probability based on value-to-weight ratio and capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    capacity_factor = (capacity - current_weight) / capacity\n                    add_prob = min(1.0, value_ratio * 0.1 * capacity_factor)\n                    if random.random() < add_prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 3: Diversity-preserving randomization\n    if random.random() < 0.3:  # 30% chance to perform randomization\n        k = min(4, n_items // 3)\n        indices = random.sample(range(n_items), k)\n        for i in indices:\n            if random.random() < 0.6:  # Higher probability to flip\n                if new_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                elif current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.94948604412736,
            -18.5027602829134
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    }
]