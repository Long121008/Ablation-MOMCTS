[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search that combines item swaps and probabilistic flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate potential improvement score (e.g., sum of both objective values)\n        scores = [sum(obj) for (sol, obj) in archive]\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform item swaps (swap between included and excluded items)\n    for _ in range(min(3, n_items // 2)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform probabilistic flips (flip based on value-to-weight ratio)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[i] <= capacity:\n                    # Use a combined value-to-weight ratio for both objectives\n                    ratio1 = value1_lst[i] / weight_lst[i]\n                    ratio2 = value2_lst[i] / weight_lst[i]\n                    combined_ratio = ratio1 + ratio2\n\n                    # Higher ratio items are more likely to be added\n                    if random.random() < min(1.0, combined_ratio * 0.1):\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -15.857052425877802,
            -15.96694236282906
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating a hybrid fitness metric combining objective values and solution diversity, then applies a novel local search operator that dynamically combines item swaps and insertions based on objective gradients to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on hybrid fitness (objective values + diversity)\n    selected_idx = 0\n    max_fitness = -np.inf\n    for i, (sol, obj) in enumerate(archive):\n        # Fitness is a combination of objective values and solution diversity\n        fitness = obj[0] + obj[1] + np.sum(sol)  # Simple hybrid metric\n        if fitness > max_fitness:\n            max_fitness = fitness\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Dynamic item swap and insertion\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) == 0 or len(items_out) == 0:\n        return new_solution  # No possible moves\n\n    # Calculate gradients for objectives\n    grad1 = value1_lst / weight_lst\n    grad2 = value2_lst / weight_lst\n\n    # Combine gradients with a dynamic weight\n    alpha = np.random.uniform(0.3, 0.7)  # Random weight for gradient combination\n    combined_grad = alpha * grad1 + (1 - alpha) * grad2\n\n    # Sort items by combined gradient in descending order\n    sorted_items = np.argsort(-combined_grad)\n\n    # Try to improve by swapping or inserting items based on gradients\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try to remove this item if it has low gradient\n            temp_sol = new_solution.copy()\n            temp_sol[item] = 0\n            if np.dot(temp_sol, weight_lst) <= capacity:\n                new_solution = temp_sol\n                break\n        else:\n            # Try to add this item if it has high gradient\n            temp_sol = new_solution.copy()\n            temp_sol[item] = 1\n            if np.dot(temp_sol, weight_lst) <= capacity:\n                new_solution = temp_sol\n                break\n\n    return new_solution\n\n",
        "score": [
            -13.968084136897346,
            -13.814044156573527
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search that combines item swaps and probabilistic flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate potential improvement score (e.g., sum of both objective values)\n        scores = [sum(obj) for (sol, obj) in archive]\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform item swaps (swap between included and excluded items)\n    for _ in range(min(3, n_items // 2)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform probabilistic flips (flip based on value-to-weight ratio)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item\n                if current_weight + weight_lst[i] <= capacity:\n                    # Use a combined value-to-weight ratio for both objectives\n                    ratio1 = value1_lst[i] / weight_lst[i]\n                    ratio2 = value2_lst[i] / weight_lst[i]\n                    combined_ratio = ratio1 + ratio2\n\n                    # Higher ratio items are more likely to be added\n                    if random.random() < min(1.0, combined_ratio * 0.1):\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -15.857052425877802,
            -15.96694236282906
        ]
    }
]