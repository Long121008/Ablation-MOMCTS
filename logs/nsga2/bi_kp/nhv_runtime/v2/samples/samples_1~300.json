[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.8192238200001005,
            1.5372501611709595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.8192238200001005,
            1.5372501611709595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.8192238200001005,
            1.5372501611709595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9719549471395192,
            3.08738049864769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9719549471395192,
            3.08738049864769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This heuristic function selects a non-dominated solution from the archive with high potential, then applies a hybrid local search operator combining random item swaps, value-based perturbations, and capacity-aware adjustments to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives to identify high-potential solutions\n        objectives = np.array([obj for (_, obj) in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap a few items\n    n_swaps = min(3, len(new_solution) // 2)\n    swap_indices = random.sample(range(len(new_solution)), n_swaps)\n    for i in swap_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Add items with high value-to-weight ratio if capacity allows\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for objective 1\n        vw_ratio1 = value1_lst / weight_lst\n        # Sort by ratio and select top items\n        sorted_indices = np.argsort(vw_ratio1)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n                if remaining_capacity <= 0:\n                    break\n\n    # Step 3: Remove low-value items to free up space\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Calculate value-to-weight ratios for objective 2\n        vw_ratio2 = value2_lst / weight_lst\n        # Sort by ratio and remove low-value items\n        sorted_indices = np.argsort(vw_ratio2)\n        for i in sorted_indices:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                if np.sum(weight_lst[new_solution == 1]) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3696789771971773,
            1.9958027601242065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives to identify high-potential solutions\n        objectives = np.array([obj for (_, obj) in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap a few items\n    n_swaps = min(3, len(new_solution) // 2)\n    swap_indices = random.sample(range(len(new_solution)), n_swaps)\n    for i in swap_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Add items with high value-to-weight ratio if capacity allows\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for objective 1\n        vw_ratio1 = value1_lst / weight_lst\n        # Sort by ratio and select top items\n        sorted_indices = np.argsort(vw_ratio1)[::-1]\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n                if remaining_capacity <= 0:\n                    break\n\n    # Step 3: Remove low-value items to free up space\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Calculate value-to-weight ratios for objective 2\n        vw_ratio2 = value2_lst / weight_lst\n        # Sort by ratio and remove low-value items\n        sorted_indices = np.argsort(vw_ratio2)\n        for i in sorted_indices:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                if np.sum(weight_lst[new_solution == 1]) <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing solutions with the highest objective values, then applies a hybrid local search that combines item swaps and adaptive perturbations to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest value in either objective)\n    archive.sort(key=lambda x: max(x[1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap items and apply adaptive perturbations\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with the lowest (value1 + value2) until feasible\n        while total_weight > capacity:\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break\n            # Select the item with the lowest combined value\n            values = value1_lst + value2_lst\n            remove_idx = candidate_indices[np.argmin(values[candidate_indices])]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Apply adaptive perturbations based on objective diversity\n    obj1, obj2 = archive[0][1]\n    if obj1 > obj2:\n        # Perturb to improve value2 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value2 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value2_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n    else:\n        # Perturb to improve value1 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value1 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value1_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3414704594993703,
            0.7952825427055359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest value in either objective)\n    archive.sort(key=lambda x: max(x[1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap items and apply adaptive perturbations\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with the lowest (value1 + value2) until feasible\n        while total_weight > capacity:\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break\n            # Select the item with the lowest combined value\n            values = value1_lst + value2_lst\n            remove_idx = candidate_indices[np.argmin(values[candidate_indices])]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Apply adaptive perturbations based on objective diversity\n    obj1, obj2 = archive[0][1]\n    if obj1 > obj2:\n        # Perturb to improve value2 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value2 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value2_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n    else:\n        # Perturb to improve value1 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value1 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value1_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing solutions with the highest objective values, then applies a hybrid local search that combines item swaps and adaptive perturbations to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest value in either objective)\n    archive.sort(key=lambda x: max(x[1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap items and apply adaptive perturbations\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with the lowest (value1 + value2) until feasible\n        while total_weight > capacity:\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break\n            # Select the item with the lowest combined value\n            values = value1_lst + value2_lst\n            remove_idx = candidate_indices[np.argmin(values[candidate_indices])]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Apply adaptive perturbations based on objective diversity\n    obj1, obj2 = archive[0][1]\n    if obj1 > obj2:\n        # Perturb to improve value2 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value2 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value2_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n    else:\n        # Perturb to improve value1 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value1 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value1_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3414704594993703,
            0.7952825427055359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest value in either objective)\n    archive.sort(key=lambda x: max(x[1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap items and apply adaptive perturbations\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with the lowest (value1 + value2) until feasible\n        while total_weight > capacity:\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break\n            # Select the item with the lowest combined value\n            values = value1_lst + value2_lst\n            remove_idx = candidate_indices[np.argmin(values[candidate_indices])]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Apply adaptive perturbations based on objective diversity\n    obj1, obj2 = archive[0][1]\n    if obj1 > obj2:\n        # Perturb to improve value2 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value2 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value2_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n    else:\n        # Perturb to improve value1 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value1 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value1_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3336259323310398,
            0.6336628198623657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3336259323310398,
            0.6336628198623657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This new algorithm selects a solution from the archive based on the diversity of its objective values, then applies a dynamic neighborhood search that alternates between adding and removing items in a way that balances both objectives while ensuring feasibility, using a priority-based selection mechanism to guide the search toward non-dominated improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity in objectives\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] * x[1][1]))  # Prioritize solutions with balanced objectives\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])[0].copy()\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Dynamic neighborhood search: alternate between adding and removing items\n    for _ in range(15):\n        # Priority-based item selection: prioritize items that improve both objectives\n        priority_scores = (value1_lst / (current_value1 + 1e-6)) + (value2_lst / (current_value2 + 1e-6))\n        if random.random() < 0.7:  # 70% chance to add an item\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                idx = candidates[np.argmax(priority_scores[candidates])]\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n        else:  # 30% chance to remove an item\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                idx = candidates[np.argmin(priority_scores[candidates])]\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2611736908010569,
            4.969509482383728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity in objectives\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] * x[1][1]))  # Prioritize solutions with balanced objectives\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 3)])[0].copy()\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Dynamic neighborhood search: alternate between adding and removing items\n    for _ in range(15):\n        # Priority-based item selection: prioritize items that improve both objectives\n        priority_scores = (value1_lst / (current_value1 + 1e-6)) + (value2_lst / (current_value2 + 1e-6))\n        if random.random() < 0.7:  # 70% chance to add an item\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                idx = candidates[np.argmax(priority_scores[candidates])]\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n        else:  # 30% chance to remove an item\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                idx = candidates[np.argmin(priority_scores[candidates])]\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The heuristic function selects a solution from the archive based on a crowding-distance metric to identify under-explored regions, then applies a novel local search strategy that combines item swaps and strategic flips to explore the neighborhood while maintaining feasibility through adaptive capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest crowding distance (under-explored region)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_obj1 = np.sort(objectives[:, 0])\n    sorted_obj2 = np.sort(objectives[:, 1])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_dist[i] = float('inf')\n        else:\n            crowding_dist[i] = (sorted_obj1[i+1] - sorted_obj1[i-1]) / (sorted_obj1[-1] - sorted_obj1[0] + 1e-6) + \\\n                               (sorted_obj2[i+1] - sorted_obj2[i-1]) / (sorted_obj2[-1] - sorted_obj2[0] + 1e-6)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swaps and strategic flips\n    num_swaps = np.random.randint(1, min(5, len(weight_lst)//2))\n    for _ in range(num_swaps):\n        # Select two items to swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) < 2:\n            break\n        swap_idx1, swap_idx2 = np.random.choice(items, 2, replace=False)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[swap_idx2] - weight_lst[swap_idx1]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n            current_weight += delta_weight\n\n    # Strategic flips based on value-weight ratio\n    value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(value_ratio)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:  # Small chance to remove low-value items\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.41695072272119005,
            6.81704169511795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest crowding distance (under-explored region)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_obj1 = np.sort(objectives[:, 0])\n    sorted_obj2 = np.sort(objectives[:, 1])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_dist[i] = float('inf')\n        else:\n            crowding_dist[i] = (sorted_obj1[i+1] - sorted_obj1[i-1]) / (sorted_obj1[-1] - sorted_obj1[0] + 1e-6) + \\\n                               (sorted_obj2[i+1] - sorted_obj2[i-1]) / (sorted_obj2[-1] - sorted_obj2[0] + 1e-6)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: item swaps and strategic flips\n    num_swaps = np.random.randint(1, min(5, len(weight_lst)//2))\n    for _ in range(num_swaps):\n        # Select two items to swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) < 2:\n            break\n        swap_idx1, swap_idx2 = np.random.choice(items, 2, replace=False)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[swap_idx2] - weight_lst[swap_idx1]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n            current_weight += delta_weight\n\n    # Strategic flips based on value-weight ratio\n    value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(value_ratio)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:  # Small chance to remove low-value items\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The new algorithm selects a solution from the archive by identifying the one with the highest diversity in terms of item selection patterns, then applies a novel local search strategy that combines item swapping with objective-aware perturbations to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest diversity (most unique item selections)\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - np.mean(archive[0][0])))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Objective-aware item swapping and perturbation\n    for _ in range(5):  # Limit iterations\n        # Select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n        if current_weight + delta_weight <= capacity:\n            # Perform swap if it improves at least one objective\n            if new_solution[item1] != new_solution[item2]:\n                delta_value1 = value1_lst[item2] - value1_lst[item1]\n                delta_value2 = value2_lst[item2] - value2_lst[item1]\n\n                if delta_value1 > 0 or delta_value2 > 0:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight += delta_weight\n\n        # Random perturbation: flip a random item if feasible\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3417897572946574,
            4.3854182958602905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest diversity (most unique item selections)\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - np.mean(archive[0][0])))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Objective-aware item swapping and perturbation\n    for _ in range(5):  # Limit iterations\n        # Select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n        if current_weight + delta_weight <= capacity:\n            # Perform swap if it improves at least one objective\n            if new_solution[item1] != new_solution[item2]:\n                delta_value1 = value1_lst[item2] - value1_lst[item1]\n                delta_value2 = value2_lst[item2] - value2_lst[item1]\n\n                if delta_value1 > 0 or delta_value2 > 0:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight += delta_weight\n\n        # Random perturbation: flip a random item if feasible\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The new algorithm selects a solution from the archive based on the diversity of its objective values, then applies a local search that iteratively adjusts item selections by considering the trade-off between objectives and the impact on solution diversity, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the most diverse objective values (highest product of objectives)\n    diversity_scores = [obj[0] * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate normalized objective contributions\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    norm_value1 = value1_lst / (total_value1 + 1e-6)\n    norm_value2 = value2_lst / (total_value2 + 1e-6)\n\n    # Dynamic trade-off based on current solution's objective balance\n    if current_value1 + current_value2 > 0:\n        alpha = current_value1 / (current_value1 + current_value2)\n    else:\n        alpha = 0.5\n\n    # Calculate diversity-aware marginal benefit\n    marginal_benefit = (alpha * norm_value1 + (1 - alpha) * norm_value2) - (new_solution * (alpha * norm_value1 + (1 - alpha) * norm_value2))\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Iterative improvement with diversity consideration\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Consider removing item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Consider adding item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8972129638258743,
            2.0424638092517853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the most diverse objective values (highest product of objectives)\n    diversity_scores = [obj[0] * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate normalized objective contributions\n    total_value1 = np.sum(value1_lst)\n    total_value2 = np.sum(value2_lst)\n    norm_value1 = value1_lst / (total_value1 + 1e-6)\n    norm_value2 = value2_lst / (total_value2 + 1e-6)\n\n    # Dynamic trade-off based on current solution's objective balance\n    if current_value1 + current_value2 > 0:\n        alpha = current_value1 / (current_value1 + current_value2)\n    else:\n        alpha = 0.5\n\n    # Calculate diversity-aware marginal benefit\n    marginal_benefit = (alpha * norm_value1 + (1 - alpha) * norm_value2) - (new_solution * (alpha * norm_value1 + (1 - alpha) * norm_value2))\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Iterative improvement with diversity consideration\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Consider removing item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Consider adding item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The heuristic function selects a solution from the archive based on a diversity-aware criterion (e.g., least similar to others in the archive) and applies a novel local search strategy that flips items in a way that simultaneously considers both objectives and their trade-offs, while ensuring feasibility through a capacity-preserving adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the least similar solution to the archive (diversity-aware selection)\n    base_solution = archive[0][0].copy()\n    min_similarity = float('inf')\n    for sol, _ in archive:\n        similarity = np.sum(base_solution == sol) / len(base_solution)\n        if similarity < min_similarity:\n            min_similarity = similarity\n            base_solution = sol.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive weights\n    alpha = np.random.uniform(0.2, 0.8)\n    beta = 1 - alpha\n    marginal_benefit = (alpha * value1_lst + beta * value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip: prioritize items with high marginal benefit and low similarity to current solution\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: flip a small random subset of items to escape local optima\n    perturbation_size = max(1, int(0.1 * len(weight_lst)))\n    perturbation_indices = np.random.choice(len(weight_lst), size=perturbation_size, replace=False)\n    for idx in perturbation_indices:\n        if np.random.rand() < 0.5 and new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        elif new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4560462811775242,
            4.011120319366455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the least similar solution to the archive (diversity-aware selection)\n    base_solution = archive[0][0].copy()\n    min_similarity = float('inf')\n    for sol, _ in archive:\n        similarity = np.sum(base_solution == sol) / len(base_solution)\n        if similarity < min_similarity:\n            min_similarity = similarity\n            base_solution = sol.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive weights\n    alpha = np.random.uniform(0.2, 0.8)\n    beta = 1 - alpha\n    marginal_benefit = (alpha * value1_lst + beta * value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip: prioritize items with high marginal benefit and low similarity to current solution\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: flip a small random subset of items to escape local optima\n    perturbation_size = max(1, int(0.1 * len(weight_lst)))\n    perturbation_indices = np.random.choice(len(weight_lst), size=perturbation_size, replace=False)\n    for idx in perturbation_indices:\n        if np.random.rand() < 0.5 and new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        elif new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity and potential for improvement, then applies a novel local search strategy that combines item flipping with a dynamic objective weighting scheme to explore the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a diverse solution from the archive\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic objective weighting\n    alpha = np.random.uniform(0.2, 0.8)\n    beta = 1 - alpha\n\n    # Calculate marginal benefits for both objectives\n    marginal_benefit1 = value1_lst / (weight_lst + 1e-6)\n    marginal_benefit2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine benefits with dynamic weights\n    combined_benefit = alpha * marginal_benefit1 + beta * marginal_benefit2\n    sorted_indices = np.argsort(combined_benefit)[::-1]\n\n    # Flip items to maximize combined benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Additional random perturbation to escape local optima\n    for _ in range(3):\n        idx = np.random.choice(len(weight_lst))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5131788660538378,
            4.983749181032181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a diverse solution from the archive\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic objective weighting\n    alpha = np.random.uniform(0.2, 0.8)\n    beta = 1 - alpha\n\n    # Calculate marginal benefits for both objectives\n    marginal_benefit1 = value1_lst / (weight_lst + 1e-6)\n    marginal_benefit2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine benefits with dynamic weights\n    combined_benefit = alpha * marginal_benefit1 + beta * marginal_benefit2\n    sorted_indices = np.argsort(combined_benefit)[::-1]\n\n    # Flip items to maximize combined benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Additional random perturbation to escape local optima\n    for _ in range(3):\n        idx = np.random.choice(len(weight_lst))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm selects a solution from the archive based on its objective diversity, then applies a novel local search strategy that dynamically rebalances item selections by prioritizing items with high marginal benefit while ensuring feasibility through adaptive capacity adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity (max range between objectives)\n    diversity_scores = [max(obj) - min(obj) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic priority calculation for items\n    remaining_capacity = capacity - current_weight\n    priority = (value1_lst / (weight_lst + 1e-6)) * (1 + 0.5 * (value2_lst / (weight_lst + 1e-6)))\n    sorted_indices = np.argsort(priority)[::-1]\n\n    # Adaptive item selection based on remaining capacity\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Consider removing items if they're not critical\n            if current_weight - weight_lst[idx] <= capacity and \\\n               (current_value1 - value1_lst[idx] >= 0.9 * current_value1 or\n                current_value2 - value2_lst[idx] >= 0.9 * current_value2):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Add items if they fit and improve both objectives\n            if weight_lst[idx] <= remaining_capacity and \\\n               (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                remaining_capacity = capacity - current_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8538350105441987,
            3.182452976703644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity (max range between objectives)\n    diversity_scores = [max(obj) - min(obj) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Dynamic priority calculation for items\n    remaining_capacity = capacity - current_weight\n    priority = (value1_lst / (weight_lst + 1e-6)) * (1 + 0.5 * (value2_lst / (weight_lst + 1e-6)))\n    sorted_indices = np.argsort(priority)[::-1]\n\n    # Adaptive item selection based on remaining capacity\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Consider removing items if they're not critical\n            if current_weight - weight_lst[idx] <= capacity and \\\n               (current_value1 - value1_lst[idx] >= 0.9 * current_value1 or\n                current_value2 - value2_lst[idx] >= 0.9 * current_value2):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Add items if they fit and improve both objectives\n            if weight_lst[idx] <= remaining_capacity and \\\n               (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                remaining_capacity = capacity - current_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a hybrid local search that combines item swapping with targeted flipping of items to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Compute crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = []\n    for i in range(len(objectives)):\n        distances = np.sum(np.abs(objectives - objectives[i]), axis=1)\n        crowding_distances.append(np.sum(distances))\n\n    # Select solution with minimum crowding distance (most under-explored)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swapping and targeted flipping\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Perform item swaps first\n    for _ in range(5):\n        idx1, idx2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = weight_lst[idx2] - weight_lst[idx1]\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight += delta_weight\n                current_value1 += value1_lst[idx2] - value1_lst[idx1]\n                current_value2 += value2_lst[idx2] - value2_lst[idx1]\n\n    # Then perform targeted flipping\n    for _ in range(5):\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves significantly\n                if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1) or \\\n                   (new_value1 >= current_value1 and new_value2 >= current_value2 - 0.2 * current_value2) or \\\n                   (new_value2 >= current_value2 and new_value1 >= current_value1 - 0.2 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves significantly\n                if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1) or \\\n                   (new_value1 >= current_value1 and new_value2 >= current_value2 - 0.2 * current_value2) or \\\n                   (new_value2 >= current_value2 and new_value1 >= current_value1 - 0.2 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.7958298425161398,
            7.432373017072678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Compute crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = []\n    for i in range(len(objectives)):\n        distances = np.sum(np.abs(objectives - objectives[i]), axis=1)\n        crowding_distances.append(np.sum(distances))\n\n    # Select solution with minimum crowding distance (most under-explored)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swapping and targeted flipping\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Perform item swaps first\n    for _ in range(5):\n        idx1, idx2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = weight_lst[idx2] - weight_lst[idx1]\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight += delta_weight\n                current_value1 += value1_lst[idx2] - value1_lst[idx1]\n                current_value2 += value2_lst[idx2] - value2_lst[idx1]\n\n    # Then perform targeted flipping\n    for _ in range(5):\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves significantly\n                if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1) or \\\n                   (new_value1 >= current_value1 and new_value2 >= current_value2 - 0.2 * current_value2) or \\\n                   (new_value2 >= current_value2 and new_value1 >= current_value1 - 0.2 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves significantly\n                if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1) or \\\n                   (new_value1 >= current_value1 and new_value2 >= current_value2 - 0.2 * current_value2) or \\\n                   (new_value2 >= current_value2 and new_value1 >= current_value1 - 0.2 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a dynamic local search strategy that flips a subset of items based on a weighted trade-off between the two objectives, prioritizing items with the highest marginal benefit while ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    alpha = np.random.uniform(0.1, 0.9)\n    beta = 1 - alpha\n\n    marginal_benefit = (alpha * value1_lst + beta * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6146008690190655,
            2.139075994491577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    alpha = np.random.uniform(0.1, 0.9)\n    beta = 1 - alpha\n\n    marginal_benefit = (alpha * value1_lst + beta * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a local search strategy that dynamically prioritizes items with high marginal benefit for either objective, while maintaining feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic prioritization based on objective dominance\n    obj1_dominance = np.mean([obj[0] for _, obj in archive]) > np.mean([obj[1] for _, obj in archive])\n    alpha = 0.7 if obj1_dominance else 0.3  # Higher alpha if obj1 is more dominant\n\n    # Calculate marginal benefit with dynamic alpha\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8439422287456034,
            2.4353493750095367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic prioritization based on objective dominance\n    obj1_dominance = np.mean([obj[0] for _, obj in archive]) > np.mean([obj[1] for _, obj in archive])\n    alpha = 0.7 if obj1_dominance else 0.3  # Higher alpha if obj1 is more dominant\n\n    # Calculate marginal benefit with dynamic alpha\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of objective values with random weights, then generates a neighbor by flipping items with high marginal contribution while ensuring feasibility through a dynamic adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Select top 20% of items with highest marginal contribution\n    top_n = max(1, len(combined_contrib) // 5)\n    high_contrib_items = np.argsort(combined_contrib)[-top_n:]\n\n    # Randomly select 3 items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with dynamic adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(current_contrib)\n        # Remove items until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.366206272206913,
            2.2621029317379
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Select top 20% of items with highest marginal contribution\n    top_n = max(1, len(combined_contrib) // 5)\n    high_contrib_items = np.argsort(combined_contrib)[-top_n:]\n\n    # Randomly select 3 items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with dynamic adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(current_contrib)\n        # Remove items until feasible\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The new algorithm selects a solution from the archive based on its potential for improving one objective while minimally compromising the other, then applies a novel local search that combines random swaps of items with a greedy selection of items that maximize the marginal improvement ratio for both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement in one objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Perform random swaps\n    for _ in range(5):\n        idx1, idx2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            else:\n                current_weight = new_weight\n\n    # Greedily add items with high marginal improvement ratio\n    for idx in np.argsort(-(value1_lst / weight_lst + value2_lst / weight_lst)):\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.37544125955728636,
            7.730905175209045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement in one objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Perform random swaps\n    for _ in range(5):\n        idx1, idx2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            else:\n                current_weight = new_weight\n\n    # Greedily add items with high marginal improvement ratio\n    for idx in np.argsort(-(value1_lst / weight_lst + value2_lst / weight_lst)):\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest dominance count (number of solutions it dominates), then applies a hybrid local search that combines greedy selection of items with high marginal benefit for both objectives and a probabilistic flip mechanism to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance count (simplified proxy)\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for sol_j, obj_j in archive:\n            if (obj_i[0] >= obj_j[0] and obj_i[1] > obj_j[1]) or (obj_i[0] > obj_j[0] and obj_i[1] >= obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine greedy and probabilistic flips\n    for _ in range(5):  # Number of iterations\n        # Greedy selection: prioritize items with high combined marginal benefit\n        combined_benefit = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(combined_benefit)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Probabilistic flip: randomly flip some items to escape local optima\n        if np.random.rand() < 0.3:  # 30% chance\n            flip_idx = np.random.choice(len(weight_lst))\n            if new_solution[flip_idx] == 1 and current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n            elif new_solution[flip_idx] == 0 and current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4079102026691276,
            9.317219585180283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance count (simplified proxy)\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for sol_j, obj_j in archive:\n            if (obj_i[0] >= obj_j[0] and obj_i[1] > obj_j[1]) or (obj_i[0] > obj_j[0] and obj_i[1] >= obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine greedy and probabilistic flips\n    for _ in range(5):  # Number of iterations\n        # Greedy selection: prioritize items with high combined marginal benefit\n        combined_benefit = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(combined_benefit)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Probabilistic flip: randomly flip some items to escape local optima\n        if np.random.rand() < 0.3:  # 30% chance\n            flip_idx = np.random.choice(len(weight_lst))\n            if new_solution[flip_idx] == 1 and current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n            elif new_solution[flip_idx] == 0 and current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The new heuristic selects a solution from the archive with the highest product of objective values, then applies a hybrid local search that flips items based on a dynamic trade-off between objectives, prioritizing items with high marginal benefit while dynamically adjusting the trade-off factor to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest product of objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive factor\n    alpha = np.random.uniform(0.4, 0.6)  # Tighter trade-off factor\n    beta = 0.1 * np.random.normal(0, 1)  # Small random perturbation\n\n    # Hybrid marginal benefit score\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) * (1 + beta) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7608023705078122,
            2.0600127279758453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest product of objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive factor\n    alpha = np.random.uniform(0.4, 0.6)  # Tighter trade-off factor\n    beta = 0.1 * np.random.normal(0, 1)  # Small random perturbation\n\n    # Hybrid marginal benefit score\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) * (1 + beta) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted score of its objectives, then generates a neighbor by flipping items with high marginal contribution while ensuring feasibility through a novel two-phase adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        score = 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n        scores.append(score)\n\n    # Select the solution with the highest weighted score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = 0.6 * marginal_contrib1 + 0.4 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(4, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Two-phase adjustment: first remove items with lowest marginal contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n        # If still over capacity, remove items with lowest weight-to-value ratio\n        if current_weight > capacity:\n            weight_to_value = weight_lst / (value1_lst + value2_lst + 1e-6)  # Avoid division by zero\n            remove_order = np.argsort(weight_to_value)\n            for idx in remove_order:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.3951723694699628,
            0.8210012018680573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        score = 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n        scores.append(score)\n\n    # Select the solution with the highest weighted score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = 0.6 * marginal_contrib1 + 0.4 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(4, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Two-phase adjustment: first remove items with lowest marginal contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n        # If still over capacity, remove items with lowest weight-to-value ratio\n        if current_weight > capacity:\n            weight_to_value = weight_lst / (value1_lst + value2_lst + 1e-6)  # Avoid division by zero\n            remove_order = np.argsort(weight_to_value)\n            for idx in remove_order:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest diversity in its objective values, then applies a novel local search strategy that flips items based on a dynamic trade-off between the two objectives, while ensuring feasibility by prioritizing items with the highest marginal benefit in the less dominated objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest diversity in objectives\n    diversity = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives based on current solution's dominance\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 > obj2:\n        alpha = np.random.uniform(0.6, 0.9)  # Prioritize objective 1\n    else:\n        alpha = np.random.uniform(0.1, 0.4)  # Prioritize objective 2\n\n    # Calculate marginal benefit for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combined marginal benefit with dynamic trade-off\n    combined_marginal = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Sort items by combined marginal benefit\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8431839970942665,
            2.8469770550727844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest diversity in objectives\n    diversity = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives based on current solution's dominance\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 > obj2:\n        alpha = np.random.uniform(0.6, 0.9)  # Prioritize objective 1\n    else:\n        alpha = np.random.uniform(0.1, 0.4)  # Prioritize objective 2\n\n    # Calculate marginal benefit for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combined marginal benefit with dynamic trade-off\n    combined_marginal = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Sort items by combined marginal benefit\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective values, then applies a hybrid local search strategy that combines item swapping with a probabilistic selection of items based on their marginal contributions to both objectives, ensuring feasibility by iteratively adjusting the solution while maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for swapping\n    selected_items = np.where(new_solution == 1)[0]\n    unselected_items = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection strategy: prioritize items with high marginal contributions\n    # but also consider diversity by including some low-contribution items\n    high_contrib_items = np.argsort(marginal_contrib1 + marginal_contrib2)[-len(weight_lst)//2:]\n\n    # Randomly select items to swap\n    swap_candidates = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Perform swaps while maintaining feasibility\n    for idx in swap_candidates:\n        if new_solution[idx] == 1:\n            # Try to remove this item and add a random unselected item\n            potential_weight = current_weight - weight_lst[idx]\n            if potential_weight <= capacity:\n                # Find a random unselected item that can be added\n                possible_additions = [i for i in unselected_items if potential_weight + weight_lst[i] <= capacity]\n                if possible_additions:\n                    add_idx = np.random.choice(possible_additions)\n                    new_solution[idx] = 0\n                    new_solution[add_idx] = 1\n                    current_weight = potential_weight + weight_lst[add_idx]\n        else:\n            # Try to add this item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4770052322352457,
            4.857054054737091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for swapping\n    selected_items = np.where(new_solution == 1)[0]\n    unselected_items = np.where(new_solution == 0)[0]\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection strategy: prioritize items with high marginal contributions\n    # but also consider diversity by including some low-contribution items\n    high_contrib_items = np.argsort(marginal_contrib1 + marginal_contrib2)[-len(weight_lst)//2:]\n\n    # Randomly select items to swap\n    swap_candidates = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Perform swaps while maintaining feasibility\n    for idx in swap_candidates:\n        if new_solution[idx] == 1:\n            # Try to remove this item and add a random unselected item\n            potential_weight = current_weight - weight_lst[idx]\n            if potential_weight <= capacity:\n                # Find a random unselected item that can be added\n                possible_additions = [i for i in unselected_items if potential_weight + weight_lst[i] <= capacity]\n                if possible_additions:\n                    add_idx = np.random.choice(possible_additions)\n                    new_solution[idx] = 0\n                    new_solution[add_idx] = 1\n                    current_weight = potential_weight + weight_lst[add_idx]\n        else:\n            # Try to add this item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Compute the weighted marginal contribution for each item (prioritize high-value, low-weight items)\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items that can be added without exceeding capacity\n    candidate_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n\n    # If no items can be added, consider removing low-contribution items\n    if len(candidate_items) == 0:\n        candidate_items = np.where(new_solution == 1)[0]\n        combined_contrib = (value1_lst + value2_lst) * new_solution\n\n    # Perform a weighted random walk: higher contribution items have higher probability of being selected\n    probs = combined_contrib[candidate_items]\n    probs = probs / np.sum(probs)  # Normalize to probabilities\n    selected_idx = np.random.choice(candidate_items, p=probs)\n\n    # Toggle the selected item (add or remove based on current state)\n    new_solution[selected_idx] = 1 - new_solution[selected_idx]\n\n    # Ensure feasibility by adjusting the solution if necessary\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9348333587257869,
            1.9338580071926117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Compute the weighted marginal contribution for each item (prioritize high-value, low-weight items)\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items that can be added without exceeding capacity\n    candidate_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n\n    # If no items can be added, consider removing low-contribution items\n    if len(candidate_items) == 0:\n        candidate_items = np.where(new_solution == 1)[0]\n        combined_contrib = (value1_lst + value2_lst) * new_solution\n\n    # Perform a weighted random walk: higher contribution items have higher probability of being selected\n    probs = combined_contrib[candidate_items]\n    probs = probs / np.sum(probs)  # Normalize to probabilities\n    selected_idx = np.random.choice(candidate_items, p=probs)\n\n    # Toggle the selected item (add or remove based on current state)\n    new_solution[selected_idx] = 1 - new_solution[selected_idx]\n\n    # Ensure feasibility by adjusting the solution if necessary\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, while also incorporating a probabilistic selection mechanism to explore diverse neighborhoods and maintain solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic selection\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n    beta = np.random.uniform(0.1, 0.5)  # Probability of flipping an item\n\n    # Identify items to flip: prioritize items with high marginal benefit and probabilistic selection\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items with probability beta to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if np.random.random() < beta:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional diversification: flip a random subset of items not already considered\n    remaining_indices = np.where((new_solution != base_solution) & (np.random.random(len(weight_lst)) < 0.2))[0]\n    for idx in remaining_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3124241415390969,
            3.9366224706172943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic selection\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n    beta = np.random.uniform(0.1, 0.5)  # Probability of flipping an item\n\n    # Identify items to flip: prioritize items with high marginal benefit and probabilistic selection\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items with probability beta to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if np.random.random() < beta:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional diversification: flip a random subset of items not already considered\n    remaining_indices = np.where((new_solution != base_solution) & (np.random.random(len(weight_lst)) < 0.2))[0]\n    for idx in remaining_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8490727986881825,
            2.191669136285782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then generates a neighbor by flipping a subset of items with high marginal contribution for both objectives, while ensuring feasibility through a guided removal process of low-contribution items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-10)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-10)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n            low_contrib_items = np.argsort(current_contrib)\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.30136133146970057,
            0.6899518370628357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-10)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-10)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n            low_contrib_items = np.argsort(current_contrib)\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted sum of objectives with a dynamic trade-off factor, then applies a hybrid local search that combines item flipping and subset replacement to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution using a dynamic weighted sum\n    weights = np.array([0.6, 0.4])  # Fixed weights for objective trade-off\n    scores = np.array([obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: flip items with high marginal benefit and replace subsets\n    alpha = np.random.uniform(0.4, 0.6)  # Dynamic trade-off factor\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip top 10% of items with highest marginal benefit\n    flip_count = max(1, int(0.1 * len(sorted_indices)))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Replace a subset of items with a random selection\n    subset_size = np.random.randint(1, min(5, len(weight_lst)))\n    available_indices = np.where((weight_lst <= capacity - current_weight) & (new_solution == 0))[0]\n    if len(available_indices) > 0:\n        selected_items = np.random.choice(available_indices, size=min(subset_size, len(available_indices)), replace=False)\n        new_solution[selected_items] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.6533945034925422,
            2.8242506086826324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution using a dynamic weighted sum\n    weights = np.array([0.6, 0.4])  # Fixed weights for objective trade-off\n    scores = np.array([obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: flip items with high marginal benefit and replace subsets\n    alpha = np.random.uniform(0.4, 0.6)  # Dynamic trade-off factor\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip top 10% of items with highest marginal benefit\n    flip_count = max(1, int(0.1 * len(sorted_indices)))\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Replace a subset of items with a random selection\n    subset_size = np.random.randint(1, min(5, len(weight_lst)))\n    available_indices = np.where((weight_lst <= capacity - current_weight) & (new_solution == 0))[0]\n    if len(available_indices) > 0:\n        selected_items = np.random.choice(available_indices, size=min(subset_size, len(available_indices)), replace=False)\n        new_solution[selected_items] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, and incorporates a probabilistic acceptance criterion to explore diverse neighborhoods while maintaining solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Probabilistic flipping based on marginal benefit and temperature\n    temperature = 0.5  # Controls exploration/exploitation trade-off\n    for idx in sorted_indices:\n        if np.random.rand() < np.exp(marginal_benefit[idx] / temperature):\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8057964933175532,
            9.779407352209091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Probabilistic flipping based on marginal benefit and temperature\n    temperature = 0.5  # Controls exploration/exploitation trade-off\n    for idx in sorted_indices:\n        if np.random.rand() < np.exp(marginal_benefit[idx] / temperature):\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic crowding distance metric to identify under-explored regions, then applies a hybrid local search that combines a greedy improvement phase with a probabilistic flip mechanism to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest crowding distance (indicating under-explored region)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_dist[i] = float('inf')\n        else:\n            crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[-1, 0] - objectives[0, 0] + 1e-6) + \\\n                               (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[-1, 1] - objectives[0, 1] + 1e-6)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy improvement followed by probabilistic flip\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Greedy improvement phase\n    for _ in range(2):  # Limit iterations to prevent excessive computation\n        for idx in np.random.permutation(len(weight_lst)):\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity = capacity - current_weight\n            elif new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove item\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    remaining_capacity = capacity - current_weight\n\n    # Probabilistic flip to maintain diversity\n    for idx in np.where(new_solution == 1)[0]:\n        if np.random.rand() < 0.1:  # 10% chance to flip included items\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    for idx in np.where(new_solution == 0)[0]:\n        if np.random.rand() < 0.1 and weight_lst[idx] <= remaining_capacity:  # 10% chance to flip excluded items\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.40392465359174484,
            6.276143312454224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest crowding distance (indicating under-explored region)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_dist[i] = float('inf')\n        else:\n            crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[-1, 0] - objectives[0, 0] + 1e-6) + \\\n                               (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[-1, 1] - objectives[0, 1] + 1e-6)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy improvement followed by probabilistic flip\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Greedy improvement phase\n    for _ in range(2):  # Limit iterations to prevent excessive computation\n        for idx in np.random.permutation(len(weight_lst)):\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                remaining_capacity = capacity - current_weight\n            elif new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove item\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    remaining_capacity = capacity - current_weight\n\n    # Probabilistic flip to maintain diversity\n    for idx in np.where(new_solution == 1)[0]:\n        if np.random.rand() < 0.1:  # 10% chance to flip included items\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    for idx in np.where(new_solution == 0)[0]:\n        if np.random.rand() < 0.1 and weight_lst[idx] <= remaining_capacity:  # 10% chance to flip excluded items\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{A new heuristic selects a solution from the archive using a weighted sum of normalized objectives, then generates neighbors by flipping items based on their marginal contribution to both objectives, while ensuring feasibility through iterative removal of low-contribution items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n\n    # Select solution with highest normalized score\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5304606832547827,
            1.4755763113498688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n\n    # Select solution with highest normalized score\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that combines greedy selection with random perturbations to explore the solution space while maintaining feasibility through dynamic capacity adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high marginal gains in both objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine greedy and random perturbations\n    for _ in range(5):  # Perform multiple perturbations\n        # Greedy selection: prioritize items with high value-to-weight ratio\n        value_to_weight = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(value_to_weight)[::-1]\n\n        # Randomly select a subset of top items to flip\n        flip_candidates = sorted_indices[:max(1, len(sorted_indices) // 3)]\n        np.random.shuffle(flip_candidates)\n\n        for idx in flip_candidates:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4192050662004223,
            4.214563310146332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high marginal gains in both objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine greedy and random perturbations\n    for _ in range(5):  # Perform multiple perturbations\n        # Greedy selection: prioritize items with high value-to-weight ratio\n        value_to_weight = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(value_to_weight)[::-1]\n\n        # Randomly select a subset of top items to flip\n        flip_candidates = sorted_indices[:max(1, len(sorted_indices) // 3)]\n        np.random.shuffle(flip_candidates)\n\n        for idx in flip_candidates:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection mechanism, then applies a hybrid local search strategy that combines item swaps with a probabilistic acceptance criterion to explore the solution space while maintaining feasibility, ensuring both objectives are improved through a balanced exploration of trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity potential\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: item swaps with probabilistic acceptance\n    for _ in range(5):  # Perform multiple swaps\n        # Select two items to swap (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        # Calculate potential improvement\n        swap_in = np.random.choice(excluded_items)\n        swap_out = np.random.choice(included_items)\n\n        new_weight = current_weight - weight_lst[swap_out] + weight_lst[swap_in]\n        if new_weight > capacity:\n            continue\n\n        new_value1 = current_value1 - value1_lst[swap_out] + value1_lst[swap_in]\n        new_value2 = current_value2 - value2_lst[swap_out] + value2_lst[swap_in]\n\n        # Probabilistic acceptance based on improvement\n        if (new_value1 > current_value1 or new_value2 > current_value2) or np.random.rand() < 0.3:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n            current_weight = new_weight\n            current_value1 = new_value1\n            current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.7211649665022075,
            6.518083393573761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity potential\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: item swaps with probabilistic acceptance\n    for _ in range(5):  # Perform multiple swaps\n        # Select two items to swap (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        # Calculate potential improvement\n        swap_in = np.random.choice(excluded_items)\n        swap_out = np.random.choice(included_items)\n\n        new_weight = current_weight - weight_lst[swap_out] + weight_lst[swap_in]\n        if new_weight > capacity:\n            continue\n\n        new_value1 = current_value1 - value1_lst[swap_out] + value1_lst[swap_in]\n        new_value2 = current_value2 - value2_lst[swap_out] + value2_lst[swap_in]\n\n        # Probabilistic acceptance based on improvement\n        if (new_value1 > current_value1 or new_value2 > current_value2) or np.random.rand() < 0.3:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n            current_weight = new_weight\n            current_value1 = new_value1\n            current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined normalized objective values, then applies a local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, prioritizing items with high marginal benefit while ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n    selected_idx = np.argmax([(obj[0]/max_v1 + obj[1]/max_v2) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.4, 0.6)  # Adjusted trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * (value1_lst / (max_v1 + 1e-6)) + (1 - alpha) * (value2_lst / (max_v2 + 1e-6))) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8193748708140839,
            3.108771115541458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n    selected_idx = np.argmax([(obj[0]/max_v1 + obj[1]/max_v2) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.4, 0.6)  # Adjusted trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * (value1_lst / (max_v1 + 1e-6)) + (1 - alpha) * (value2_lst / (max_v2 + 1e-6))) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    obj_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(obj_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic adjustment\n    alpha = np.random.uniform(0.2, 0.8)\n    beta = np.random.uniform(0.3, 0.7)\n\n    # Calculate marginal benefit with dynamic trade-off\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip with probabilistic acceptance\n    for idx in range(len(weight_lst)):\n        if np.random.rand() < beta:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional improvement: flip items with highest marginal benefit if feasible\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4154036720683331,
            3.4218844175338745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    obj_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(obj_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic adjustment\n    alpha = np.random.uniform(0.2, 0.8)\n    beta = np.random.uniform(0.3, 0.7)\n\n    # Calculate marginal benefit with dynamic trade-off\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip with probabilistic acceptance\n    for idx in range(len(weight_lst)):\n        if np.random.rand() < beta:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional improvement: flip items with highest marginal benefit if feasible\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The new heuristic selects a solution from the archive with the highest product of normalized objective values, then applies a local search that flips items based on a dynamic trade-off weighted by their marginal benefit, while ensuring feasibility by prioritizing items with the highest normalized marginal benefit and adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Normalize objectives to avoid scale bias\n    max_value1 = max(obj[0] for _, obj in archive) if any(obj[0] for _, obj in archive) else 1.0\n    max_value2 = max(obj[1] for _, obj in archive) if any(obj[1] for _, obj in archive) else 1.0\n    normalized_archive = [(sol, (obj[0]/max_value1, obj[1]/max_value2)) for sol, obj in archive]\n\n    # Select solution with highest product of normalized objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in normalized_archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives using normalized values\n    alpha = np.random.uniform(0.4, 0.6)  # Adjusted trade-off factor\n\n    # Calculate normalized marginal benefit\n    normalized_value1 = value1_lst / (max_value1 if max_value1 > 0 else 1.0)\n    normalized_value2 = value2_lst / (max_value2 if max_value2 > 0 else 1.0)\n    marginal_benefit = (alpha * normalized_value1 + (1 - alpha) * normalized_value2) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7639101487769004,
            3.4943699538707733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Normalize objectives to avoid scale bias\n    max_value1 = max(obj[0] for _, obj in archive) if any(obj[0] for _, obj in archive) else 1.0\n    max_value2 = max(obj[1] for _, obj in archive) if any(obj[1] for _, obj in archive) else 1.0\n    normalized_archive = [(sol, (obj[0]/max_value1, obj[1]/max_value2)) for sol, obj in archive]\n\n    # Select solution with highest product of normalized objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in normalized_archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives using normalized values\n    alpha = np.random.uniform(0.4, 0.6)  # Adjusted trade-off factor\n\n    # Calculate normalized marginal benefit\n    normalized_value1 = value1_lst / (max_value1 if max_value1 > 0 else 1.0)\n    normalized_value2 = value2_lst / (max_value2 if max_value2 > 0 else 1.0)\n    marginal_benefit = (alpha * normalized_value1 + (1 - alpha) * normalized_value2) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted sum of objectives with adaptive weights, then applies a dynamic flip strategy that prioritizes items with high marginal benefit in both objectives while ensuring feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with adaptive objective weighting\n    weights = np.random.uniform(0.4, 0.6, size=len(archive))\n    weighted_scores = [w * (obj[0] + obj[1]) for (_, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive alpha\n    alpha = np.random.beta(2, 3)  # Biased towards 0.5 to 0.8\n    beta = 1 - alpha\n\n    # Calculate marginal benefit for both objectives\n    benefit1 = value1_lst / (weight_lst + 1e-6)\n    benefit2 = value2_lst / (weight_lst + 1e-6)\n    combined_benefit = alpha * benefit1 + beta * benefit2\n\n    # Sort by combined benefit and apply dynamic flips\n    sorted_indices = np.argsort(combined_benefit)[::-1]\n    flip_prob = np.random.beta(1, 2)  # Higher chance to flip fewer items\n\n    for idx in sorted_indices:\n        if np.random.random() < flip_prob:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4144417311458142,
            4.941013664007187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with adaptive objective weighting\n    weights = np.random.uniform(0.4, 0.6, size=len(archive))\n    weighted_scores = [w * (obj[0] + obj[1]) for (_, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive alpha\n    alpha = np.random.beta(2, 3)  # Biased towards 0.5 to 0.8\n    beta = 1 - alpha\n\n    # Calculate marginal benefit for both objectives\n    benefit1 = value1_lst / (weight_lst + 1e-6)\n    benefit2 = value2_lst / (weight_lst + 1e-6)\n    combined_benefit = alpha * benefit1 + beta * benefit2\n\n    # Sort by combined benefit and apply dynamic flips\n    sorted_indices = np.argsort(combined_benefit)[::-1]\n    flip_prob = np.random.beta(1, 2)  # Higher chance to flip fewer items\n\n    for idx in sorted_indices:\n        if np.random.random() < flip_prob:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, and incorporates a random walk to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Calculate marginal benefit with dynamic trade-off\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n\n    # Sort items by marginal benefit\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip a subset of items to maximize benefit while staying feasible\n    flip_size = min(5, len(sorted_indices))  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(sorted_indices, size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Random walk to escape local optima\n    if np.random.random() < 0.3:  # 30% chance to perform random walk\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            # Randomly select an item to remove\n            remove_idx = np.random.choice(candidate_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n            # Randomly select an item to add (if feasible)\n            add_candidates = np.where((weight_lst <= capacity - current_weight) & (new_solution == 0))[0]\n            if len(add_candidates) > 0:\n                add_idx = np.random.choice(add_candidates)\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.30557543676606524,
            2.502532124519348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Calculate marginal benefit with dynamic trade-off\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n\n    # Sort items by marginal benefit\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip a subset of items to maximize benefit while staying feasible\n    flip_size = min(5, len(sorted_indices))  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(sorted_indices, size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Random walk to escape local optima\n    if np.random.random() < 0.3:  # 30% chance to perform random walk\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            # Randomly select an item to remove\n            remove_idx = np.random.choice(candidate_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n            # Randomly select an item to add (if feasible)\n            add_candidates = np.where((weight_lst <= capacity - current_weight) & (new_solution == 0))[0]\n            if len(add_candidates) > 0:\n                add_idx = np.random.choice(add_candidates)\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, while also incorporating a probabilistic selection mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Probabilistic selection of items to flip\n    flip_prob = np.linspace(0.9, 0.1, len(sorted_indices))  # Higher probability for top items\n    flip_mask = np.random.random(len(sorted_indices)) < flip_prob\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices[flip_mask]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7355794526985108,
            2.6764430701732635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Probabilistic selection of items to flip\n    flip_prob = np.linspace(0.9, 0.1, len(sorted_indices))  # Higher probability for top items\n    flip_mask = np.random.random(len(sorted_indices)) < flip_prob\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices[flip_mask]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a hybrid local search strategy that combines greedy marginal contribution with random exploration to flip items, ensuring feasibility by dynamically adjusting the trade-off between objectives and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid strategy: combine greedy and random exploration\n    # Step 1: Greedily flip items with high marginal contribution\n    marginal_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_contrib)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Step 2: Randomly flip a small number of items to escape local optima\n    num_random_flips = np.random.randint(1, min(4, len(weight_lst)))\n    flip_candidates = np.where(new_solution == 0)[0]\n    if len(flip_candidates) > 0:\n        random_indices = np.random.choice(flip_candidates, size=min(num_random_flips, len(flip_candidates)), replace=False)\n        for idx in random_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7786402163381566,
            3.9349205493927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid strategy: combine greedy and random exploration\n    # Step 1: Greedily flip items with high marginal contribution\n    marginal_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_contrib)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Step 2: Randomly flip a small number of items to escape local optima\n    num_random_flips = np.random.randint(1, min(4, len(weight_lst)))\n    flip_candidates = np.where(new_solution == 0)[0]\n    if len(flip_candidates) > 0:\n        random_indices = np.random.choice(flip_candidates, size=min(num_random_flips, len(flip_candidates)), replace=False)\n        for idx in random_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, while also incorporating adaptive neighborhood exploration to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive neighborhood exploration\n    alpha = np.random.uniform(0.1, 0.9)  # Random trade-off factor\n    beta = np.random.uniform(0.1, 0.5)  # Exploration factor\n\n    # Calculate marginal benefit with adaptive weights\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items with adaptive probability\n    for idx in sorted_indices:\n        if np.random.rand() < beta:  # Control exploration\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional local improvement: flip the smallest item not in the solution\n    if np.random.rand() < 0.3:  # Probability of additional flip\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            smallest_item = excluded_items[np.argmin(weight_lst[excluded_items])]\n            if current_weight + weight_lst[smallest_item] <= capacity:\n                new_solution[smallest_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36522568443127723,
            3.782690644264221
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive neighborhood exploration\n    alpha = np.random.uniform(0.1, 0.9)  # Random trade-off factor\n    beta = np.random.uniform(0.1, 0.5)  # Exploration factor\n\n    # Calculate marginal benefit with adaptive weights\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items with adaptive probability\n    for idx in sorted_indices:\n        if np.random.rand() < beta:  # Control exploration\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional local improvement: flip the smallest item not in the solution\n    if np.random.rand() < 0.3:  # Probability of additional flip\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            smallest_item = excluded_items[np.argmin(weight_lst[excluded_items])]\n            if current_weight + weight_lst[smallest_item] <= capacity:\n                new_solution[smallest_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional local search: flip two items simultaneously to explore more neighbors\n    if len(sorted_indices) >= 2:\n        idx1, idx2 = sorted_indices[0], sorted_indices[1]\n        if new_solution[idx1] == 1 and new_solution[idx2] == 1:\n            if current_weight - weight_lst[idx1] - weight_lst[idx2] <= capacity:\n                new_solution[idx1], new_solution[idx2] = 0, 0\n        elif new_solution[idx1] == 0 and new_solution[idx2] == 0:\n            if current_weight + weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                new_solution[idx1], new_solution[idx2] = 1, 1\n\n    return new_solution\n\n",
        "score": [
            -0.66704799272045,
            3.4293706119060516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional local search: flip two items simultaneously to explore more neighbors\n    if len(sorted_indices) >= 2:\n        idx1, idx2 = sorted_indices[0], sorted_indices[1]\n        if new_solution[idx1] == 1 and new_solution[idx2] == 1:\n            if current_weight - weight_lst[idx1] - weight_lst[idx2] <= capacity:\n                new_solution[idx1], new_solution[idx2] = 0, 0\n        elif new_solution[idx1] == 0 and new_solution[idx2] == 0:\n            if current_weight + weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                new_solution[idx1], new_solution[idx2] = 1, 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel heuristic selects a base solution from the archive using a weighted sum of objectives with random weights, then applies a hybrid local search combining random flips of high-marginal-contribution items and a greedy removal of low-marginal-contribution items to ensure feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(2)\n    weighted_scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Randomly select a subset of high-contribution items to flip\n    high_contrib_items = np.where(combined_contrib > np.percentile(combined_contrib, 75))[0]\n    if len(high_contrib_items) > 0:\n        flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4075430337570062,
            3.122360944747925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.rand(2)\n    weighted_scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Randomly select a subset of high-contribution items to flip\n    high_contrib_items = np.where(combined_contrib > np.percentile(combined_contrib, 75))[0]\n    if len(high_contrib_items) > 0:\n        flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A new algorithm that prioritizes solutions with high marginal contributions and applies a hybrid local search by flipping subsets of items with high combined contribution while intelligently repairing infeasible solutions by removing items with low marginal contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.523834326042452,
            3.8829307854175568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This new algorithm selects a solution from the archive with the highest combined objective values, then applies a dynamic local search strategy that flips items based on a weighted combination of objective values and their marginal benefits, while ensuring feasibility by prioritizing items that fit within the remaining capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n\n    # Calculate marginal benefit for items not in the solution\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and remaining_capacity + weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.715707494516688,
            2.6032920479774475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n\n    # Calculate marginal benefit for items not in the solution\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and remaining_capacity + weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{The new heuristic selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, and additionally considers the impact of item correlations to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with correlation consideration\n    alpha = np.random.uniform(0.3, 0.7)\n    correlation_matrix = np.corrcoef([value1_lst, value2_lst])[0, 1]\n    adjusted_alpha = alpha * (1 + correlation_matrix)\n\n    # Identify items to flip: prioritize items with high marginal benefit and consider item correlations\n    marginal_benefit = (adjusted_alpha * value1_lst + (1 - adjusted_alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7120277026336492,
            4.018315076828003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with correlation consideration\n    alpha = np.random.uniform(0.3, 0.7)\n    correlation_matrix = np.corrcoef([value1_lst, value2_lst])[0, 1]\n    adjusted_alpha = alpha * (1 + correlation_matrix)\n\n    # Identify items to flip: prioritize items with high marginal benefit and consider item correlations\n    marginal_benefit = (adjusted_alpha * value1_lst + (1 - adjusted_alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A new algorithm that prioritizes solutions with balanced marginal contributions across both objectives, flips a subset of high-contribution items, and uses a more sophisticated feasibility repair mechanism by iteratively removing low-contribution items in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest combined contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate combined contribution of items in the current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        # Sort items by contribution and remove lowest ones until feasible\n        sorted_items = np.argsort(current_contrib)\n        for idx in sorted_items:\n            if new_solution[idx] == 1 and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.40534680575841503,
            3.8313637375831604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest combined contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate combined contribution of items in the current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        # Sort items by contribution and remove lowest ones until feasible\n        sorted_items = np.argsort(current_contrib)\n        for idx in sorted_items:\n            if new_solution[idx] == 1 and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic balance between objective values, then applies a novel local search strategy that flips items in clusters based on their combined marginal contribution, while ensuring feasibility through a capacity-aware adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    objective_scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.random.choice(\n        np.argsort(objective_scores)[-min(3, len(archive)):],\n        p=np.random.dirichlet(np.ones(min(3, len(archive))), size=1)[0]\n    )\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Compute combined marginal contribution\n    combined_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Identify clusters of items with high combined contribution\n    sorted_indices = np.argsort(combined_contrib)[::-1]\n    cluster_size = max(1, int(0.2 * len(weight_lst)))  # Dynamic cluster size\n    cluster_indices = sorted_indices[:cluster_size]\n\n    # Flip items in the cluster if they improve the solution\n    for idx in cluster_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    # Ensure feasibility by removing items with lowest marginal contribution if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(current_contrib)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8862595091507568,
            1.7215198576450348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    objective_scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.random.choice(\n        np.argsort(objective_scores)[-min(3, len(archive)):],\n        p=np.random.dirichlet(np.ones(min(3, len(archive))), size=1)[0]\n    )\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Compute combined marginal contribution\n    combined_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Identify clusters of items with high combined contribution\n    sorted_indices = np.argsort(combined_contrib)[::-1]\n    cluster_size = max(1, int(0.2 * len(weight_lst)))  # Dynamic cluster size\n    cluster_indices = sorted_indices[:cluster_size]\n\n    # Flip items in the cluster if they improve the solution\n    for idx in cluster_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    # Ensure feasibility by removing items with lowest marginal contribution if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(current_contrib)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined normalized objective values, then applies a local search strategy that flips items based on a dynamic trade-off between objectives, prioritizing high-marginal-benefit items while ensuring feasibility by dynamically adjusting the trade-off factor and item selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    selected_idx = np.argmax([(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive factor\n    alpha = np.random.uniform(0.4, 0.6)  # Adjusted trade-off factor\n    beta = np.random.uniform(0.2, 0.8)    # Additional random factor\n\n    # Calculate marginal benefit with adaptive weights\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst + beta * (value1_lst * value2_lst)) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7103008031685261,
            2.848592162132263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined normalized objective\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    selected_idx = np.argmax([(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with adaptive factor\n    alpha = np.random.uniform(0.4, 0.6)  # Adjusted trade-off factor\n    beta = np.random.uniform(0.2, 0.8)    # Additional random factor\n\n    # Calculate marginal benefit with adaptive weights\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst + beta * (value1_lst * value2_lst)) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a novel local search strategy that uses a dynamic trade-off between objectives to selectively flip items, prioritizing those with high marginal benefit while ensuring feasibility by adjusting the selection to stay within capacity, and further refines the solution by considering both objective contributions and weight efficiency.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Calculate marginal benefit for each objective\n    marginal_benefit1 = value1_lst / (weight_lst + 1e-6)\n    marginal_benefit2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal benefits with dynamic trade-off\n    combined_benefit = alpha * marginal_benefit1 + (1 - alpha) * marginal_benefit2\n\n    # Identify items to flip: prioritize items with high combined benefit\n    sorted_indices = np.argsort(combined_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Further refine by considering both objectives and weight efficiency\n    for idx in range(len(weight_lst)):\n        if new_solution[idx] == 1:\n            # Check if removing this item improves both objectives\n            if (value1_lst[idx] < 0 or value2_lst[idx] < 0) and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Check if adding this item improves both objectives\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0) and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.658826140589546,
            3.6957965195178986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Calculate marginal benefit for each objective\n    marginal_benefit1 = value1_lst / (weight_lst + 1e-6)\n    marginal_benefit2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal benefits with dynamic trade-off\n    combined_benefit = alpha * marginal_benefit1 + (1 - alpha) * marginal_benefit2\n\n    # Identify items to flip: prioritize items with high combined benefit\n    sorted_indices = np.argsort(combined_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Further refine by considering both objectives and weight efficiency\n    for idx in range(len(weight_lst)):\n        if new_solution[idx] == 1:\n            # Check if removing this item improves both objectives\n            if (value1_lst[idx] < 0 or value2_lst[idx] < 0) and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Check if adding this item improves both objectives\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0) and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that dynamically adjusts the trade-off between objectives by flipping items based on their marginal contribution to both objectives, while ensuring feasibility by prioritizing items that can be added without exceeding capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n\n    # Calculate marginal contribution for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combined marginal contribution with dynamic trade-off\n    combined_contrib = alpha * marginal_contrib1 + (1 - alpha) * marginal_contrib2\n\n    # Sort items by combined marginal contribution\n    sorted_indices = np.argsort(combined_contrib)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            # Randomly decide whether to remove the item to explore different solutions\n            if np.random.rand() < 0.3:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4193693366217695,
            3.104008764028549
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n\n    # Calculate marginal contribution for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combined marginal contribution with dynamic trade-off\n    combined_contrib = alpha * marginal_contrib1 + (1 - alpha) * marginal_contrib2\n\n    # Sort items by combined marginal contribution\n    sorted_indices = np.argsort(combined_contrib)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            # Randomly decide whether to remove the item to explore different solutions\n            if np.random.rand() < 0.3:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This algorithm selects the solution with the highest combined objective values from the archive, then generates a neighbor by flipping items with high marginal contribution in both objectives, while ensuring feasibility by removing low-contribution items if the capacity is exceeded.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(4, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.43970347524610676,
            1.4404135346412659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(4, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest weighted sum of objectives, where weights are dynamically adjusted based on the current archive diversity, then applies a hybrid local search that combines random flips with a greedy selection of items with high marginal benefit for both objectives, ensuring feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate archive diversity and adjust weights\n    obj1_values = np.array([obj[0] for _, obj in archive])\n    obj2_values = np.array([obj[1] for _, obj in archive])\n    diversity = np.std(obj1_values) + np.std(obj2_values)\n    alpha = 0.5 + 0.3 * (diversity / (np.max(obj1_values) + np.max(obj2_values) + 1e-6))\n\n    # Select solution with highest weighted objective\n    weighted_scores = [alpha * obj[0] + (1 - alpha) * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal benefit for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection: random flips with greedy marginal benefit\n    flip_prob = 0.3\n    for idx in range(len(weight_lst)):\n        if np.random.random() < flip_prob:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                if marginal1[idx] > marginal2[idx] and alpha > 0.5:\n                    continue\n                elif marginal2[idx] > marginal1[idx] and alpha <= 0.5:\n                    continue\n                else:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n            else:\n                if marginal1[idx] > marginal2[idx] and alpha > 0.5:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                elif marginal2[idx] > marginal1[idx] and alpha <= 0.5:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4774490672692807,
            5.055647701025009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate archive diversity and adjust weights\n    obj1_values = np.array([obj[0] for _, obj in archive])\n    obj2_values = np.array([obj[1] for _, obj in archive])\n    diversity = np.std(obj1_values) + np.std(obj2_values)\n    alpha = 0.5 + 0.3 * (diversity / (np.max(obj1_values) + np.max(obj2_values) + 1e-6))\n\n    # Select solution with highest weighted objective\n    weighted_scores = [alpha * obj[0] + (1 - alpha) * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal benefit for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection: random flips with greedy marginal benefit\n    flip_prob = 0.3\n    for idx in range(len(weight_lst)):\n        if np.random.random() < flip_prob:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                if marginal1[idx] > marginal2[idx] and alpha > 0.5:\n                    continue\n                elif marginal2[idx] > marginal1[idx] and alpha <= 0.5:\n                    continue\n                else:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n            else:\n                if marginal1[idx] > marginal2[idx] and alpha > 0.5:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                elif marginal2[idx] > marginal1[idx] and alpha <= 0.5:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective balance, then applies a hybrid local search that combines marginal contribution analysis with a probabilistic selection of items to flip, ensuring feasibility by iteratively adjusting the solution while maintaining a balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a dynamic objective balance\n    obj_scores = [obj[0] * 0.6 + obj[1] * 0.4 for _, obj in archive]  # Weighted sum\n    selected_idx = np.argmax(obj_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine marginal contribution and probabilistic selection\n    marginal_benefit1 = value1_lst / (weight_lst + 1e-6)\n    marginal_benefit2 = value2_lst / (weight_lst + 1e-6)\n    combined_benefit = marginal_benefit1 * 0.7 + marginal_benefit2 * 0.3  # Bias towards value1\n\n    # Identify candidate items to flip\n    candidate_items = np.where(combined_benefit > np.percentile(combined_benefit, 70))[0]\n\n    # Randomly select a subset of candidate items to flip\n    num_flips = min(3, len(candidate_items))\n    if num_flips > 0:\n        flip_indices = np.random.choice(candidate_items, size=num_flips, replace=False)\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Ensure feasibility if needed\n    if current_weight > capacity:\n        # Remove items with lowest combined benefit until feasible\n        while current_weight > capacity:\n            current_benefit = combined_benefit * new_solution\n            remove_idx = np.argmax(current_benefit)\n            if new_solution[remove_idx] == 1:\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.41780078205224536,
            2.9465942978858948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a dynamic objective balance\n    obj_scores = [obj[0] * 0.6 + obj[1] * 0.4 for _, obj in archive]  # Weighted sum\n    selected_idx = np.argmax(obj_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine marginal contribution and probabilistic selection\n    marginal_benefit1 = value1_lst / (weight_lst + 1e-6)\n    marginal_benefit2 = value2_lst / (weight_lst + 1e-6)\n    combined_benefit = marginal_benefit1 * 0.7 + marginal_benefit2 * 0.3  # Bias towards value1\n\n    # Identify candidate items to flip\n    candidate_items = np.where(combined_benefit > np.percentile(combined_benefit, 70))[0]\n\n    # Randomly select a subset of candidate items to flip\n    num_flips = min(3, len(candidate_items))\n    if num_flips > 0:\n        flip_indices = np.random.choice(candidate_items, size=num_flips, replace=False)\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Ensure feasibility if needed\n    if current_weight > capacity:\n        # Remove items with lowest combined benefit until feasible\n        while current_weight > capacity:\n            current_benefit = combined_benefit * new_solution\n            remove_idx = np.argmax(current_benefit)\n            if new_solution[remove_idx] == 1:\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high combined marginal contributions, then applies a hybrid local search combining greedy addition of high-contribution items and probabilistic removal of low-contribution items to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify candidate items for addition/removal\n    candidate_items = np.where(base_solution == 0)[0]\n    candidate_contrib = combined_contrib[candidate_items]\n\n    # Greedily add high-contribution items\n    for idx in np.argsort(candidate_contrib)[::-1][:2]:\n        item_idx = candidate_items[idx]\n        if np.sum(weight_lst * new_solution) + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n\n    # Probabilistically remove low-contribution items\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        current_contrib = combined_contrib[current_items]\n        removal_probs = np.exp(-current_contrib / np.max(current_contrib + 1e-8))\n        removal_probs = removal_probs / np.sum(removal_probs)\n        for idx in np.random.choice(current_items, size=min(2, len(current_items)), p=removal_probs, replace=False):\n            new_solution[idx] = 0\n\n    # Ensure feasibility by removing items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        items_sorted = np.argsort(weight_lst)\n        for idx in items_sorted:\n            if new_solution[idx] == 1 and excess > 0:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8110586144254979,
            2.1466698050498962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify candidate items for addition/removal\n    candidate_items = np.where(base_solution == 0)[0]\n    candidate_contrib = combined_contrib[candidate_items]\n\n    # Greedily add high-contribution items\n    for idx in np.argsort(candidate_contrib)[::-1][:2]:\n        item_idx = candidate_items[idx]\n        if np.sum(weight_lst * new_solution) + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n\n    # Probabilistically remove low-contribution items\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        current_contrib = combined_contrib[current_items]\n        removal_probs = np.exp(-current_contrib / np.max(current_contrib + 1e-8))\n        removal_probs = removal_probs / np.sum(removal_probs)\n        for idx in np.random.choice(current_items, size=min(2, len(current_items)), p=removal_probs, replace=False):\n            new_solution[idx] = 0\n\n    # Ensure feasibility by removing items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        items_sorted = np.argsort(weight_lst)\n        for idx in items_sorted:\n            if new_solution[idx] == 1 and excess > 0:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The new algorithm will select a solution from the archive based on its potential to improve both objectives, then generate a neighbor by strategically combining items from high-contribution regions while ensuring feasibility through a novel adaptive removal mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([0.6*obj[0] + 0.4*obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in each objective\n    high_contrib1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//2:]\n    high_contrib2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//2:]\n\n    # Combine high-contribution items from both objectives\n    combined_candidates = np.union1d(high_contrib1, high_contrib2)\n\n    # Randomly select items to consider for flipping\n    flip_candidates = np.random.choice(combined_candidates, size=min(5, len(combined_candidates)), replace=False)\n\n    # Flip selected items with probability based on their marginal contribution\n    for idx in flip_candidates:\n        prob = (marginal_contrib1[idx] + marginal_contrib2[idx]) / (np.max(marginal_contrib1) + np.max(marginal_contrib2))\n        if np.random.rand() < prob:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility using adaptive removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate removal priorities based on contribution and weight\n        contrib = (value1_lst + value2_lst) * new_solution\n        removal_priority = contrib / (weight_lst + 1e-6)\n        removal_order = np.argsort(removal_priority)\n\n        # Remove items in order of lowest priority until feasible\n        for idx in removal_order:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.34714710962480017,
            8.066719233989716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([0.6*obj[0] + 0.4*obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in each objective\n    high_contrib1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//2:]\n    high_contrib2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//2:]\n\n    # Combine high-contribution items from both objectives\n    combined_candidates = np.union1d(high_contrib1, high_contrib2)\n\n    # Randomly select items to consider for flipping\n    flip_candidates = np.random.choice(combined_candidates, size=min(5, len(combined_candidates)), replace=False)\n\n    # Flip selected items with probability based on their marginal contribution\n    for idx in flip_candidates:\n        prob = (marginal_contrib1[idx] + marginal_contrib2[idx]) / (np.max(marginal_contrib1) + np.max(marginal_contrib2))\n        if np.random.rand() < prob:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility using adaptive removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate removal priorities based on contribution and weight\n        contrib = (value1_lst + value2_lst) * new_solution\n        removal_priority = contrib / (weight_lst + 1e-6)\n        removal_order = np.argsort(removal_priority)\n\n        # Remove items in order of lowest priority until feasible\n        for idx in removal_order:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This algorithm selects the best solution from the archive based on a combined objective score, then generates a neighbor by strategically flipping items with high marginal contribution, while ensuring feasibility through a dynamic adjustment process that removes low-contribution items if capacity is exceeded.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items to consider for flipping\n    candidate_items = np.where(base_solution == 0)[0]  # Only consider items not in the current solution\n    if len(candidate_items) == 0:\n        return new_solution  # No items to add\n\n    # Select top 20% of candidate items with highest combined contribution\n    top_contrib = np.argsort(combined_contrib[candidate_items])[-max(1, len(candidate_items) // 5):]\n    selected_items = candidate_items[top_contrib]\n\n    # Randomly select 1-3 items to add\n    num_to_add = np.random.randint(1, min(4, len(selected_items) + 1))\n    add_indices = np.random.choice(selected_items, size=num_to_add, replace=False)\n\n    # Add selected items\n    for idx in add_indices:\n        new_solution[idx] = 1\n\n    # Check feasibility and remove items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_items = np.where(new_solution == 1)[0]\n            if len(current_items) == 0:\n                break  # No items to remove\n            # Calculate current marginal contributions\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            # Find item with lowest contribution\n            remove_idx = np.argmin(current_contrib[current_items])\n            actual_idx = current_items[remove_idx]\n            new_solution[actual_idx] = 0\n            current_weight -= weight_lst[actual_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3672424876756892,
            4.280816048383713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items to consider for flipping\n    candidate_items = np.where(base_solution == 0)[0]  # Only consider items not in the current solution\n    if len(candidate_items) == 0:\n        return new_solution  # No items to add\n\n    # Select top 20% of candidate items with highest combined contribution\n    top_contrib = np.argsort(combined_contrib[candidate_items])[-max(1, len(candidate_items) // 5):]\n    selected_items = candidate_items[top_contrib]\n\n    # Randomly select 1-3 items to add\n    num_to_add = np.random.randint(1, min(4, len(selected_items) + 1))\n    add_indices = np.random.choice(selected_items, size=num_to_add, replace=False)\n\n    # Add selected items\n    for idx in add_indices:\n        new_solution[idx] = 1\n\n    # Check feasibility and remove items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_items = np.where(new_solution == 1)[0]\n            if len(current_items) == 0:\n                break  # No items to remove\n            # Calculate current marginal contributions\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            # Find item with lowest contribution\n            remove_idx = np.argmin(current_contrib[current_items])\n            actual_idx = current_items[remove_idx]\n            new_solution[actual_idx] = 0\n            current_weight -= weight_lst[actual_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined normalized objective values, then applies a dynamic local search that flips items based on a weighted combination of normalized benefits, prioritizing items with high marginal contributions while ensuring feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest normalized combined objective\n    max_norm = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        current_norm = norm_obj[0] + norm_obj[1]\n        if current_norm > max_norm:\n            max_norm = current_norm\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic weighted benefit calculation\n    beta = np.random.uniform(0.4, 0.6)\n    normalized_value1 = value1_lst / np.max(value1_lst)\n    normalized_value2 = value2_lst / np.max(value2_lst)\n    weighted_benefit = beta * normalized_value1 + (1 - beta) * normalized_value2\n    marginal_benefit = weighted_benefit * (1 / (weight_lst + 1e-6))\n\n    # Sort items by marginal benefit\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8350314758002354,
            5.997942000627518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest normalized combined objective\n    max_norm = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        current_norm = norm_obj[0] + norm_obj[1]\n        if current_norm > max_norm:\n            max_norm = current_norm\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic weighted benefit calculation\n    beta = np.random.uniform(0.4, 0.6)\n    normalized_value1 = value1_lst / np.max(value1_lst)\n    normalized_value2 = value2_lst / np.max(value2_lst)\n    weighted_benefit = beta * normalized_value1 + (1 - beta) * normalized_value2\n    marginal_benefit = weighted_benefit * (1 / (weight_lst + 1e-6))\n\n    # Sort items by marginal benefit\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The heuristic selects a solution from the archive with the highest diversity in objective trade-offs, then applies a novel local search strategy that flips items based on a probabilistic model that considers both marginal contributions and solution density in the archive, ensuring feasibility by iteratively adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity in objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic model for item selection\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Solution density factor (how similar to other solutions in archive)\n    solution_matrix = np.array([sol for sol, _ in archive])\n    similarity = np.mean(np.abs(solution_matrix - base_solution), axis=1)\n    density_factor = 1 - similarity\n\n    # Combined probability\n    prob = combined_contrib * (1 + density_factor[selected_idx])\n\n    # Normalize probabilities\n    prob = prob / np.sum(prob)\n\n    # Determine number of items to flip (1-3)\n    num_flips = np.random.randint(1, 4)\n\n    # Select items to flip based on probability\n    flip_indices = np.random.choice(len(weight_lst), size=num_flips, p=prob, replace=False)\n\n    # Apply flips while maintaining feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7906261078332473,
            3.873760551214218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity in objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic model for item selection\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Solution density factor (how similar to other solutions in archive)\n    solution_matrix = np.array([sol for sol, _ in archive])\n    similarity = np.mean(np.abs(solution_matrix - base_solution), axis=1)\n    density_factor = 1 - similarity\n\n    # Combined probability\n    prob = combined_contrib * (1 + density_factor[selected_idx])\n\n    # Normalize probabilities\n    prob = prob / np.sum(prob)\n\n    # Determine number of items to flip (1-3)\n    num_flips = np.random.randint(1, 4)\n\n    # Select items to flip based on probability\n    flip_indices = np.random.choice(len(weight_lst), size=num_flips, p=prob, replace=False)\n\n    # Apply flips while maintaining feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The new heuristic selects a solution from the archive with the highest product of objective values, then applies a dynamic local search that flips items based on a normalized score combining both objectives, while ensuring feasibility through iterative adjustment of the selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest product of objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off using normalized scores\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    alpha = np.random.uniform(0.4, 0.6)\n    combined_score = alpha * norm_value1 + (1 - alpha) * norm_value2\n    sorted_indices = np.argsort(combined_score)[::-1]\n\n    # Flip items to maximize combined score while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.45804972514227715,
            2.194905787706375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest product of objectives\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off using normalized scores\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    alpha = np.random.uniform(0.4, 0.6)\n    combined_score = alpha * norm_value1 + (1 - alpha) * norm_value2\n    sorted_indices = np.argsort(combined_score)[::-1]\n\n    # Flip items to maximize combined score while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic combination of objective values and item importance, then applies a hybrid local search that combines item flipping with a novel trade-off adjustment mechanism to explore high-potential regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective with randomness\n    obj_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = obj_values / np.sum(obj_values)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off adjustment\n    alpha = np.random.uniform(0.1, 0.9)\n    beta = np.random.uniform(0.2, 0.8)\n\n    # Calculate item importance scores\n    importance = (alpha * value1_lst + (1 - alpha) * value2_lst) * (beta * np.log(weight_lst + 1) + (1 - beta))\n\n    # Sort items by importance\n    sorted_indices = np.argsort(importance)[::-1]\n\n    # Hybrid local search: flip top k items with highest importance\n    k = max(1, int(0.3 * len(weight_lst)))  # Flip up to 30% of items\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4800642480574081,
            2.075587719678879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective with randomness\n    obj_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = obj_values / np.sum(obj_values)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off adjustment\n    alpha = np.random.uniform(0.1, 0.9)\n    beta = np.random.uniform(0.2, 0.8)\n\n    # Calculate item importance scores\n    importance = (alpha * value1_lst + (1 - alpha) * value2_lst) * (beta * np.log(weight_lst + 1) + (1 - beta))\n\n    # Sort items by importance\n    sorted_indices = np.argsort(importance)[::-1]\n\n    # Hybrid local search: flip top k items with highest importance\n    k = max(1, int(0.3 * len(weight_lst)))  # Flip up to 30% of items\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score function combining normalized objective values and diversity, then applies a hybrid local search operator that flips items with high marginal contribution while ensuring feasibility through a dynamic capacity adjustment strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    values1 = np.array([obj[0] for _, obj in archive])\n    values2 = np.array([obj[1] for _, obj in archive])\n    max1, min1 = np.max(values1), np.min(values1)\n    max2, min2 = np.max(values2), np.min(values2)\n    norm_values1 = (values1 - min1) / (max1 - min1 + 1e-10)\n    norm_values2 = (values2 - min2) / (max2 - min2 + 1e-10)\n    diversity = np.sqrt((1 - norm_values1) ** 2 + (1 - norm_values2) ** 2)\n    score = norm_values1 + norm_values2 + 0.5 * diversity\n\n    # Select the solution with highest score\n    selected_idx = np.argmax(score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-10)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-10)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these items to flip\n    if len(high_contrib_items) > 0:\n        flip_count = min(2, len(high_contrib_items))\n        flip_indices = np.random.choice(high_contrib_items, size=flip_count, replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with dynamic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by marginal contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(current_contrib)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38163219869715936,
            2.0214823484420776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    values1 = np.array([obj[0] for _, obj in archive])\n    values2 = np.array([obj[1] for _, obj in archive])\n    max1, min1 = np.max(values1), np.min(values1)\n    max2, min2 = np.max(values2), np.min(values2)\n    norm_values1 = (values1 - min1) / (max1 - min1 + 1e-10)\n    norm_values2 = (values2 - min2) / (max2 - min2 + 1e-10)\n    diversity = np.sqrt((1 - norm_values1) ** 2 + (1 - norm_values2) ** 2)\n    score = norm_values1 + norm_values2 + 0.5 * diversity\n\n    # Select the solution with highest score\n    selected_idx = np.argmax(score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-10)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-10)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these items to flip\n    if len(high_contrib_items) > 0:\n        flip_count = min(2, len(high_contrib_items))\n        flip_indices = np.random.choice(high_contrib_items, size=flip_count, replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with dynamic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by marginal contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_indices = np.argsort(current_contrib)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A novel heuristic selects a solution from the archive based on a dynamic objective balance, then applies a hybrid local search that combines item swaps with adaptive flipping, prioritizing items with high marginal contributions while ensuring feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a dynamic objective balance\n    objective_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(objective_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: adaptive item swaps and flips\n    # Step 1: Identify candidate items for swap\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) < 2:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Step 2: Perform adaptive swaps\n    if len(candidate_items) >= 2:\n        swap_indices = np.random.choice(candidate_items, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Step 3: Calculate new weight after swap\n    new_weight = np.sum(weight_lst * new_solution)\n\n    # Step 4: Adaptive flipping to maximize marginal contribution\n    if new_weight <= capacity:\n        # Calculate marginal contributions\n        marginal_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n        # Flip items based on marginal contribution and current state\n        for idx in np.argsort(marginal_contrib)[::-1]:\n            if new_solution[idx] == 0:\n                if new_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    new_weight += weight_lst[idx]\n            else:\n                if new_weight - weight_lst[idx] >= 0 and np.random.rand() < 0.3:  # 30% chance to remove\n                    new_solution[idx] = 0\n                    new_weight -= weight_lst[idx]\n\n    # Ensure feasibility by removing items if necessary\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove item with lowest marginal contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        remove_idx = np.argmin(current_contrib * new_solution)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5556269280163983,
            2.6866843700408936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a dynamic objective balance\n    objective_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(objective_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: adaptive item swaps and flips\n    # Step 1: Identify candidate items for swap\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) < 2:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Step 2: Perform adaptive swaps\n    if len(candidate_items) >= 2:\n        swap_indices = np.random.choice(candidate_items, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Step 3: Calculate new weight after swap\n    new_weight = np.sum(weight_lst * new_solution)\n\n    # Step 4: Adaptive flipping to maximize marginal contribution\n    if new_weight <= capacity:\n        # Calculate marginal contributions\n        marginal_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n        # Flip items based on marginal contribution and current state\n        for idx in np.argsort(marginal_contrib)[::-1]:\n            if new_solution[idx] == 0:\n                if new_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    new_weight += weight_lst[idx]\n            else:\n                if new_weight - weight_lst[idx] >= 0 and np.random.rand() < 0.3:  # 30% chance to remove\n                    new_solution[idx] = 0\n                    new_weight -= weight_lst[idx]\n\n    # Ensure feasibility by removing items if necessary\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove item with lowest marginal contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        remove_idx = np.argmin(current_contrib * new_solution)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel \"objective-adaptive\" local search strategy that dynamically identifies and flips items based on their marginal contribution to either objective, with a probability that depends on the current trade-off between objectives, ensuring feasibility through a capacity-aware adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives (adaptive based on current solution's dominance)\n    total_value1, total_value2 = archive[selected_idx][1]\n    alpha = total_value1 / (total_value1 + total_value2 + 1e-6)  # Normalized trade-off\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Objective-adaptive flipping: prioritize items based on current trade-off\n    for idx in range(len(weight_lst)):\n        # Probabilistic selection based on objective trade-off\n        if np.random.rand() < alpha:\n            # Prefer items that improve objective 1\n            if marginal_contrib1[idx] > marginal_contrib2[idx]:\n                if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n        else:\n            # Prefer items that improve objective 2\n            if marginal_contrib2[idx] > marginal_contrib1[idx]:\n                if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n    # Capacity-aware adjustment: remove low-contribution items if over capacity\n    while current_weight > capacity:\n        # Find items with the lowest combined marginal contribution in the current solution\n        current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n        low_contrib_idx = np.argmax(new_solution * (current_contrib == np.min(current_contrib[new_solution == 1])))\n        new_solution[low_contrib_idx] = 0\n        current_weight -= weight_lst[low_contrib_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.41932004743232054,
            3.6074219942092896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives (adaptive based on current solution's dominance)\n    total_value1, total_value2 = archive[selected_idx][1]\n    alpha = total_value1 / (total_value1 + total_value2 + 1e-6)  # Normalized trade-off\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Objective-adaptive flipping: prioritize items based on current trade-off\n    for idx in range(len(weight_lst)):\n        # Probabilistic selection based on objective trade-off\n        if np.random.rand() < alpha:\n            # Prefer items that improve objective 1\n            if marginal_contrib1[idx] > marginal_contrib2[idx]:\n                if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n        else:\n            # Prefer items that improve objective 2\n            if marginal_contrib2[idx] > marginal_contrib1[idx]:\n                if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n    # Capacity-aware adjustment: remove low-contribution items if over capacity\n    while current_weight > capacity:\n        # Find items with the lowest combined marginal contribution in the current solution\n        current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n        low_contrib_idx = np.argmax(new_solution * (current_contrib == np.min(current_contrib[new_solution == 1])))\n        new_solution[low_contrib_idx] = 0\n        current_weight -= weight_lst[low_contrib_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objective_values = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive), dtype=int)\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objective_values[j][0] >= objective_values[i][0] and objective_values[j][1] >= objective_values[i][1]) and \\\n                   (objective_values[j][0] > objective_values[i][0] or objective_values[j][1] > objective_values[i][1]):\n                    dominated_count += 1\n        ranks[i] = dominated_count\n\n    # Select a solution with the highest rank (least dominated) and high potential for improvement\n    potential_scores = objective_values[:, 0] + objective_values[:, 1] - ranks * 0.1\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search operator: adaptive item swapping with perturbation\n    # Step 1: Identify items with high marginal contribution for each objective\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Step 2: Select a subset of items to swap or perturb based on their contribution\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n\n    # Step 3: Perform adaptive swapping between high-contribution items\n    swap_candidates = np.union1d(high_contrib_items1, high_contrib_items2)\n    if len(swap_candidates) >= 2:\n        swap_indices = np.random.choice(swap_candidates, size=min(2, len(swap_candidates)), replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Step 4: Apply adaptive perturbation to introduce diversity\n    perturbation_prob = 0.3\n    for i in range(len(new_solution)):\n        if np.random.rand() < perturbation_prob:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Remove items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.40761196107332587,
            10.461673855781555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objective_values = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive), dtype=int)\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objective_values[j][0] >= objective_values[i][0] and objective_values[j][1] >= objective_values[i][1]) and \\\n                   (objective_values[j][0] > objective_values[i][0] or objective_values[j][1] > objective_values[i][1]):\n                    dominated_count += 1\n        ranks[i] = dominated_count\n\n    # Select a solution with the highest rank (least dominated) and high potential for improvement\n    potential_scores = objective_values[:, 0] + objective_values[:, 1] - ranks * 0.1\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search operator: adaptive item swapping with perturbation\n    # Step 1: Identify items with high marginal contribution for each objective\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Step 2: Select a subset of items to swap or perturb based on their contribution\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n\n    # Step 3: Perform adaptive swapping between high-contribution items\n    swap_candidates = np.union1d(high_contrib_items1, high_contrib_items2)\n    if len(swap_candidates) >= 2:\n        swap_indices = np.random.choice(swap_candidates, size=min(2, len(swap_candidates)), replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Step 4: Apply adaptive perturbation to introduce diversity\n    perturbation_prob = 0.3\n    for i in range(len(new_solution)):\n        if np.random.rand() < perturbation_prob:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Remove items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, while ensuring feasibility by prioritizing items with high marginal benefit and adaptively adjusting the trade-off factor based on the current solution's performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    current_obj1 = np.sum(value1_lst * new_solution)\n    current_obj2 = np.sum(value2_lst * new_solution)\n\n    # Adaptive trade-off factor based on current solution's performance\n    if current_obj1 > current_obj2:\n        alpha = np.random.uniform(0.6, 0.9)  # Prefer value1 if it's currently dominant\n    else:\n        alpha = np.random.uniform(0.1, 0.4)  # Prefer value2 if it's currently dominant\n\n    # Calculate marginal benefit with adaptive trade-off\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional diversification: randomly flip a small number of low-marginal items\n    if np.random.rand() < 0.2:\n        low_marginal_items = np.argsort(marginal_benefit)[:len(marginal_benefit)//4]\n        flip_candidate = np.random.choice(low_marginal_items)\n        if new_solution[flip_candidate] == 1:\n            if current_weight - weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 0\n        else:\n            if current_weight + weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7533734917621698,
            4.2202785313129425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    current_obj1 = np.sum(value1_lst * new_solution)\n    current_obj2 = np.sum(value2_lst * new_solution)\n\n    # Adaptive trade-off factor based on current solution's performance\n    if current_obj1 > current_obj2:\n        alpha = np.random.uniform(0.6, 0.9)  # Prefer value1 if it's currently dominant\n    else:\n        alpha = np.random.uniform(0.1, 0.4)  # Prefer value2 if it's currently dominant\n\n    # Calculate marginal benefit with adaptive trade-off\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional diversification: randomly flip a small number of low-marginal items\n    if np.random.rand() < 0.2:\n        low_marginal_items = np.argsort(marginal_benefit)[:len(marginal_benefit)//4]\n        flip_candidate = np.random.choice(low_marginal_items)\n        if new_solution[flip_candidate] == 1:\n            if current_weight - weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 0\n        else:\n            if current_weight + weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a solution from the archive based on its combined objective values, then generates a neighbor by intelligently flipping items with high marginal contribution while ensuring feasibility through a dynamic removal strategy that prioritizes items with the lowest current marginal contribution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high combined marginal contribution\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest current marginal contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate current marginal contribution for items in the solution\n        current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n        # Sort items by current contribution (ascending) to remove least valuable\n        sorted_items = np.argsort(current_contrib)\n        # Remove items until feasible\n        for idx in sorted_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.31345985186553293,
            2.8365577459335327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high combined marginal contribution\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest current marginal contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate current marginal contribution for items in the solution\n        current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n        # Sort items by current contribution (ascending) to remove least valuable\n        sorted_items = np.argsort(current_contrib)\n        # Remove items until feasible\n        for idx in sorted_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping items with high value-to-weight ratio in both objectives\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Identify items with high combined value-to-weight ratio\n    high_ratio_items = np.argsort(combined_ratio)[-len(combined_ratio)//4:]\n\n    # Randomly select a subset of these high-ratio items to flip\n    flip_indices = np.random.choice(high_ratio_items, size=min(2, len(high_ratio_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest value-to-weight ratio in the current solution\n        while current_weight > capacity:\n            current_ratio = (value1_lst + value2_lst) / weight_lst * new_solution\n            low_ratio_items = np.argsort(current_ratio)[::-1]\n            for idx in low_ratio_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.42723155927563505,
            3.8235116004943848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping items with high value-to-weight ratio in both objectives\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Identify items with high combined value-to-weight ratio\n    high_ratio_items = np.argsort(combined_ratio)[-len(combined_ratio)//4:]\n\n    # Randomly select a subset of these high-ratio items to flip\n    flip_indices = np.random.choice(high_ratio_items, size=min(2, len(high_ratio_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest value-to-weight ratio in the current solution\n        while current_weight > capacity:\n            current_ratio = (value1_lst + value2_lst) / weight_lst * new_solution\n            low_ratio_items = np.argsort(current_ratio)[::-1]\n            for idx in low_ratio_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objective values, then applies a hybrid local search that combines item flipping with a probabilistic swap of high-marginal-contribution items, ensuring feasibility through iterative removal of low-contribution items if capacity is exceeded.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Identify top 20% of items with highest marginal contribution\n    top_items = np.argsort(combined_marginal)[-max(1, len(combined_marginal) // 5):]\n\n    # Randomly select 1-3 items from top candidates to flip\n    num_flips = np.random.randint(1, min(4, len(top_items) + 1))\n    flip_indices = np.random.choice(top_items, size=num_flips, replace=False)\n\n    # Apply flips with probability based on marginal contribution\n    for idx in flip_indices:\n        flip_prob = min(1.0, 0.5 + 0.5 * combined_marginal[idx] / np.max(combined_marginal))\n        if np.random.rand() < flip_prob:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by their contribution in the current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_items = np.argsort(current_contrib)\n\n        # Remove items until feasible\n        for idx in sorted_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.23951953087607147,
            6.326641172170639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n\n    # Identify top 20% of items with highest marginal contribution\n    top_items = np.argsort(combined_marginal)[-max(1, len(combined_marginal) // 5):]\n\n    # Randomly select 1-3 items from top candidates to flip\n    num_flips = np.random.randint(1, min(4, len(top_items) + 1))\n    flip_indices = np.random.choice(top_items, size=num_flips, replace=False)\n\n    # Apply flips with probability based on marginal contribution\n    for idx in flip_indices:\n        flip_prob = min(1.0, 0.5 + 0.5 * combined_marginal[idx] / np.max(combined_marginal))\n        if np.random.rand() < flip_prob:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by their contribution in the current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        sorted_items = np.argsort(current_contrib)\n\n        # Remove items until feasible\n        for idx in sorted_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution from the archive by considering both the diversity of solutions and their objective values, then applies a novel local search strategy that dynamically adjusts the selection of items based on a weighted combination of their value-to-weight ratios and their current inclusion status, ensuring feasibility by strategically swapping items while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution that balances diversity and objective values\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(sol != archive[0][0])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    # Combine diversity and objective values for selection\n    combined_scores = diversity_scores + np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic weighted combination of value-to-weight ratios and inclusion status\n    beta = np.random.uniform(0.1, 0.9)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    inclusion_factor = new_solution * 0.5 + (1 - new_solution) * 0.3  # Reward inclusion, slightly favor exclusion\n    dynamic_weight = beta * value_to_weight1 + (1 - beta) * value_to_weight2\n    priority_scores = dynamic_weight * inclusion_factor\n\n    # Sort items based on priority scores\n    sorted_indices = np.argsort(priority_scores)[::-1]\n\n    # Apply strategic swaps to improve both objectives\n    for i in range(len(sorted_indices) // 2):\n        idx1, idx2 = sorted_indices[i], sorted_indices[-i-1]\n\n        # Check if swapping these items would improve both objectives\n        if new_solution[idx1] != new_solution[idx2]:\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2] if new_solution[idx1] == 1 else current_weight + weight_lst[idx1] - weight_lst[idx2]\n\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.5048662427885012,
            2.8869463205337524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution that balances diversity and objective values\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(sol != archive[0][0])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    # Combine diversity and objective values for selection\n    combined_scores = diversity_scores + np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic weighted combination of value-to-weight ratios and inclusion status\n    beta = np.random.uniform(0.1, 0.9)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    inclusion_factor = new_solution * 0.5 + (1 - new_solution) * 0.3  # Reward inclusion, slightly favor exclusion\n    dynamic_weight = beta * value_to_weight1 + (1 - beta) * value_to_weight2\n    priority_scores = dynamic_weight * inclusion_factor\n\n    # Sort items based on priority scores\n    sorted_indices = np.argsort(priority_scores)[::-1]\n\n    # Apply strategic swaps to improve both objectives\n    for i in range(len(sorted_indices) // 2):\n        idx1, idx2 = sorted_indices[i], sorted_indices[-i-1]\n\n        # Check if swapping these items would improve both objectives\n        if new_solution[idx1] != new_solution[idx2]:\n            temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2] if new_solution[idx1] == 1 else current_weight + weight_lst[idx1] - weight_lst[idx2]\n\n            if temp_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_scores = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine contributions with different weights\n    combined_contrib = 0.7 * marginal_contrib1 + 0.3 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        current_contrib = (0.7 * value1_lst + 0.3 * value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)[::-1]\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3972057260864563,
            1.6646334826946259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_scores = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine contributions with different weights\n    combined_contrib = 0.7 * marginal_contrib1 + 0.3 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        current_contrib = (0.7 * value1_lst + 0.3 * value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)[::-1]\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, then applies a probabilistic local search that flips items with a bias towards higher marginal benefit, while ensuring feasibility by dynamically adjusting the trade-off weights between objectives and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest weighted sum of objectives\n    weights = [np.random.uniform(0.2, 0.8) for _ in archive]\n    weighted_sums = [w * obj[0] + (1 - w) * obj[1] for (_, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic probability-based flipping\n    for idx in range(len(weight_lst)):\n        if np.random.rand() < 0.5:  # 50% chance to consider flipping\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Probabilistic acceptance based on marginal benefit\n                    benefit = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                    if np.random.rand() < (benefit / (benefit + 1)):  # Higher benefit = higher probability\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4971746467878779,
            3.661920726299286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest weighted sum of objectives\n    weights = [np.random.uniform(0.2, 0.8) for _ in archive]\n    weighted_sums = [w * obj[0] + (1 - w) * obj[1] for (_, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic probability-based flipping\n    for idx in range(len(weight_lst)):\n        if np.random.rand() < 0.5:  # 50% chance to consider flipping\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Probabilistic acceptance based on marginal benefit\n                    benefit = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                    if np.random.rand() < (benefit / (benefit + 1)):  # Higher benefit = higher probability\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The new algorithm selects a solution from the archive using a dynamic selection criterion based on the ratio of objective values, then applies a hybrid local search that combines item flipping with a probabilistic approach to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic selection based on objective ratio\n    obj_ratios = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(obj_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search parameters\n    beta = np.random.uniform(0.2, 0.8)  # Probability threshold\n    gamma = np.random.uniform(0.4, 0.6)  # Trade-off factor\n\n    # Calculate hybrid score for each item\n    hybrid_score = (gamma * value1_lst + (1 - gamma) * value2_lst) * np.random.uniform(0.8, 1.2, size=len(weight_lst))\n    sorted_indices = np.argsort(hybrid_score)[::-1]\n\n    # Flip items based on hybrid score and probability\n    for idx in sorted_indices:\n        if np.random.rand() < beta:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.44782600928838673,
            3.530178189277649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Dynamic selection based on objective ratio\n    obj_ratios = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(obj_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search parameters\n    beta = np.random.uniform(0.2, 0.8)  # Probability threshold\n    gamma = np.random.uniform(0.4, 0.6)  # Trade-off factor\n\n    # Calculate hybrid score for each item\n    hybrid_score = (gamma * value1_lst + (1 - gamma) * value2_lst) * np.random.uniform(0.8, 1.2, size=len(weight_lst))\n    sorted_indices = np.argsort(hybrid_score)[::-1]\n\n    # Flip items based on hybrid score and probability\n    for idx in sorted_indices:\n        if np.random.rand() < beta:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The heuristic selects a solution from the archive with the highest hypervolume contribution (estimated by a fast approximation), then applies a novel \"objective-balanced perturbation\" strategy that flips items based on their normalized marginal contributions to both objectives, while dynamically adjusting the trade-off between objectives and ensuring feasibility through a capacity-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hypervolume contribution (approximated)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolume = np.prod(max_obj - objectives, axis=1)\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Normalized marginal contributions for both objectives\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    norm_weight = weight_lst / (np.max(weight_lst) + 1e-6)\n\n    # Dynamic objective trade-off factor (based on current solution's balance)\n    current_v1 = np.sum(value1_lst * new_solution)\n    current_v2 = np.sum(value2_lst * new_solution)\n    alpha = 0.5 + 0.4 * (current_v2 - current_v1) / (current_v1 + current_v2 + 1e-6)\n\n    # Calculate balanced marginal benefit\n    marginal_benefit = (alpha * norm_value1 + (1 - alpha) * norm_value2) / (norm_weight + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Apply perturbation: flip top-k items with highest marginal benefit\n    k = max(1, len(weight_lst) // 10)\n    flip_indices = sorted_indices[:k]\n\n    # Track current weight and capacity\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Flip items while maintaining feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Capacity-aware repair if needed\n    if current_weight > capacity:\n        # Remove items with lowest balanced marginal contribution\n        for idx in sorted_indices[::-1]:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8555456983988858,
            1.8451183438301086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hypervolume contribution (approximated)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolume = np.prod(max_obj - objectives, axis=1)\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Normalized marginal contributions for both objectives\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    norm_weight = weight_lst / (np.max(weight_lst) + 1e-6)\n\n    # Dynamic objective trade-off factor (based on current solution's balance)\n    current_v1 = np.sum(value1_lst * new_solution)\n    current_v2 = np.sum(value2_lst * new_solution)\n    alpha = 0.5 + 0.4 * (current_v2 - current_v1) / (current_v1 + current_v2 + 1e-6)\n\n    # Calculate balanced marginal benefit\n    marginal_benefit = (alpha * norm_value1 + (1 - alpha) * norm_value2) / (norm_weight + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Apply perturbation: flip top-k items with highest marginal benefit\n    k = max(1, len(weight_lst) // 10)\n    flip_indices = sorted_indices[:k]\n\n    # Track current weight and capacity\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Flip items while maintaining feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Capacity-aware repair if needed\n    if current_weight > capacity:\n        # Remove items with lowest balanced marginal contribution\n        for idx in sorted_indices[::-1]:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a hybrid local search strategy that combines item flipping based on marginal contribution with a dynamic trade-off between objectives, while ensuring feasibility by prioritizing items that maximize the combined benefit while staying within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid strategy: combine marginal contribution and dynamic trade-off\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n    marginal_contrib = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_contrib)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # If removing improves the solution, do it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If adding improves the solution, do it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional refinement: flip items with low marginal contribution if possible\n    low_contrib_items = np.argsort(marginal_contrib)[:len(marginal_contrib)//4]\n    for idx in low_contrib_items:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9020632324071498,
            3.0830954015254974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid strategy: combine marginal contribution and dynamic trade-off\n    alpha = np.random.uniform(0.2, 0.8)  # Random trade-off factor\n    marginal_contrib = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_contrib)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # If removing improves the solution, do it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If adding improves the solution, do it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional refinement: flip items with low marginal contribution if possible\n    low_contrib_items = np.argsort(marginal_contrib)[:len(marginal_contrib)//4]\n    for idx in low_contrib_items:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, while ensuring feasibility by iteratively adjusting the selection to stay within capacity, and additionally incorporates a probabilistic acceptance criterion to balance exploration and exploitation in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic acceptance\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n    beta = np.random.uniform(0.1, 0.3)  # Probabilistic acceptance threshold\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items with probabilistic acceptance to balance exploration and exploitation\n    for idx in sorted_indices:\n        if np.random.random() < beta:  # Probabilistic acceptance\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5928655214610382,
            3.392588436603546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic acceptance\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n    beta = np.random.uniform(0.1, 0.3)  # Probabilistic acceptance threshold\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items with probabilistic acceptance to balance exploration and exploitation\n    for idx in sorted_indices:\n        if np.random.random() < beta:  # Probabilistic acceptance\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, while also incorporating a probabilistic element to explore less obvious item combinations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic selection\n    alpha = np.random.uniform(0.3, 0.7)\n    beta = np.random.uniform(0.1, 0.9)  # Probability threshold for flipping\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items probabilistically to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if np.random.rand() < beta:  # Only flip with probability beta\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional local search: flip a small subset of items based on diversity\n    diversity_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in diversity_indices:\n        if np.random.rand() < 0.3:  # Low probability for diversity\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5399104745743191,
            4.440080285072327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives with probabilistic selection\n    alpha = np.random.uniform(0.3, 0.7)\n    beta = np.random.uniform(0.1, 0.9)  # Probability threshold for flipping\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items probabilistically to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if np.random.rand() < beta:  # Only flip with probability beta\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional local search: flip a small subset of items based on diversity\n    diversity_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in diversity_indices:\n        if np.random.rand() < 0.3:  # Low probability for diversity\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = 0.6 * marginal_contrib1 + 0.4 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in current solution\n        while current_weight > capacity:\n            current_contrib = (value1_lst * 0.6 + value2_lst * 0.4) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.45414986627186954,
            2.1428675055503845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = 0.6 * marginal_contrib1 + 0.4 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in current solution\n        while current_weight > capacity:\n            current_contrib = (value1_lst * 0.6 + value2_lst * 0.4) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high marginal utility, then applies a hybrid local search that combines random flips with a value-driven selection to explore diverse neighbors while maintaining feasibility through adaptive capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high marginal utility\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine random flips with value-driven selection\n    flip_prob = 0.3  # Probability of random flip\n    for i in range(len(weight_lst)):\n        if np.random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:\n            # Value-driven selection\n            if new_solution[i] == 0:\n                if current_weight + weight_lst[i] <= capacity:\n                    if (value1_lst[i] + value2_lst[i]) > 0.5 * (np.mean(value1_lst) + np.mean(value2_lst)):\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3429808151940774,
            8.451411336660385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high marginal utility\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: combine random flips with value-driven selection\n    flip_prob = 0.3  # Probability of random flip\n    for i in range(len(weight_lst)):\n        if np.random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:\n            # Value-driven selection\n            if new_solution[i] == 0:\n                if current_weight + weight_lst[i] <= capacity:\n                    if (value1_lst[i] + value2_lst[i]) > 0.5 * (np.mean(value1_lst) + np.mean(value2_lst)):\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high and low marginal contributions\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n    low_contrib_items = np.argsort(combined_contrib)[:len(combined_contrib)//2]\n\n    # Randomly select a subset of high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing low-contribution items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_in_solution = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_in_solution:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3287452119942559,
            2.2751728892326355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high and low marginal contributions\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n    low_contrib_items = np.argsort(combined_contrib)[:len(combined_contrib)//2]\n\n    # Randomly select a subset of high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing low-contribution items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_in_solution = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_in_solution:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.0006300282116203,
            6.243985891342163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.0006300282116203,
            6.243985891342163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity, while also incorporating a probabilistic element to explore diverse neighborhoods by randomly perturbing the solution with a small probability.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    alpha = np.random.uniform(0.3, 0.7)\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    if np.random.random() < 0.2:\n        flip_indices = np.random.choice(len(weight_lst), size=min(2, len(weight_lst)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            elif new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8722451185961102,
            3.907321035861969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    alpha = np.random.uniform(0.3, 0.7)\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    if np.random.random() < 0.2:\n        flip_indices = np.random.choice(len(weight_lst), size=min(2, len(weight_lst)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            elif new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj1 = [obj[0] / np.max([o[0] for _, o in archive]) for _, obj in archive]\n    normalized_obj2 = [obj[1] / np.max([o[1] for _, o in archive]) for _, obj in archive]\n    scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping items with high marginal contribution in a different objective space\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 * 0.7 + marginal_contrib2 * 0.3  # Emphasize value2 more\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        current_contrib = (value1_lst * 0.3 + value2_lst * 0.7) * new_solution\n        low_contrib_items = np.argsort(current_contrib)[::-1]\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.339153297449726,
            5.0669116377830505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj1 = [obj[0] / np.max([o[0] for _, o in archive]) for _, obj in archive]\n    normalized_obj2 = [obj[1] / np.max([o[1] for _, o in archive]) for _, obj in archive]\n    scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping items with high marginal contribution in a different objective space\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 * 0.7 + marginal_contrib2 * 0.3  # Emphasize value2 more\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        current_contrib = (value1_lst * 0.3 + value2_lst * 0.7) * new_solution\n        low_contrib_items = np.argsort(current_contrib)[::-1]\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a hybrid local search strategy that combines item flipping based on marginal contribution with a dynamic trade-off between objectives, while ensuring feasibility by using a greedy removal of low-contribution items when capacity is exceeded.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    alpha = np.random.uniform(0.2, 0.8)\n\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = alpha * marginal_contrib1 + (1 - alpha) * marginal_contrib2\n\n    sorted_indices = np.argsort(combined_contrib)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    if current_weight > capacity:\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8844649479018167,
            4.180526256561279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * new_solution)\n    alpha = np.random.uniform(0.2, 0.8)\n\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = alpha * marginal_contrib1 + (1 - alpha) * marginal_contrib2\n\n    sorted_indices = np.argsort(combined_contrib)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    if current_weight > capacity:\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective values, then applies a hybrid local search strategy that combines item flipping based on marginal benefits and a dynamic trade-off between objectives, while ensuring feasibility by carefully adjusting the selection of items to stay within capacity, and also incorporates a random walk component to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Random walk component to escape local optima\n    if np.random.random() < 0.2:  # 20% chance to perform random walk\n        candidate_indices = np.where((weight_lst <= capacity - current_weight) | (new_solution == 1))[0]\n        if len(candidate_indices) > 0:\n            random_idx = np.random.choice(candidate_indices)\n            if new_solution[random_idx] == 1:\n                new_solution[random_idx] = 0\n            else:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7410263260109146,
            3.999199330806732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Random walk component to escape local optima\n    if np.random.random() < 0.2:  # 20% chance to perform random walk\n        candidate_indices = np.where((weight_lst <= capacity - current_weight) | (new_solution == 1))[0]\n        if len(candidate_indices) > 0:\n            random_idx = np.random.choice(candidate_indices)\n            if new_solution[random_idx] == 1:\n                new_solution[random_idx] = 0\n            else:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a combination of marginal contribution analysis and adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility through dynamic capacity adjustment and item swapping.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution for either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n\n    # Combine and deduplicate high contribution items\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n\n    # Randomly select items to flip based on their marginal contribution\n    if len(high_contrib_items) > 0:\n        flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # If no high contribution items or flipping didn't help, try swapping items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity or np.random.rand() < 0.3:\n        # Find items in the solution and not in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        not_in_solution = np.where(new_solution == 0)[0]\n\n        # Calculate potential swaps\n        if len(in_solution) > 0 and len(not_in_solution) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = np.random.choice(in_solution)\n            add_idx = np.random.choice(not_in_solution)\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.30524239615280324,
            2.9438979029655457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution for either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n\n    # Combine and deduplicate high contribution items\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n\n    # Randomly select items to flip based on their marginal contribution\n    if len(high_contrib_items) > 0:\n        flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # If no high contribution items or flipping didn't help, try swapping items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity or np.random.rand() < 0.3:\n        # Find items in the solution and not in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        not_in_solution = np.where(new_solution == 0)[0]\n\n        # Calculate potential swaps\n        if len(in_solution) > 0 and len(not_in_solution) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = np.random.choice(in_solution)\n            add_idx = np.random.choice(not_in_solution)\n\n            # Check if swap is feasible\n            if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8152339959322121,
            6.442092210054398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel heuristic function that selects a solution with high potential for improvement by combining marginal contribution analysis with adaptive subset flipping, ensuring feasibility through an intelligent item removal strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0]/np.max(value1_lst), obj[1]/np.max(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions with adaptive weights\n    alpha = 0.7  # Higher weight for value1\n    beta = 0.3   # Lower weight for value2\n    marginal_contrib = (alpha * value1_lst + beta * value2_lst) / weight_lst\n\n    # Identify items with high marginal contribution\n    high_contrib_items = np.argsort(marginal_contrib)[-len(marginal_contrib)//2:]\n\n    # Flip a subset of high-contribution items with probability based on their contribution\n    probs = marginal_contrib[high_contrib_items] / np.sum(marginal_contrib[high_contrib_items])\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False, p=probs)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest ratio of contribution to weight\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        contrib_ratio = (value1_lst + value2_lst) / weight_lst\n        while current_weight > capacity:\n            # Find the item with lowest contribution-to-weight ratio in current solution\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) == 0:\n                break\n            worst_item = candidate_items[np.argmin(contrib_ratio[candidate_items])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.3575087070558721,
            3.2586036920547485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0]/np.max(value1_lst), obj[1]/np.max(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([obj[0] + obj[1] for obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions with adaptive weights\n    alpha = 0.7  # Higher weight for value1\n    beta = 0.3   # Lower weight for value2\n    marginal_contrib = (alpha * value1_lst + beta * value2_lst) / weight_lst\n\n    # Identify items with high marginal contribution\n    high_contrib_items = np.argsort(marginal_contrib)[-len(marginal_contrib)//2:]\n\n    # Flip a subset of high-contribution items with probability based on their contribution\n    probs = marginal_contrib[high_contrib_items] / np.sum(marginal_contrib[high_contrib_items])\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False, p=probs)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest ratio of contribution to weight\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        contrib_ratio = (value1_lst + value2_lst) / weight_lst\n        while current_weight > capacity:\n            # Find the item with lowest contribution-to-weight ratio in current solution\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) == 0:\n                break\n            worst_item = candidate_items[np.argmin(contrib_ratio[candidate_items])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance potential\" score that considers both objective values and their relative improvements, then generates a neighbor by strategically flipping items with high \"value-to-weight dominance\" ratios while maintaining feasibility through a dynamic phase adjustment process that prioritizes items with high cross-objective improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance potential\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    dominance_scores = objectives / (max_values + 1e-6)\n    combined_scores = np.prod(dominance_scores, axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight dominance ratios\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    combined_dominance = v1_dominance * v2_dominance\n\n    # Identify items to flip based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7627021007011128,
            3.3009359538555145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance potential\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    dominance_scores = objectives / (max_values + 1e-6)\n    combined_scores = np.prod(dominance_scores, axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight dominance ratios\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    combined_dominance = v1_dominance * v2_dominance\n\n    # Identify items to flip based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance score\" that combines both objective values with a dynamic weight factor, then generates a neighbor by applying a \"diversity-aware flip\" strategy that prioritizes items with high cross-objective synergy while maintaining feasibility through a capacity-adaptive adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective dominance scores with dynamic weight factor\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n    weight_factor = max_v1 / (max_v2 + 1e-6) if max_v2 > 0 else 1.0\n    scores = np.array([(obj[0] * weight_factor + obj[1]) for _, obj in archive])\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate diversity-aware flip scores\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    # For included items: prioritize those that reduce both objectives when removed\n    if len(in_items) > 0:\n        in_scores = (value1_lst[in_items] + value2_lst[in_items]) / (weight_lst[in_items] + 1e-6)\n        in_flip = np.argsort(in_scores)\n        in_flip = in_items[in_flip[:max(1, len(in_items)//3)]]\n\n    # For excluded items: prioritize those that improve both objectives when added\n    if len(out_items) > 0:\n        out_scores = (value1_lst[out_items] + value2_lst[out_items]) / (weight_lst[out_items] + 1e-6)\n        out_flip = np.argsort(out_scores)[::-1]\n        out_flip = out_items[out_flip[:max(1, len(out_items)//3)]]\n\n    # Combine flip candidates\n    flip_candidates = np.concatenate([in_flip, out_flip]) if len(in_flip) > 0 and len(out_flip) > 0 else in_flip if len(in_flip) > 0 else out_flip\n\n    # Apply capacity-adaptive flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:  # Try to remove\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:  # Try to add\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n        # Early termination if capacity is nearly full\n        if current_weight > 0.9 * capacity:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8771799855104028,
            2.495704412460327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective dominance scores with dynamic weight factor\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n    weight_factor = max_v1 / (max_v2 + 1e-6) if max_v2 > 0 else 1.0\n    scores = np.array([(obj[0] * weight_factor + obj[1]) for _, obj in archive])\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate diversity-aware flip scores\n    in_items = np.where(base_solution == 1)[0]\n    out_items = np.where(base_solution == 0)[0]\n\n    # For included items: prioritize those that reduce both objectives when removed\n    if len(in_items) > 0:\n        in_scores = (value1_lst[in_items] + value2_lst[in_items]) / (weight_lst[in_items] + 1e-6)\n        in_flip = np.argsort(in_scores)\n        in_flip = in_items[in_flip[:max(1, len(in_items)//3)]]\n\n    # For excluded items: prioritize those that improve both objectives when added\n    if len(out_items) > 0:\n        out_scores = (value1_lst[out_items] + value2_lst[out_items]) / (weight_lst[out_items] + 1e-6)\n        out_flip = np.argsort(out_scores)[::-1]\n        out_flip = out_items[out_flip[:max(1, len(out_items)//3)]]\n\n    # Combine flip candidates\n    flip_candidates = np.concatenate([in_flip, out_flip]) if len(in_flip) > 0 and len(out_flip) > 0 else in_flip if len(in_flip) > 0 else out_flip\n\n    # Apply capacity-adaptive flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:  # Try to remove\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:  # Try to add\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n        # Early termination if capacity is nearly full\n        if current_weight > 0.9 * capacity:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then generates a neighbor by flipping items with high marginal contribution in both objectives, while ensuring feasibility through a dynamic removal process that prioritizes items with the lowest current contribution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_sum = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_sum)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest current contribution until feasible\n        while current_weight > capacity:\n            # Calculate current contribution of each item in the solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            # Find items with the lowest current contribution in the solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4855312477402748,
            3.560290962457657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_sum = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(weighted_sum)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest current contribution until feasible\n        while current_weight > capacity:\n            # Calculate current contribution of each item in the solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            # Find items with the lowest current contribution in the solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This algorithm selects a solution from the archive by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight balance\" heuristic, ensuring feasibility through a probabilistic acceptance process that prioritizes items with high cross-objective synergy while maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight balance for both objectives\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    balance_ratio = v1_balance / (v2_balance + 1e-6)\n\n    # Identify items to flip based on balance ratio\n    flip_candidates = np.argsort(balance_ratio)[::-1]\n\n    # Probabilistic flipping to maintain feasibility and diversity\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_prob = 0.3  # Initial flip probability\n\n    for idx in flip_candidates:\n        if np.random.rand() < flip_prob:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                flip_prob *= 0.9  # Decrease probability after successful flip\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                flip_prob *= 1.1  # Increase probability after removal\n                flip_prob = min(flip_prob, 0.9)  # Cap probability\n\n    return new_solution\n\n",
        "score": [
            -0.36470435392515455,
            6.354772388935089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight balance for both objectives\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    balance_ratio = v1_balance / (v2_balance + 1e-6)\n\n    # Identify items to flip based on balance ratio\n    flip_candidates = np.argsort(balance_ratio)[::-1]\n\n    # Probabilistic flipping to maintain feasibility and diversity\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_prob = 0.3  # Initial flip probability\n\n    for idx in flip_candidates:\n        if np.random.rand() < flip_prob:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                flip_prob *= 0.9  # Decrease probability after successful flip\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                flip_prob *= 1.1  # Increase probability after removal\n                flip_prob = min(flip_prob, 0.9)  # Cap probability\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{The new algorithm selects a solution from the archive and generates a neighbor by strategically flipping items based on their marginal contribution to both objectives, while dynamically adjusting the selection to balance the trade-off between objectives and ensuring feasibility through a hybrid of greedy and probabilistic removal strategies.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Combine contributions with a dynamic weight based on current solution's trade-off\n    current_obj = archive[selected_idx][1]\n    trade_off = current_obj[0] / (current_obj[0] + current_obj[1] + 1e-8)\n    combined_contrib = trade_off * marginal_contrib1 + (1 - trade_off) * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Probabilistically select items to flip based on their contribution\n    probs = combined_contrib[high_contrib_items] / combined_contrib[high_contrib_items].sum()\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False, p=probs)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with a hybrid removal strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # First, remove items with lowest marginal contribution in the current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n        # If still infeasible, use a greedy removal strategy\n        if current_weight > capacity:\n            remaining_weight = current_weight - capacity\n            sorted_items = np.argsort(weight_lst)\n            for idx in sorted_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    remaining_weight -= weight_lst[idx]\n                    if remaining_weight <= 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.3024398299243578,
            3.8286193907260895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Combine contributions with a dynamic weight based on current solution's trade-off\n    current_obj = archive[selected_idx][1]\n    trade_off = current_obj[0] / (current_obj[0] + current_obj[1] + 1e-8)\n    combined_contrib = trade_off * marginal_contrib1 + (1 - trade_off) * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Probabilistically select items to flip based on their contribution\n    probs = combined_contrib[high_contrib_items] / combined_contrib[high_contrib_items].sum()\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False, p=probs)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with a hybrid removal strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # First, remove items with lowest marginal contribution in the current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n        # If still infeasible, use a greedy removal strategy\n        if current_weight > capacity:\n            remaining_weight = current_weight - capacity\n            sorted_items = np.argsort(weight_lst)\n            for idx in sorted_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    remaining_weight -= weight_lst[idx]\n                    if remaining_weight <= 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This algorithm selects a solution from the archive by considering both objectives, then applies a hybrid local search strategy that combines item flipping with a probabilistic approach to balance exploration and exploitation, while ensuring feasibility through a greedy removal process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Probabilistically select items to flip based on marginal contributions\n    probs = (marginal1 + marginal2) / (np.sum(marginal1) + np.sum(marginal2))\n    flip_indices = np.random.choice(len(weight_lst), size=min(5, len(weight_lst)), p=probs, replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        while current_weight > capacity:\n            contrib = (value1_lst + value2_lst) * new_solution\n            min_contrib_idx = np.argmin(contrib[new_solution == 1])\n            new_solution[min_contrib_idx] = 0\n            current_weight -= weight_lst[min_contrib_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.43676941215870013,
            4.28691953420639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Probabilistically select items to flip based on marginal contributions\n    probs = (marginal1 + marginal2) / (np.sum(marginal1) + np.sum(marginal2))\n    flip_indices = np.random.choice(len(weight_lst), size=min(5, len(weight_lst)), p=probs, replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        while current_weight > capacity:\n            contrib = (value1_lst + value2_lst) * new_solution\n            min_contrib_idx = np.argmin(contrib[new_solution == 1])\n            new_solution[min_contrib_idx] = 0\n            current_weight -= weight_lst[min_contrib_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potentials = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight == 0:\n            potentials.append(0)\n            continue\n        # Calculate normalized marginal contributions for selected items\n        selected_items = np.where(sol == 1)[0]\n        if len(selected_items) == 0:\n            potentials.append(0)\n            continue\n        marginal_contrib1 = value1_lst[selected_items] / weight_lst[selected_items]\n        marginal_contrib2 = value2_lst[selected_items] / weight_lst[selected_items]\n        normalized_contrib = np.sum(marginal_contrib1 + marginal_contrib2) / len(selected_items)\n        potentials.append(normalized_contrib)\n\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy selection of items to add and random perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Greedily add items with highest combined marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Sort items by descending combined marginal contribution\n    sorted_items = np.argsort(combined_contrib)[::-1]\n\n    # Add items until no more can fit\n    for idx in sorted_items:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Randomly perturb the solution by flipping 1-3 items\n    flip_indices = np.random.choice(np.where(new_solution == 1)[0], size=min(3, len(np.where(new_solution == 1)[0])), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 0\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7689565519452364,
            8.79858312010765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potentials = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight == 0:\n            potentials.append(0)\n            continue\n        # Calculate normalized marginal contributions for selected items\n        selected_items = np.where(sol == 1)[0]\n        if len(selected_items) == 0:\n            potentials.append(0)\n            continue\n        marginal_contrib1 = value1_lst[selected_items] / weight_lst[selected_items]\n        marginal_contrib2 = value2_lst[selected_items] / weight_lst[selected_items]\n        normalized_contrib = np.sum(marginal_contrib1 + marginal_contrib2) / len(selected_items)\n        potentials.append(normalized_contrib)\n\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy selection of items to add and random perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Greedily add items with highest combined marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Sort items by descending combined marginal contribution\n    sorted_items = np.argsort(combined_contrib)[::-1]\n\n    # Add items until no more can fit\n    for idx in sorted_items:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Randomly perturb the solution by flipping 1-3 items\n    flip_indices = np.random.choice(np.where(new_solution == 1)[0], size=min(3, len(np.where(new_solution == 1)[0])), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 0\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{A new algorithm that selects a solution from the archive by prioritizing those with balanced objective contributions, then applies a hybrid local search combining greedy marginal contribution updates with a probabilistic item swap to explore high-potential regions while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    deviations = np.abs(objectives - mean_obj)\n    balance_scores = np.sum(deviations, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy updates + probabilistic swaps\n    # Step 1: Greedy marginal contribution updates\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal contributions for each objective\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Identify high-marginal items not in solution\n    for i in np.where(new_solution == 0)[0]:\n        if weight_lst[i] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add high-marginal item\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    # Step 2: Probabilistic item swaps\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        # Select a random item to potentially replace\n        swap_idx = np.random.choice(current_items)\n        # Find items not in solution with weight <= current item's weight\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= weight_lst[swap_idx]))[0]\n        if len(candidate_items) > 0:\n            # Select a candidate with probability proportional to marginal contribution\n            probs = (marginal1[candidate_items] + marginal2[candidate_items]) / np.sum(marginal1[candidate_items] + marginal2[candidate_items])\n            chosen_item = np.random.choice(candidate_items, p=probs)\n            new_solution[swap_idx] = 0\n            new_solution[chosen_item] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        while current_weight > capacity:\n            current_items = np.where(new_solution == 1)[0]\n            if len(current_items) == 0:\n                break\n            contrib = (value1_lst + value2_lst) * new_solution\n            remove_idx = np.argmin(contrib[current_items])\n            new_solution[current_items[remove_idx]] = 0\n            current_weight -= weight_lst[current_items[remove_idx]]\n\n    return new_solution\n\n",
        "score": [
            -0.8050992572936355,
            4.293363451957703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    deviations = np.abs(objectives - mean_obj)\n    balance_scores = np.sum(deviations, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: greedy updates + probabilistic swaps\n    # Step 1: Greedy marginal contribution updates\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal contributions for each objective\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Identify high-marginal items not in solution\n    for i in np.where(new_solution == 0)[0]:\n        if weight_lst[i] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add high-marginal item\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    # Step 2: Probabilistic item swaps\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        # Select a random item to potentially replace\n        swap_idx = np.random.choice(current_items)\n        # Find items not in solution with weight <= current item's weight\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= weight_lst[swap_idx]))[0]\n        if len(candidate_items) > 0:\n            # Select a candidate with probability proportional to marginal contribution\n            probs = (marginal1[candidate_items] + marginal2[candidate_items]) / np.sum(marginal1[candidate_items] + marginal2[candidate_items])\n            chosen_item = np.random.choice(candidate_items, p=probs)\n            new_solution[swap_idx] = 0\n            new_solution[chosen_item] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        while current_weight > capacity:\n            current_items = np.where(new_solution == 1)[0]\n            if len(current_items) == 0:\n                break\n            contrib = (value1_lst + value2_lst) * new_solution\n            remove_idx = np.argmin(contrib[current_items])\n            new_solution[current_items[remove_idx]] = 0\n            current_weight -= weight_lst[current_items[remove_idx]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted sum of objectives, then generates a neighbor by flipping items with high marginal contribution in both objectives, ensuring feasibility through a greedy removal of low-marginal items if capacity is exceeded.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Combine contributions with different weights (0.6 for value1, 0.4 for value2)\n    combined_contrib = 0.6 * marginal_contrib1 + 0.4 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip (up to 5 items)\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        while current_weight > capacity:\n            current_contrib = (0.6 * value1_lst + 0.4 * value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3578744110492034,
            3.0834133327007294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Combine contributions with different weights (0.6 for value1, 0.4 for value2)\n    combined_contrib = 0.6 * marginal_contrib1 + 0.4 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip (up to 5 items)\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        while current_weight > capacity:\n            current_contrib = (0.6 * value1_lst + 0.4 * value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high combined objective values and then generates a neighbor by strategically flipping items based on a novel \"objective-aware marginal contribution\" heuristic, ensuring feasibility through a dynamic adjustment process that balances item additions and removals while maintaining cross-objective trade-off awareness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective-aware marginal contributions\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate normalized marginal contributions\n    v1_marginal = value1_lst / (weight_lst + 1e-6)\n    v2_marginal = value2_lst / (weight_lst + 1e-6)\n\n    # Calculate combined marginal contribution with trade-off awareness\n    if np.random.rand() > 0.5:  # Focus on first objective\n        combined_marginal = v1_marginal + 0.3 * v2_marginal\n    else:  # Focus on second objective\n        combined_marginal = v2_marginal + 0.3 * v1_marginal\n\n    # Identify items to flip based on combined marginal contribution\n    flip_candidates = np.argsort(combined_marginal)[::-1]\n\n    # Dynamic adjustment process\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 60% utilized\n        if remaining_capacity < 0.4 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9251712803429439,
            2.521193265914917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective-aware marginal contributions\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate normalized marginal contributions\n    v1_marginal = value1_lst / (weight_lst + 1e-6)\n    v2_marginal = value2_lst / (weight_lst + 1e-6)\n\n    # Calculate combined marginal contribution with trade-off awareness\n    if np.random.rand() > 0.5:  # Focus on first objective\n        combined_marginal = v1_marginal + 0.3 * v2_marginal\n    else:  # Focus on second objective\n        combined_marginal = v2_marginal + 0.3 * v1_marginal\n\n    # Identify items to flip based on combined marginal contribution\n    flip_candidates = np.argsort(combined_marginal)[::-1]\n\n    # Dynamic adjustment process\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 60% utilized\n        if remaining_capacity < 0.4 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values and their variance, then generates a neighbor by strategically flipping items with high cross-objective utility scores, ensuring feasibility through a dynamic adjustment process that balances both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest weighted objective score considering variance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    variance = np.var(normalized_obj, axis=0)\n    scores = np.sum(normalized_obj * (1 + variance), axis=1) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective utility scores\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    w_norm = weight_lst / (np.max(weight_lst) + 1e-6)\n    utility = (v1_norm + v2_norm) / (1 + w_norm)\n\n    # Identify items to flip based on utility and current solution\n    flip_candidates = np.argsort(utility)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            if np.random.rand() > 0.7:  # Higher chance to remove less useful items\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4763917772442249,
            8.256755411624908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest weighted objective score considering variance\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    variance = np.var(normalized_obj, axis=0)\n    scores = np.sum(normalized_obj * (1 + variance), axis=1) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective utility scores\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    w_norm = weight_lst / (np.max(weight_lst) + 1e-6)\n    utility = (v1_norm + v2_norm) / (1 + w_norm)\n\n    # Identify items to flip based on utility and current solution\n    flip_candidates = np.argsort(utility)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            if np.random.rand() > 0.7:  # Higher chance to remove less useful items\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective diversity\" metric, then generates a neighbor by applying a hybrid local search that combines item swapping with a \"value dominance\" heuristic, ensuring feasibility through a dynamic capacity adjustment process that prioritizes items with high cross-objective balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    diversity_score = diversity[0] * diversity[1]  # Product of diversity in both objectives\n    selected_idx = np.argmax(diversity_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value dominance scores\n    dominance1 = value1_lst / (value2_lst + 1e-6)\n    dominance2 = value2_lst / (value1_lst + 1e-6)\n    combined_dominance = (dominance1 + dominance2) / 2\n\n    # Hybrid local search: swap items with high dominance and low weight\n    swap_candidates = np.argsort(combined_dominance)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    for idx in swap_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Try to add item\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Try to remove item if it's not critical\n            if np.random.rand() < 0.3:  # 30% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Dynamic capacity adjustment\n    if current_weight > capacity:\n        # Remove items with lowest value dominance until feasible\n        while current_weight > capacity:\n            current_dominance = combined_dominance * new_solution\n            low_dominance_items = np.argsort(current_dominance)[::-1]\n            for idx in low_dominance_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3970210981862742,
            5.358003079891205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    diversity_score = diversity[0] * diversity[1]  # Product of diversity in both objectives\n    selected_idx = np.argmax(diversity_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value dominance scores\n    dominance1 = value1_lst / (value2_lst + 1e-6)\n    dominance2 = value2_lst / (value1_lst + 1e-6)\n    combined_dominance = (dominance1 + dominance2) / 2\n\n    # Hybrid local search: swap items with high dominance and low weight\n    swap_candidates = np.argsort(combined_dominance)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    for idx in swap_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Try to add item\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Try to remove item if it's not critical\n            if np.random.rand() < 0.3:  # 30% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Dynamic capacity adjustment\n    if current_weight > capacity:\n        # Remove items with lowest value dominance until feasible\n        while current_weight > capacity:\n            current_dominance = combined_dominance * new_solution\n            low_dominance_items = np.argsort(current_dominance)[::-1]\n            for idx in low_dominance_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects a solution from the archive using a novel \"objective divergence\" metric to identify under-explored regions of the Pareto front, then generates neighbors by strategically flipping items based on a \"value synergy\" heuristic that maximizes cross-objective improvement while maintaining feasibility through a dynamic capacity threshold adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective divergence for each solution in archive\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    divergence = np.abs(obj1_norm - obj2_norm)\n\n    # Select solution with highest divergence (under-explored region)\n    selected_idx = np.argmax(divergence)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value synergy between objectives\n    value_synergy = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    synergy_rank = np.argsort(value_synergy)[::-1]\n\n    # Dynamic capacity threshold (70% of capacity)\n    dynamic_threshold = 0.7 * capacity\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Flip items based on value synergy, maintaining dynamic threshold\n    for idx in synergy_rank:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= dynamic_threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= dynamic_threshold * 0.8:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest value synergy until feasible\n        while current_weight > capacity:\n            for idx in synergy_rank[::-1]:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8592584567589652,
            4.150404363870621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective divergence for each solution in archive\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    divergence = np.abs(obj1_norm - obj2_norm)\n\n    # Select solution with highest divergence (under-explored region)\n    selected_idx = np.argmax(divergence)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value synergy between objectives\n    value_synergy = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    synergy_rank = np.argsort(value_synergy)[::-1]\n\n    # Dynamic capacity threshold (70% of capacity)\n    dynamic_threshold = 0.7 * capacity\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Flip items based on value synergy, maintaining dynamic threshold\n    for idx in synergy_rank:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= dynamic_threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= dynamic_threshold * 0.8:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest value synergy until feasible\n        while current_weight > capacity:\n            for idx in synergy_rank[::-1]:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives * crowding_distances, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items to flip based on their potential to improve both objectives\n    flip_candidates = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            flip_candidates.append((i, marginal_contrib1[i] + marginal_contrib2[i]))\n        else:\n            flip_candidates.append((i, -(marginal_contrib1[i] + marginal_contrib2[i])))\n\n    # Sort candidates by their potential impact on both objectives\n    flip_candidates.sort(key=lambda x: abs(x[1]), reverse=True)\n\n    # Flip top candidates while ensuring feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx, _ in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Dynamic adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with the smallest contribution to both objectives\n        while excess > 0:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            worst_item = np.argmin(current_contrib)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                excess -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8336630925430175,
            4.026249468326569
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives * crowding_distances, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items to flip based on their potential to improve both objectives\n    flip_candidates = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            flip_candidates.append((i, marginal_contrib1[i] + marginal_contrib2[i]))\n        else:\n            flip_candidates.append((i, -(marginal_contrib1[i] + marginal_contrib2[i])))\n\n    # Sort candidates by their potential impact on both objectives\n    flip_candidates.sort(key=lambda x: abs(x[1]), reverse=True)\n\n    # Flip top candidates while ensuring feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx, _ in flip_candidates[:min(5, len(flip_candidates))]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Dynamic adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with the smallest contribution to both objectives\n        while excess > 0:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            worst_item = np.argmin(current_contrib)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                excess -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This algorithm selects a solution from the archive by analyzing the trade-off between objectives, then generates a neighbor by strategically flipping items based on their potential to improve both objectives while considering their weight-normalized contributions, using a novel two-phase selection process that prioritizes items with high cross-objective value-weight synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective\n    objectives = np.array([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight normalized scores for both objectives\n    v1_score = value1_lst / (weight_lst + 1e-6)\n    v2_score = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to flip based on their potential to improve both objectives\n    candidate_items = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0:\n            candidate_items.append((i, v1_score[i] + v2_score[i]))\n        elif new_solution[i] == 1:\n            candidate_items.append((i, -(v1_score[i] + v2_score[i])))\n\n    # Sort candidates by their potential impact (adding high, removing low)\n    candidate_items.sort(key=lambda x: -x[1])\n\n    # Two-phase selection: first try to add promising items, then remove weak ones\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx, _ in candidate_items:\n        if phase == 0:\n            # Try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            # Try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7955758757785277,
            6.717398464679718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective\n    objectives = np.array([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight normalized scores for both objectives\n    v1_score = value1_lst / (weight_lst + 1e-6)\n    v2_score = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to flip based on their potential to improve both objectives\n    candidate_items = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0:\n            candidate_items.append((i, v1_score[i] + v2_score[i]))\n        elif new_solution[i] == 1:\n            candidate_items.append((i, -(v1_score[i] + v2_score[i])))\n\n    # Sort candidates by their potential impact (adding high, removing low)\n    candidate_items.sort(key=lambda x: -x[1])\n\n    # Two-phase selection: first try to add promising items, then remove weak ones\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx, _ in candidate_items:\n        if phase == 0:\n            # Try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            # Try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement through a novel \"objective synergy-aware\" heuristic, then generates a neighbor by strategically flipping items based on their combined value-weight ratios, while maintaining feasibility through an adaptive capacity-aware flipping strategy that balances item additions and removals based on their cross-objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and objective synergy\n    if abs_correlation > 0.5:  # Strong correlation, prioritize items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Adaptive flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_count = 0\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                flip_count += 1\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                flip_count += 1\n\n        # Switch phase when capacity is 70% full or after 5 flips\n        if (current_weight > 0.7 * capacity) or (flip_count >= 5 and current_weight < 0.5 * capacity):\n            phase = 1\n\n        # Stop if we've made enough changes\n        if flip_count >= 10:\n            break\n\n    # Final check to ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio until feasible\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8320285137289343,
            6.021730810403824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and objective synergy\n    if abs_correlation > 0.5:  # Strong correlation, prioritize items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Adaptive flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_count = 0\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                flip_count += 1\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                flip_count += 1\n\n        # Switch phase when capacity is 70% full or after 5 flips\n        if (current_weight > 0.7 * capacity) or (flip_count >= 5 and current_weight < 0.5 * capacity):\n            phase = 1\n\n        # Stop if we've made enough changes\n        if flip_count >= 10:\n            break\n\n    # Final check to ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio until feasible\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n    diversity_scores = [(abs(obj[0] - avg_obj1) + abs(obj[1] - avg_obj2)) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping items based on their contribution to both objectives\n    # Calculate the contribution of each item to both objectives\n    contrib1 = value1_lst / weight_lst\n    contrib2 = value2_lst / weight_lst\n    combined_contrib = contrib1 + contrib2\n\n    # Identify items that are either in the solution or have high contribution\n    candidate_items = np.where((new_solution == 1) | (combined_contrib > np.percentile(combined_contrib, 75)))[0]\n\n    # Randomly select a subset of candidates to flip\n    flip_indices = np.random.choice(candidate_items, size=min(2, len(candidate_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest combined contribution if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Find items with the lowest combined contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8452245197314301,
            5.639758288860321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n    diversity_scores = [(abs(obj[0] - avg_obj1) + abs(obj[1] - avg_obj2)) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping items based on their contribution to both objectives\n    # Calculate the contribution of each item to both objectives\n    contrib1 = value1_lst / weight_lst\n    contrib2 = value2_lst / weight_lst\n    combined_contrib = contrib1 + contrib2\n\n    # Identify items that are either in the solution or have high contribution\n    candidate_items = np.where((new_solution == 1) | (combined_contrib > np.percentile(combined_contrib, 75)))[0]\n\n    # Randomly select a subset of candidates to flip\n    flip_indices = np.random.choice(candidate_items, size=min(2, len(candidate_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items with lowest combined contribution if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Find items with the lowest combined contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.802648101797464,
            7.792183995246887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.random.choice(min(3, len(sorted_archive)), size=1)[0]\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contribution for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items not in the current solution with high marginal contribution\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 1)[0]\n\n    # Select items with top marginal contribution for both objectives\n    top_items1 = candidate_items[np.argsort(marginal_contrib1[candidate_items])[-min(3, len(candidate_items)):]]\n    top_items2 = candidate_items[np.argsort(marginal_contrib2[candidate_items])[-min(3, len(candidate_items)):]]\n\n    # Combine and select unique items\n    flip_indices = np.union1d(top_items1, top_items2)\n    flip_indices = np.random.choice(flip_indices, size=min(2, len(flip_indices)), replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.39471638667142595,
            7.441407412290573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.random.choice(min(3, len(sorted_archive)), size=1)[0]\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contribution for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items not in the current solution with high marginal contribution\n    candidate_items = np.where(base_solution == 0)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 1)[0]\n\n    # Select items with top marginal contribution for both objectives\n    top_items1 = candidate_items[np.argsort(marginal_contrib1[candidate_items])[-min(3, len(candidate_items)):]]\n    top_items2 = candidate_items[np.argsort(marginal_contrib2[candidate_items])[-min(3, len(candidate_items)):]]\n\n    # Combine and select unique items\n    flip_indices = np.union1d(top_items1, top_items2)\n    flip_indices = np.random.choice(flip_indices, size=min(2, len(flip_indices)), replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance ratio\" score that combines normalized objective values with a penalty for weight proximity to capacity, then generates neighbors by strategically flipping items with high cross-objective value-to-weight ratios while maintaining feasibility through a two-phase adjustment process that prioritizes items with high synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective dominance ratio score\n    objectives = np.array([obj for _, obj in archive])\n    v1_max, v2_max = objectives.max(axis=0)\n    dominance_scores = (objectives[:, 0]/v1_max + objectives[:, 1]/v2_max) * (1 - np.array([np.sum(weight_lst * sol)/capacity for sol, _ in archive]))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio * v2_ratio) ** 0.5\n\n    # Identify flip candidates based on cross-ratio and current solution state\n    flip_candidates = np.argsort(cross_ratio * (1 - base_solution))[::-1]\n\n    # Two-phase flipping with adaptive capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0\n    capacity_threshold = 0.6 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:  # Addition phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity_threshold:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Removal phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when approaching capacity\n        if current_weight > capacity_threshold:\n            phase = 1\n            capacity_threshold = 0.9 * capacity\n\n    return new_solution\n\n",
        "score": [
            -0.954531232110932,
            4.880401313304901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective dominance ratio score\n    objectives = np.array([obj for _, obj in archive])\n    v1_max, v2_max = objectives.max(axis=0)\n    dominance_scores = (objectives[:, 0]/v1_max + objectives[:, 1]/v2_max) * (1 - np.array([np.sum(weight_lst * sol)/capacity for sol, _ in archive]))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio * v2_ratio) ** 0.5\n\n    # Identify flip candidates based on cross-ratio and current solution state\n    flip_candidates = np.argsort(cross_ratio * (1 - base_solution))[::-1]\n\n    # Two-phase flipping with adaptive capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0\n    capacity_threshold = 0.6 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:  # Addition phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity_threshold:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Removal phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when approaching capacity\n        if current_weight > capacity_threshold:\n            phase = 1\n            capacity_threshold = 0.9 * capacity\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This new algorithm selects a solution from the archive with the highest combined objective score, then generates a neighbor by flipping a subset of high-marginal-contribution items, while using a dynamic threshold for item selection and adaptive flipping based on current solution quality to ensure feasibility and potentially better objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Combine contributions with adaptive weights based on current solution quality\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n    weight1 = total_value2 / (total_value1 + total_value2 + 1e-6)  # Avoid division by zero\n    weight2 = total_value1 / (total_value1 + total_value2 + 1e-6)\n    combined_contrib = weight1 * marginal_contrib1 + weight2 * marginal_contrib2\n\n    # Dynamic threshold for selecting high-contribution items\n    threshold = np.percentile(combined_contrib, 75)  # Top 25% of items\n    high_contrib_items = np.where(combined_contrib >= threshold)[0]\n\n    # Flip a subset of high-contribution items with adaptive size\n    flip_size = min(5, len(high_contrib_items))\n    flip_indices = np.random.choice(high_contrib_items, size=flip_size, replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4356699369132253,
            5.754834532737732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Combine contributions with adaptive weights based on current solution quality\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n    weight1 = total_value2 / (total_value1 + total_value2 + 1e-6)  # Avoid division by zero\n    weight2 = total_value1 / (total_value1 + total_value2 + 1e-6)\n    combined_contrib = weight1 * marginal_contrib1 + weight2 * marginal_contrib2\n\n    # Dynamic threshold for selecting high-contribution items\n    threshold = np.percentile(combined_contrib, 75)  # Top 25% of items\n    high_contrib_items = np.where(combined_contrib >= threshold)[0]\n\n    # Flip a subset of high-contribution items with adaptive size\n    flip_size = min(5, len(high_contrib_items))\n    flip_indices = np.random.choice(high_contrib_items, size=flip_size, replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in the current solution\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The new algorithm selects a solution from the archive by considering both objective values and their trade-offs, then applies a hybrid local search that combines item swapping with a probabilistic acceptance criterion to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    trade_off_scores = []\n    for sol, obj in archive:\n        v1, v2 = obj\n        trade_off = abs(v1 - v2) / (v1 + v2 + 1e-6)  # Normalized trade-off\n        trade_off_scores.append(trade_off)\n\n    selected_idx = np.argmax(trade_off_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with probabilistic acceptance\n    current_weight = np.sum(weight_lst * new_solution)\n    available_items = np.where(base_solution == 0)[0]\n    selected_items = np.where(base_solution == 1)[0]\n\n    for _ in range(5):  # Perform 5 random swaps\n        if len(available_items) > 0 and len(selected_items) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = np.random.choice(selected_items)\n            add_idx = np.random.choice(available_items)\n\n            # Calculate weight change\n            weight_change = weight_lst[add_idx] - weight_lst[remove_idx]\n\n            # Check feasibility and probabilistic acceptance\n            if current_weight + weight_change <= capacity or np.random.rand() < 0.3:  # 30% chance to accept infeasible swap\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight += weight_change\n\n                # Update available/selected items\n                available_items = np.where(new_solution == 0)[0]\n                selected_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.79279966030088,
            5.597122013568878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    trade_off_scores = []\n    for sol, obj in archive:\n        v1, v2 = obj\n        trade_off = abs(v1 - v2) / (v1 + v2 + 1e-6)  # Normalized trade-off\n        trade_off_scores.append(trade_off)\n\n    selected_idx = np.argmax(trade_off_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with probabilistic acceptance\n    current_weight = np.sum(weight_lst * new_solution)\n    available_items = np.where(base_solution == 0)[0]\n    selected_items = np.where(base_solution == 1)[0]\n\n    for _ in range(5):  # Perform 5 random swaps\n        if len(available_items) > 0 and len(selected_items) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = np.random.choice(selected_items)\n            add_idx = np.random.choice(available_items)\n\n            # Calculate weight change\n            weight_change = weight_lst[add_idx] - weight_lst[remove_idx]\n\n            # Check feasibility and probabilistic acceptance\n            if current_weight + weight_change <= capacity or np.random.rand() < 0.3:  # 30% chance to accept infeasible swap\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight += weight_change\n\n                # Update available/selected items\n                available_items = np.where(new_solution == 0)[0]\n                selected_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7855348185573091,
            5.737573325634003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This algorithm selects a solution from the archive that is highly promising for local improvement by evaluating both objectives, then generates a neighbor by strategically flipping items with high marginal contribution in both objectives, while ensuring feasibility through a dynamic adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//2:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//2:]\n\n    # Combine and deduplicate high-contribution items\n    high_contrib_items = np.unique(np.concatenate([high_contrib_items1, high_contrib_items2]))\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in both objectives\n        while current_weight > capacity:\n            # Calculate current marginal contributions for both objectives\n            current_contrib1 = value1_lst * new_solution\n            current_contrib2 = value2_lst * new_solution\n            total_contrib = current_contrib1 + current_contrib2\n\n            # Find items with the lowest total contribution in the current solution\n            low_contrib_items = np.argsort(total_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.31021592847069124,
            4.371748894453049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution in either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//2:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//2:]\n\n    # Combine and deduplicate high-contribution items\n    high_contrib_items = np.unique(np.concatenate([high_contrib_items1, high_contrib_items2]))\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in both objectives\n        while current_weight > capacity:\n            # Calculate current marginal contributions for both objectives\n            current_contrib1 = value1_lst * new_solution\n            current_contrib2 = value2_lst * new_solution\n            total_contrib = current_contrib1 + current_contrib2\n\n            # Find items with the lowest total contribution in the current solution\n            low_contrib_items = np.argsort(total_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # If no items can be added, remove the lowest marginal contribution items\n    if len(candidate_items) == 0:\n        # Calculate marginal contribution for items in the solution\n        marginal_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(marginal_contrib)[::-1]  # Sort in descending order\n\n        # Remove items with the lowest marginal contribution until feasible\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                remaining_capacity += weight_lst[idx]\n                # Recheck candidate items after removal\n                candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n                if len(candidate_items) > 0:\n                    break\n    else:\n        # Randomly select a subset of candidate items to add\n        num_to_add = min(2, len(candidate_items))\n        selected_items = np.random.choice(candidate_items, size=num_to_add, replace=False)\n        new_solution[selected_items] = 1\n\n    # Ensure feasibility by removing items if capacity exceeded (safety check)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        marginal_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(marginal_contrib)[::-1]\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9146428120199547,
            2.931458681821823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # If no items can be added, remove the lowest marginal contribution items\n    if len(candidate_items) == 0:\n        # Calculate marginal contribution for items in the solution\n        marginal_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(marginal_contrib)[::-1]  # Sort in descending order\n\n        # Remove items with the lowest marginal contribution until feasible\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                remaining_capacity += weight_lst[idx]\n                # Recheck candidate items after removal\n                candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n                if len(candidate_items) > 0:\n                    break\n    else:\n        # Randomly select a subset of candidate items to add\n        num_to_add = min(2, len(candidate_items))\n        selected_items = np.random.choice(candidate_items, size=num_to_add, replace=False)\n        new_solution[selected_items] = 1\n\n    # Ensure feasibility by removing items if capacity exceeded (safety check)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        marginal_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(marginal_contrib)[::-1]\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted sum of objectives with random weights, then applies a hybrid local search combining marginal contribution analysis and random flips to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    normalized_weights = weights / np.sum(weights)\n    scores = [obj[0] * normalized_weights[0] + obj[1] * normalized_weights[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 * normalized_weights[0] + marginal_contrib2 * normalized_weights[1]\n\n    # Identify items with high marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest weighted marginal contribution in current solution\n        current_contrib = (value1_lst * normalized_weights[0] + value2_lst * normalized_weights[1]) * new_solution\n        while current_weight > capacity:\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5445844594065441,
            3.764139771461487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    normalized_weights = weights / np.sum(weights)\n    scores = [obj[0] * normalized_weights[0] + obj[1] * normalized_weights[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 * normalized_weights[0] + marginal_contrib2 * normalized_weights[1]\n\n    # Identify items with high marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest weighted marginal contribution in current solution\n        current_contrib = (value1_lst * normalized_weights[0] + value2_lst * normalized_weights[1]) * new_solution\n        while current_weight > capacity:\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and their diversity, then generates a neighbor by strategically flipping items with high marginal value improvement while maintaining feasibility through a dynamic capacity threshold adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity scores for each solution\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n    diversity = np.mean(normalized, axis=1)\n\n    # Combine diversity with objective values (weighted 70-30)\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = 0.7 * np.sum(normalized, axis=1) + 0.3 * diversity - 0.1 * weights / capacity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal value improvement\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate potential improvement for each item\n    improvement1 = (value1_lst - current_value1) / (weight_lst + 1e-6)\n    improvement2 = (value2_lst - current_value2) / (weight_lst + 1e-6)\n    combined_improvement = improvement1 + improvement2\n\n    # Sort items by combined improvement\n    flip_candidates = np.argsort(combined_improvement)[::-1]\n\n    # Dynamic capacity threshold (80% of capacity)\n    dynamic_threshold = 0.8 * capacity\n\n    # Two-phase flipping with dynamic threshold\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= dynamic_threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9102602741984462,
            8.16319277882576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity scores for each solution\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n    diversity = np.mean(normalized, axis=1)\n\n    # Combine diversity with objective values (weighted 70-30)\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = 0.7 * np.sum(normalized, axis=1) + 0.3 * diversity - 0.1 * weights / capacity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal value improvement\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate potential improvement for each item\n    improvement1 = (value1_lst - current_value1) / (weight_lst + 1e-6)\n    improvement2 = (value2_lst - current_value2) / (weight_lst + 1e-6)\n    combined_improvement = improvement1 + improvement2\n\n    # Sort items by combined improvement\n    flip_candidates = np.argsort(combined_improvement)[::-1]\n\n    # Dynamic capacity threshold (80% of capacity)\n    dynamic_threshold = 0.8 * capacity\n\n    # Two-phase flipping with dynamic threshold\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= dynamic_threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives * crowding_dist, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high contribution to both objectives\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//4:]\n\n    # Hybrid local search: random flips with targeted swaps\n    if np.random.random() < 0.7:  # 70% chance for random flip\n        # Randomly flip a subset of high-contribution items\n        flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n    else:  # 30% chance for targeted swap\n        # Swap two items: one from high-contribution and one from low-contribution\n        low_contrib_items = np.argsort(combined_contrib)[:len(combined_contrib)//4]\n        if len(low_contrib_items) > 0 and len(high_contrib_items) > 0:\n            swap_out = np.random.choice(low_contrib_items)\n            swap_in = np.random.choice(high_contrib_items)\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest ratio of (value1 + value2) to weight until feasible\n        while current_weight > capacity:\n            current_ratios = (value1_lst + value2_lst) / weight_lst\n            current_ratios[new_solution == 0] = np.inf  # Exclude items not in solution\n            remove_idx = np.argmin(current_ratios)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2511840968656454,
            9.526672452688217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives * crowding_dist, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high contribution to both objectives\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//4:]\n\n    # Hybrid local search: random flips with targeted swaps\n    if np.random.random() < 0.7:  # 70% chance for random flip\n        # Randomly flip a subset of high-contribution items\n        flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n    else:  # 30% chance for targeted swap\n        # Swap two items: one from high-contribution and one from low-contribution\n        low_contrib_items = np.argsort(combined_contrib)[:len(combined_contrib)//4]\n        if len(low_contrib_items) > 0 and len(high_contrib_items) > 0:\n            swap_out = np.random.choice(low_contrib_items)\n            swap_in = np.random.choice(high_contrib_items)\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest ratio of (value1 + value2) to weight until feasible\n        while current_weight > capacity:\n            current_ratios = (value1_lst + value2_lst) / weight_lst\n            current_ratios[new_solution == 0] = np.inf  # Exclude items not in solution\n            remove_idx = np.argmin(current_ratios)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_vals = np.array([obj[0] for _, obj in archive])\n    obj2_vals = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1_vals - np.min(obj1_vals)) / (np.max(obj1_vals) - np.min(obj1_vals) + 1e-8)\n    norm_obj2 = (obj2_vals - np.min(obj2_vals)) / (np.max(obj2_vals) - np.min(obj2_vals) + 1e-8)\n    combined_scores = norm_obj1 + norm_obj2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items in the current solution and not in the solution\n    in_solution = np.where(new_solution == 1)[0]\n    not_in_solution = np.where(new_solution == 0)[0]\n\n    # Perform adaptive perturbation: swap high-contribution items with low-contribution items\n    if len(in_solution) > 0 and len(not_in_solution) > 0:\n        # Select top 20% high-contribution items in the solution\n        high_contrib_in = np.argsort(marginal_contrib1[in_solution] + marginal_contrib2[in_solution])[-max(1, len(in_solution)//5):]\n        high_contrib_indices = in_solution[high_contrib_in]\n\n        # Select bottom 20% low-contribution items not in the solution\n        low_contrib_not_in = np.argsort(marginal_contrib1[not_in_solution] + marginal_contrib2[not_in_solution])[:max(1, len(not_in_solution)//5)]\n        low_contrib_indices = not_in_solution[low_contrib_not_in]\n\n        # Perform swaps between high-contribution items in solution and low-contribution items not in solution\n        for i in range(min(len(high_contrib_indices), len(low_contrib_indices))):\n            new_solution[high_contrib_indices[i]] = 0\n            new_solution[low_contrib_indices[i]] = 1\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    # Apply adaptive perturbation: randomly flip a small number of items to escape local optima\n    if np.random.rand() < 0.3:\n        flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Remove items in order of lowest marginal contribution until feasible\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8843702325671936,
            4.435711443424225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_vals = np.array([obj[0] for _, obj in archive])\n    obj2_vals = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1_vals - np.min(obj1_vals)) / (np.max(obj1_vals) - np.min(obj1_vals) + 1e-8)\n    norm_obj2 = (obj2_vals - np.min(obj2_vals)) / (np.max(obj2_vals) - np.min(obj2_vals) + 1e-8)\n    combined_scores = norm_obj1 + norm_obj2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items in the current solution and not in the solution\n    in_solution = np.where(new_solution == 1)[0]\n    not_in_solution = np.where(new_solution == 0)[0]\n\n    # Perform adaptive perturbation: swap high-contribution items with low-contribution items\n    if len(in_solution) > 0 and len(not_in_solution) > 0:\n        # Select top 20% high-contribution items in the solution\n        high_contrib_in = np.argsort(marginal_contrib1[in_solution] + marginal_contrib2[in_solution])[-max(1, len(in_solution)//5):]\n        high_contrib_indices = in_solution[high_contrib_in]\n\n        # Select bottom 20% low-contribution items not in the solution\n        low_contrib_not_in = np.argsort(marginal_contrib1[not_in_solution] + marginal_contrib2[not_in_solution])[:max(1, len(not_in_solution)//5)]\n        low_contrib_indices = not_in_solution[low_contrib_not_in]\n\n        # Perform swaps between high-contribution items in solution and low-contribution items not in solution\n        for i in range(min(len(high_contrib_indices), len(low_contrib_indices))):\n            new_solution[high_contrib_indices[i]] = 0\n            new_solution[low_contrib_indices[i]] = 1\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    # Apply adaptive perturbation: randomly flip a small number of items to escape local optima\n    if np.random.rand() < 0.3:\n        flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Remove items in order of lowest marginal contribution until feasible\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This algorithm selects a solution from the archive based on both objective values and their diversity, then generates a neighbor by strategically swapping items between high-value groups and low-value groups across objectives, while maintaining feasibility through a weight-balanced adjustment process that prioritizes cross-objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest diversity in objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value groups for both objectives\n    v1_median = np.median(value1_lst)\n    v2_median = np.median(value2_lst)\n    high_v1 = (value1_lst > v1_median) & (weight_lst <= capacity)\n    high_v2 = (value2_lst > v2_median) & (weight_lst <= capacity)\n    low_v1 = (value1_lst <= v1_median) & (weight_lst <= capacity)\n    low_v2 = (value2_lst <= v2_median) & (weight_lst <= capacity)\n\n    # Identify candidate items for swapping\n    candidates = []\n    if np.random.rand() > 0.5:\n        candidates = np.where(high_v1 & low_v2)[0]  # High v1, low v2\n    else:\n        candidates = np.where(high_v2 & low_v1)[0]  # High v2, low v1\n\n    # Perform strategic swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        removable = np.where(new_solution == 1)[0]\n        weights_sorted = np.argsort(weight_lst[removable])\n        for i in weights_sorted:\n            if excess <= 0:\n                break\n            idx = removable[i]\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7665872869273573,
            3.3243933022022247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest diversity in objective values\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value groups for both objectives\n    v1_median = np.median(value1_lst)\n    v2_median = np.median(value2_lst)\n    high_v1 = (value1_lst > v1_median) & (weight_lst <= capacity)\n    high_v2 = (value2_lst > v2_median) & (weight_lst <= capacity)\n    low_v1 = (value1_lst <= v1_median) & (weight_lst <= capacity)\n    low_v2 = (value2_lst <= v2_median) & (weight_lst <= capacity)\n\n    # Identify candidate items for swapping\n    candidates = []\n    if np.random.rand() > 0.5:\n        candidates = np.where(high_v1 & low_v2)[0]  # High v1, low v2\n    else:\n        candidates = np.where(high_v2 & low_v1)[0]  # High v2, low v1\n\n    # Perform strategic swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        removable = np.where(new_solution == 1)[0]\n        weights_sorted = np.argsort(weight_lst[removable])\n        for i in weights_sorted:\n            if excess <= 0:\n                break\n            idx = removable[i]\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{A novel local search heuristic that first selects a solution from the archive based on a weighted sum of objective values, then applies a hybrid perturbation strategy that combines random flips of high-marginal-contribution items with a greedy removal of low-contribution items to ensure feasibility, while also incorporating a dynamic adjustment of perturbation intensity based on solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high and low marginal contributions\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n    low_contrib_items = np.argsort(combined_contrib)[:len(combined_contrib)//2]\n\n    # Apply hybrid perturbation: flip high-contribution items and remove low-contribution items\n    for idx in high_contrib_items:\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing low-contribution items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Additional dynamic adjustment: if solution is poor, apply more aggressive perturbations\n    if combined_values[selected_idx] < np.mean(combined_values) * 0.8:\n        for idx in np.random.choice(len(new_solution), size=2, replace=False):\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.29970230448734075,
            2.4279381334781647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high and low marginal contributions\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n    low_contrib_items = np.argsort(combined_contrib)[:len(combined_contrib)//2]\n\n    # Apply hybrid perturbation: flip high-contribution items and remove low-contribution items\n    for idx in high_contrib_items:\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing low-contribution items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Additional dynamic adjustment: if solution is poor, apply more aggressive perturbations\n    if combined_values[selected_idx] < np.mean(combined_values) * 0.8:\n        for idx in np.random.choice(len(new_solution), size=2, replace=False):\n            new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = [(obj[0] / np.max([o[0] for _, o in archive]), obj[1] / np.max([o[1] for _, o in archive])) for _, obj in archive]\n    selected_idx = np.argmax([(score[0] + score[1]) / 2 for score in normalized_scores])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.40262261673689004,
            3.362569898366928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = [(obj[0] / np.max([o[0] for _, o in archive]), obj[1] / np.max([o[1] for _, o in archive])) for _, obj in archive]\n    selected_idx = np.argmax([(score[0] + score[1]) / 2 for score in normalized_scores])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7934221659619043,
            5.3647491335868835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel heuristic that selects a solution based on a weighted sum of objectives with randomized weights, then applies a hybrid local search by flipping items with high marginal contribution in either objective space while ensuring feasibility through a greedy removal of low-contribution items when capacity is exceeded.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    scores = [obj[0] * weights[i] + obj[1] * (1 - weights[i]) for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Randomly choose to focus on one objective space with 70% probability\n    if np.random.rand() < 0.7:\n        # Focus on objective 1\n        high_contrib_items = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//2:]\n    else:\n        # Focus on objective 2\n        high_contrib_items = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//2:]\n\n    # Randomly select a subset of high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(4, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5000855937419623,
            3.4370511770248413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    scores = [obj[0] * weights[i] + obj[1] * (1 - weights[i]) for i, (_, obj) in enumerate(archive)]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n\n    # Randomly choose to focus on one objective space with 70% probability\n    if np.random.rand() < 0.7:\n        # Focus on objective 1\n        high_contrib_items = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//2:]\n    else:\n        # Focus on objective 2\n        high_contrib_items = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//2:]\n\n    # Randomly select a subset of high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(4, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (marginal_contrib1 + marginal_contrib2) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution for either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n\n    # Randomly select items to swap (one from each high-contribution set)\n    if len(high_contrib_items1) > 0 and len(high_contrib_items2) > 0:\n        swap_idx1 = np.random.choice(high_contrib_items1)\n        swap_idx2 = np.random.choice(high_contrib_items2)\n        new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    # Randomly flip a subset of items with high marginal contribution\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4614694779808652,
            2.3760408461093903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n\n    # Identify items with high marginal contribution for either objective\n    high_contrib_items1 = np.argsort(marginal_contrib1)[-len(marginal_contrib1)//4:]\n    high_contrib_items2 = np.argsort(marginal_contrib2)[-len(marginal_contrib2)//4:]\n\n    # Randomly select items to swap (one from each high-contribution set)\n    if len(high_contrib_items1) > 0 and len(high_contrib_items2) > 0:\n        swap_idx1 = np.random.choice(high_contrib_items1)\n        swap_idx2 = np.random.choice(high_contrib_items2)\n        new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    # Randomly flip a subset of items with high marginal contribution\n    high_contrib_items = np.union1d(high_contrib_items1, high_contrib_items2)\n    flip_indices = np.random.choice(high_contrib_items, size=min(2, len(high_contrib_items)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items currently in the solution with high marginal contribution\n    high_contrib_in = np.where((new_solution == 1) & (combined_contrib > np.percentile(combined_contrib, 75)))[0]\n    # Identify items currently out of the solution with high marginal contribution\n    high_contrib_out = np.where((new_solution == 0) & (combined_contrib > np.percentile(combined_contrib, 75)))[0]\n\n    # Apply a novel local search strategy: swap high-contribution items in and out\n    if len(high_contrib_in) > 0 and len(high_contrib_out) > 0:\n        # Randomly select one item to remove and one to add\n        remove_idx = np.random.choice(high_contrib_in)\n        add_idx = np.random.choice(high_contrib_out)\n\n        # Perform the swap\n        new_solution[remove_idx] = 0\n        new_solution[add_idx] = 1\n\n        # Ensure feasibility by removing items if capacity exceeded\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Remove items with the lowest marginal contribution until feasible\n            while current_weight > capacity:\n                # Find items with the lowest marginal contribution in the current solution\n                current_contrib = (value1_lst + value2_lst) * new_solution\n                low_contrib_items = np.argsort(current_contrib)[::-1]\n                for idx in low_contrib_items:\n                    if new_solution[idx] == 1:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.36497598273555976,
            4.4896611869335175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items currently in the solution with high marginal contribution\n    high_contrib_in = np.where((new_solution == 1) & (combined_contrib > np.percentile(combined_contrib, 75)))[0]\n    # Identify items currently out of the solution with high marginal contribution\n    high_contrib_out = np.where((new_solution == 0) & (combined_contrib > np.percentile(combined_contrib, 75)))[0]\n\n    # Apply a novel local search strategy: swap high-contribution items in and out\n    if len(high_contrib_in) > 0 and len(high_contrib_out) > 0:\n        # Randomly select one item to remove and one to add\n        remove_idx = np.random.choice(high_contrib_in)\n        add_idx = np.random.choice(high_contrib_out)\n\n        # Perform the swap\n        new_solution[remove_idx] = 0\n        new_solution[add_idx] = 1\n\n        # Ensure feasibility by removing items if capacity exceeded\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Remove items with the lowest marginal contribution until feasible\n            while current_weight > capacity:\n                # Find items with the lowest marginal contribution in the current solution\n                current_contrib = (value1_lst + value2_lst) * new_solution\n                low_contrib_items = np.argsort(current_contrib)[::-1]\n                for idx in low_contrib_items:\n                    if new_solution[idx] == 1:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search that combines marginal contribution analysis with random perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n\n    # Select solution with highest weighted sum of normalized objectives\n    weights = np.random.dirichlet([1, 1])\n    scores = weights[0] * norm_obj1 + weights[1] * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine marginal contribution with random perturbations\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items with probability 0.7, otherwise random flip\n    for idx in flip_indices:\n        if np.random.rand() < 0.7:\n            new_solution[idx] = 1 - new_solution[idx]\n        else:\n            new_solution[idx] = np.random.randint(0, 2)\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in current solution\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.36272657540978037,
            4.123570144176483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n\n    # Select solution with highest weighted sum of normalized objectives\n    weights = np.random.dirichlet([1, 1])\n    scores = weights[0] * norm_obj1 + weights[1] * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine marginal contribution with random perturbations\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items with probability 0.7, otherwise random flip\n    for idx in flip_indices:\n        if np.random.rand() < 0.7:\n            new_solution[idx] = 1 - new_solution[idx]\n        else:\n            new_solution[idx] = np.random.randint(0, 2)\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution in current solution\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm selects a solution from the archive that shows potential for improvement by analyzing the trade-off between objectives, then generates a neighbor by strategically flipping items based on their contribution to both objectives, while ensuring feasibility through a dynamic adjustment process that prioritizes items with high cross-objective value synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off between objectives (normalized by weight)\n    objectives = np.array([(obj[0] + obj[1]) / (weight_lst * sol).sum() for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value synergy\n    synergy = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    synergy_score = synergy * (1 - base_solution)  # Prioritize items not in current solution\n\n    # Identify items to flip based on synergy and current solution status\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic flipping with feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8954373894073817,
            3.329691082239151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off between objectives (normalized by weight)\n    objectives = np.array([(obj[0] + obj[1]) / (weight_lst * sol).sum() for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value synergy\n    synergy = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    synergy_score = synergy * (1 - base_solution)  # Prioritize items not in current solution\n\n    # Identify items to flip based on synergy and current solution status\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic flipping with feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and marginal contribution\n    if abs_correlation > 0.5:  # Strong correlation, prioritize items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, prioritize items with high marginal contribution\n        marginal_contrib1 = value1_lst / weight_lst\n        marginal_contrib2 = value2_lst / weight_lst\n        combined_contrib = marginal_contrib1 + marginal_contrib2\n        flip_candidates = np.argsort(combined_contrib)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    # Final check and adjustment\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        remove_candidates = np.argsort(current_contrib)[::-1]\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9004233083415075,
            3.76578027009964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and marginal contribution\n    if abs_correlation > 0.5:  # Strong correlation, prioritize items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, prioritize items with high marginal contribution\n        marginal_contrib1 = value1_lst / weight_lst\n        marginal_contrib2 = value2_lst / weight_lst\n        combined_contrib = marginal_contrib1 + marginal_contrib2\n        flip_candidates = np.argsort(combined_contrib)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    # Final check and adjustment\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        remove_candidates = np.argsort(current_contrib)[::-1]\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8710433594535185,
            1.9005539417266846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining normalized objective values and item diversity, then generates a neighbor by flipping items with high marginal contribution to both objectives while ensuring feasibility through a dynamic weight adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = 0.4 * (norm_obj1 + norm_obj2) + 0.6 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with dynamic weight adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by marginal contribution in descending order\n        item_indices = np.argsort(-combined_contrib)\n        for idx in item_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.39104252241357534,
            0.6390179693698883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = 0.4 * (norm_obj1 + norm_obj2) + 0.6 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with dynamic weight adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Sort items by marginal contribution in descending order\n        item_indices = np.argsort(-combined_contrib)\n        for idx in item_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with high combined objective values, then generates a neighbor by intelligently flipping items with high marginal contribution while ensuring feasibility through a probabilistic removal process if capacity is exceeded.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items to flip based on probability weighted by marginal contribution\n    probs = combined_contrib / np.sum(combined_contrib)\n    flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), p=probs, replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with probabilistic removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate removal probabilities based on inverse marginal contribution\n        removal_probs = 1.0 / (combined_contrib + 1e-6)\n        removal_probs = removal_probs / np.sum(removal_probs)\n        while current_weight > capacity:\n            # Select an item to remove with probability proportional to its inverse contribution\n            remove_idx = np.random.choice(len(weight_lst), p=removal_probs)\n            if new_solution[remove_idx] == 1:\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3481112870225599,
            2.1698614060878754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items to flip based on probability weighted by marginal contribution\n    probs = combined_contrib / np.sum(combined_contrib)\n    flip_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), p=probs, replace=False)\n\n    # Flip selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with probabilistic removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Calculate removal probabilities based on inverse marginal contribution\n        removal_probs = 1.0 / (combined_contrib + 1e-6)\n        removal_probs = removal_probs / np.sum(removal_probs)\n        while current_weight > capacity:\n            # Select an item to remove with probability proportional to its inverse contribution\n            remove_idx = np.random.choice(len(weight_lst), p=removal_probs)\n            if new_solution[remove_idx] == 1:\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"value diversity\" metric that combines both objectives with a dynamic weight that adapts to the current solution's structure, then generates a neighbor by strategically flipping items based on their potential to diversify the solution while maintaining feasibility through a multi-phase adjustment process that prioritizes items with high cross-objective trade-off potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate value diversity metric for each solution\n    objectives = np.array([obj for _, obj in archive])\n    v1_norm = objectives[:, 0] / (np.sum(value1_lst) + 1e-6)\n    v2_norm = objectives[:, 1] / (np.sum(value2_lst) + 1e-6)\n    diversity_scores = np.abs(v1_norm - v2_norm)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weight based on solution structure\n    current_weight = np.sum(weight_lst * new_solution)\n    weight_ratio = current_weight / capacity\n    dynamic_weight = 0.7 if weight_ratio < 0.5 else 1.3\n\n    # Calculate value diversity heuristic for items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    value_diversity = np.abs(v1_ratio - v2_ratio) * dynamic_weight\n\n    # Identify items to flip based on value diversity\n    flip_candidates = np.argsort(value_diversity)[::-1]\n\n    # Multi-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8758201826722091,
            0.5908966064453125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate value diversity metric for each solution\n    objectives = np.array([obj for _, obj in archive])\n    v1_norm = objectives[:, 0] / (np.sum(value1_lst) + 1e-6)\n    v2_norm = objectives[:, 1] / (np.sum(value2_lst) + 1e-6)\n    diversity_scores = np.abs(v1_norm - v2_norm)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weight based on solution structure\n    current_weight = np.sum(weight_lst * new_solution)\n    weight_ratio = current_weight / capacity\n    dynamic_weight = 0.7 if weight_ratio < 0.5 else 1.3\n\n    # Calculate value diversity heuristic for items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    value_diversity = np.abs(v1_ratio - v2_ratio) * dynamic_weight\n\n    # Identify items to flip based on value diversity\n    flip_candidates = np.argsort(value_diversity)[::-1]\n\n    # Multi-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score combining normalized objective values and diversity-aware weight distribution, then generates a neighbor by flipping items with high cross-objective value synergy while maintaining feasibility through a dynamic capacity utilization strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / (max_obj + 1e-6)\n    diversity = np.std(norm_obj, axis=0)\n    scores = np.sum(norm_obj * diversity, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value synergy\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    synergy = v1_norm * v2_norm * weight_lst / (np.sum(weight_lst * base_solution) + 1e-6)\n    flip_candidates = np.argsort(synergy)[::-1]\n\n    # Dynamic capacity utilization strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    utilization_threshold = min(0.9, max(0.5, current_weight / capacity))\n    phase = 0 if current_weight < utilization_threshold * capacity else 1\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adaptive phase switching\n        if phase == 0 and current_weight > utilization_threshold * capacity:\n            phase = 1\n        elif phase == 1 and current_weight < (utilization_threshold - 0.1) * capacity:\n            phase = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8228006635003815,
            2.8160761892795563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / (max_obj + 1e-6)\n    diversity = np.std(norm_obj, axis=0)\n    scores = np.sum(norm_obj * diversity, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value synergy\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    synergy = v1_norm * v2_norm * weight_lst / (np.sum(weight_lst * base_solution) + 1e-6)\n    flip_candidates = np.argsort(synergy)[::-1]\n\n    # Dynamic capacity utilization strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    utilization_threshold = min(0.9, max(0.5, current_weight / capacity))\n    phase = 0 if current_weight < utilization_threshold * capacity else 1\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adaptive phase switching\n        if phase == 0 and current_weight > utilization_threshold * capacity:\n            phase = 1\n        elif phase == 1 and current_weight < (utilization_threshold - 0.1) * capacity:\n            phase = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8969479205285642,
            4.406024992465973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8389806644944884,
            3.441630631685257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with balanced objective improvements, then generates a neighbor by strategically flipping items based on a hybrid \"value-efficiency\" and \"objective-correlation\" heuristic that considers both individual item performance and their combined impact on both objectives, while maintaining feasibility through an adaptive capacity management process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most balanced objective improvement potential\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance_score = np.abs(obj1 - obj2)\n    selected_idx = np.argmin(balance_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid efficiency scores\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(value1_lst, value2_lst)[0, 1]\n    hybrid_score = (v1_efficiency + v2_efficiency) * (1 + correlation)\n\n    # Identify flip candidates based on hybrid score and current solution\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Adaptive flipping strategy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and (current_weight - weight_lst[idx]) <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Final capacity adjustment if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(weight_lst / (value1_lst + value2_lst + 1e-6))\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and weight_lst[idx] <= excess:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.778111806170019,
            2.664898067712784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most balanced objective improvement potential\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance_score = np.abs(obj1 - obj2)\n    selected_idx = np.argmin(balance_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid efficiency scores\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(value1_lst, value2_lst)[0, 1]\n    hybrid_score = (v1_efficiency + v2_efficiency) * (1 + correlation)\n\n    # Identify flip candidates based on hybrid score and current solution\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Adaptive flipping strategy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and (current_weight - weight_lst[idx]) <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Final capacity adjustment if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(weight_lst / (value1_lst + value2_lst + 1e-6))\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and weight_lst[idx] <= excess:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective balance\" heuristic that prioritizes items with high potential to improve one objective while maintaining or slightly improving the other, while ensuring feasibility through a dynamic capacity-aware adjustment process that alternates between adding and removing items in a way that preserves the balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized difference)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.abs(obj1 - obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmin(balance)  # Prefer solutions with balanced objectives\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items to flip based on balance\n    flip_candidates = np.argsort(np.abs(v1_balance - v2_balance))[::-1]  # Prioritize items that balance objectives\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items that improve balance\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items that disrupt balance\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Alternate phases based on capacity usage\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(np.abs(v1_balance - v2_balance))\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8512857200047712,
            2.7696732580661774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized difference)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.abs(obj1 - obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmin(balance)  # Prefer solutions with balanced objectives\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items to flip based on balance\n    flip_candidates = np.argsort(np.abs(v1_balance - v2_balance))[::-1]  # Prioritize items that balance objectives\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items that improve balance\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items that disrupt balance\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Alternate phases based on capacity usage\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(np.abs(v1_balance - v2_balance))\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective combining both value metrics, then applies a novel local search by strategically flipping items with high marginal contribution while ensuring feasibility through a weighted removal process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0] / np.sum(value1_lst), obj[1] / np.sum(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([(n_obj[0] + n_obj[1]) / 2 for n_obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items with high marginal contribution\n    high_marginal = np.argsort(combined_marginal)[-len(combined_marginal)//2:]\n\n    # Flip a subset of high-marginal items\n    flip_count = min(4, len(high_marginal))\n    flip_indices = np.random.choice(high_marginal, size=flip_count, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with weighted removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Calculate removal priority based on marginal contribution and weight\n            removal_priority = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            remove_idx = np.argmax(removal_priority * new_solution)\n            if new_solution[remove_idx] == 1:\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.31578377742005526,
            3.12826007604599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_obj = [(obj[0] / np.sum(value1_lst), obj[1] / np.sum(value2_lst)) for _, obj in archive]\n    selected_idx = np.argmax([(n_obj[0] + n_obj[1]) / 2 for n_obj in normalized_obj])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items with high marginal contribution\n    high_marginal = np.argsort(combined_marginal)[-len(combined_marginal)//2:]\n\n    # Flip a subset of high-marginal items\n    flip_count = min(4, len(high_marginal))\n    flip_indices = np.random.choice(high_marginal, size=flip_count, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility with weighted removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        while current_weight > capacity:\n            # Calculate removal priority based on marginal contribution and weight\n            removal_priority = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            remove_idx = np.argmax(removal_priority * new_solution)\n            if new_solution[remove_idx] == 1:\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective divergence\" metric that identifies solutions with imbalanced objectives, then generates a neighbor by strategically flipping items to rebalance the objectives while maintaining feasibility through a dynamic weight adjustment process that prioritizes items with high cross-objective trade-off potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective divergence scores\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0]\n    v2_scores = objectives[:, 1]\n    divergence = np.abs(v1_scores - v2_scores) / (np.maximum(v1_scores, v2_scores) + 1e-6)\n\n    # Select solution with highest divergence (most imbalanced objectives)\n    selected_idx = np.argmax(divergence)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item trade-off potential\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    trade_off = np.abs(v1_norm - v2_norm) * weight_lst / (weight_lst + 1e-6)\n\n    # Identify flip candidates based on trade-off potential and current solution status\n    flip_candidates = np.argsort(trade_off)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic flipping strategy\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            # Try removing high trade-off items first\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        elif current_weight + weight_lst[idx] <= capacity:\n            # Add items with high trade-off potential\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n        # Early termination if capacity is nearly full\n        if current_weight > 0.9 * capacity:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7823805846182268,
            10.274310529232025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective divergence scores\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0]\n    v2_scores = objectives[:, 1]\n    divergence = np.abs(v1_scores - v2_scores) / (np.maximum(v1_scores, v2_scores) + 1e-6)\n\n    # Select solution with highest divergence (most imbalanced objectives)\n    selected_idx = np.argmax(divergence)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item trade-off potential\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    trade_off = np.abs(v1_norm - v2_norm) * weight_lst / (weight_lst + 1e-6)\n\n    # Identify flip candidates based on trade-off potential and current solution status\n    flip_candidates = np.argsort(trade_off)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic flipping strategy\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            # Try removing high trade-off items first\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        elif current_weight + weight_lst[idx] <= capacity:\n            # Add items with high trade-off potential\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n        # Early termination if capacity is nearly full\n        if current_weight > 0.9 * capacity:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid score combining normalized objective values and their variance, then generates neighbors by flipping items with high \"value-entropy\" scores to balance exploration and exploitation while maintaining feasibility through a dynamic weight adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate hybrid score combining normalized objectives and variance\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    variance = np.var(norm_obj, axis=0)\n    scores = np.sum(norm_obj * variance, axis=1) / (np.array([np.sum(weight_lst * sol) for sol, _ in archive]) + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-entropy scores for both objectives\n    v1_entropy = -np.sum(np.log(value1_lst + 1) * value1_lst / np.sum(value1_lst))\n    v2_entropy = -np.sum(np.log(value2_lst + 1) * value2_lst / np.sum(value2_lst))\n    v1_score = value1_lst * (1 + v1_entropy)\n    v2_score = value2_lst * (1 + v2_entropy)\n    flip_candidates = np.argsort(v1_score + v2_score)[::-1]\n\n    # Dynamic weight adjustment phase\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    threshold = 0.6 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adjust phase based on current weight\n        if current_weight > threshold:\n            phase = 1\n            threshold = 0.9 * capacity\n\n    return new_solution\n\n",
        "score": [
            -0.8235029335893524,
            4.612982898950577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate hybrid score combining normalized objectives and variance\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    variance = np.var(norm_obj, axis=0)\n    scores = np.sum(norm_obj * variance, axis=1) / (np.array([np.sum(weight_lst * sol) for sol, _ in archive]) + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-entropy scores for both objectives\n    v1_entropy = -np.sum(np.log(value1_lst + 1) * value1_lst / np.sum(value1_lst))\n    v2_entropy = -np.sum(np.log(value2_lst + 1) * value2_lst / np.sum(value2_lst))\n    v1_score = value1_lst * (1 + v1_entropy)\n    v2_score = value2_lst * (1 + v2_entropy)\n    flip_candidates = np.argsort(v1_score + v2_score)[::-1]\n\n    # Dynamic weight adjustment phase\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    threshold = 0.6 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adjust phase based on current weight\n        if current_weight > threshold:\n            phase = 1\n            threshold = 0.9 * capacity\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive by analyzing the Pareto front's curvature and item dominance, then generates a neighbor by strategically flipping items based on a novel \"objective gap-aware\" heuristic that prioritizes items with high potential to bridge the gap between the current solution and the ideal point, while ensuring feasibility through a dynamic weight adjustment process that maintains solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate Pareto front curvature and ideal point\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    ideal1, ideal2 = np.max(obj1), np.max(obj2)\n\n    # Select solution with highest gap to ideal point\n    gaps = (ideal1 - obj1) + (ideal2 - obj2)\n    selected_idx = np.argmax(gaps)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective gaps for each item\n    current_obj1 = np.sum(value1_lst * new_solution)\n    current_obj2 = np.sum(value2_lst * new_solution)\n    gap1 = ideal1 - current_obj1\n    gap2 = ideal2 - current_obj2\n\n    # Calculate item dominance based on gap contribution\n    dominance = (gap1 * value1_lst + gap2 * value2_lst) / (weight_lst + 1e-6)\n    flip_candidates = np.argsort(dominance)[::-1]\n\n    # Dynamic weight adjustment process\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items that bridge the largest gaps\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items that have minimal impact on gap reduction\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.819288836313123,
            2.1394034922122955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate Pareto front curvature and ideal point\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    ideal1, ideal2 = np.max(obj1), np.max(obj2)\n\n    # Select solution with highest gap to ideal point\n    gaps = (ideal1 - obj1) + (ideal2 - obj2)\n    selected_idx = np.argmax(gaps)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective gaps for each item\n    current_obj1 = np.sum(value1_lst * new_solution)\n    current_obj2 = np.sum(value2_lst * new_solution)\n    gap1 = ideal1 - current_obj1\n    gap2 = ideal2 - current_obj2\n\n    # Calculate item dominance based on gap contribution\n    dominance = (gap1 * value1_lst + gap2 * value2_lst) / (weight_lst + 1e-6)\n    flip_candidates = np.argsort(dominance)[::-1]\n\n    # Dynamic weight adjustment process\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items that bridge the largest gaps\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items that have minimal impact on gap reduction\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"trade-off dominance\" score that combines both objective values and their ratios, then generates a neighbor by strategically flipping items using a hybrid approach that prioritizes items with high potential to improve both objectives while dynamically adjusting for capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate trade-off dominance score for each solution\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    trade_off = (obj1 + obj2) / (np.abs(obj1 - obj2) + 1e-6)\n    selected_idx = np.argmax(trade_off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid dominance score\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    hybrid_score = (v1_ratio + v2_ratio) * (1 - np.abs(v1_ratio - v2_ratio))\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high hybrid score\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low hybrid score\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(hybrid_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.964306300882511,
            1.8897600769996643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate trade-off dominance score for each solution\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    trade_off = (obj1 + obj2) / (np.abs(obj1 - obj2) + 1e-6)\n    selected_idx = np.argmax(trade_off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid dominance score\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    hybrid_score = (v1_ratio + v2_ratio) * (1 - np.abs(v1_ratio - v2_ratio))\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high hybrid score\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low hybrid score\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(hybrid_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the Pareto front's curvature and applying a novel \"objective-space transformation\" heuristic that dynamically adjusts item selections based on their contribution to both objectives in the transformed space, ensuring feasibility through a multi-phase adjustment process that prioritizes items with high cross-objective leverage while preserving the solution's overall structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with the most balanced objectives (minimizing the angle between objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    angles = np.arctan2(obj2, obj1)\n    selected_idx = np.argmin(np.abs(angles - np.pi/4))  # Prefer solutions near 45-degree angle\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate transformed objective values (rotating objective space by 45 degrees)\n    alpha = np.pi/4\n    transformed_v1 = value1_lst * np.cos(alpha) - value2_lst * np.sin(alpha)\n    transformed_v2 = value1_lst * np.sin(alpha) + value2_lst * np.cos(alpha)\n\n    # Identify items to flip based on transformed objectives\n    combined_transformed = transformed_v1 + transformed_v2\n    flip_candidates = np.argsort(combined_transformed)[::-1]\n\n    # Multi-phase adjustment to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment if over capacity\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_transformed)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.838327690644508,
            1.7068502306938171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with the most balanced objectives (minimizing the angle between objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    angles = np.arctan2(obj2, obj1)\n    selected_idx = np.argmin(np.abs(angles - np.pi/4))  # Prefer solutions near 45-degree angle\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate transformed objective values (rotating objective space by 45 degrees)\n    alpha = np.pi/4\n    transformed_v1 = value1_lst * np.cos(alpha) - value2_lst * np.sin(alpha)\n    transformed_v2 = value1_lst * np.sin(alpha) + value2_lst * np.cos(alpha)\n\n    # Identify items to flip based on transformed objectives\n    combined_transformed = transformed_v1 + transformed_v2\n    flip_candidates = np.argsort(combined_transformed)[::-1]\n\n    # Multi-phase adjustment to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment if over capacity\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_transformed)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8991789642584843,
            6.140114843845367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8824345771684836,
            10.858115285634995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both objective correlations and individual item contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst * np.log1p(value2_lst)\n    v2_synergy = value2_lst * np.log1p(value1_lst)\n    combined_synergy = v1_synergy + v2_synergy\n\n    # Identify items with high synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-based prioritization\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: fine-tune by flipping items based on marginal improvement\n    marginal_improvement = (value1_lst / (weight_lst + 1e-6)) + (value2_lst / (weight_lst + 1e-6))\n    for idx in np.argsort(marginal_improvement)[::-1]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7654969138815503,
            5.220233529806137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst * np.log1p(value2_lst)\n    v2_synergy = value2_lst * np.log1p(value1_lst)\n    combined_synergy = v1_synergy + v2_synergy\n\n    # Identify items with high synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-based prioritization\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: fine-tune by flipping items based on marginal improvement\n    marginal_improvement = (value1_lst / (weight_lst + 1e-6)) + (value2_lst / (weight_lst + 1e-6))\n    for idx in np.argsort(marginal_improvement)[::-1]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering the trade-off between objectives using a novel \"objective dominance ratio\" heuristic, then generates a neighbor by strategically flipping items based on their potential to improve both objectives simultaneously, ensuring feasibility through an adaptive weight adjustment process that prioritizes items with balanced value improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance ratio\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.maximum(objectives[:, 0], objectives[:, 1]) / (np.minimum(objectives[:, 0], objectives[:, 1]) + 1e-6)\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = dominance_scores / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate potential value improvements\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to flip based on balanced value improvement potential\n    v1_improvement = value1_lst / (weight_lst + 1e-6)\n    v2_improvement = value2_lst / (weight_lst + 1e-6)\n    balanced_score = (v1_improvement + v2_improvement) / (1 + np.abs(v1_improvement - v2_improvement))\n    flip_candidates = np.argsort(balanced_score)[::-1]\n\n    # Adaptive flipping to maintain feasibility\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and remaining_capacity + weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9308831062947756,
            4.440081983804703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance ratio\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.maximum(objectives[:, 0], objectives[:, 1]) / (np.minimum(objectives[:, 0], objectives[:, 1]) + 1e-6)\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = dominance_scores / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate potential value improvements\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to flip based on balanced value improvement potential\n    v1_improvement = value1_lst / (weight_lst + 1e-6)\n    v2_improvement = value2_lst / (weight_lst + 1e-6)\n    balanced_score = (v1_improvement + v2_improvement) / (1 + np.abs(v1_improvement - v2_improvement))\n    flip_candidates = np.argsort(balanced_score)[::-1]\n\n    # Adaptive flipping to maintain feasibility\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and remaining_capacity + weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"trade-off balance\" score that considers both objective values and their relative improvements, then generates a neighbor by strategically flipping items based on a \"value-efficiency\" heuristic that prioritizes items with high potential to improve both objectives proportionally, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with best trade-off balance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance_score = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value efficiency\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    combined_efficiency = v1_efficiency + v2_efficiency\n\n    # Identify items with high potential\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high efficiency\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low efficiency\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9214563459811487,
            1.9039237201213837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with best trade-off balance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance_score = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value efficiency\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    combined_efficiency = v1_efficiency + v2_efficiency\n\n    # Identify items with high potential\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high efficiency\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low efficiency\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in both objectives and its potential for improvement, then generates a neighbor by strategically flipping items using a hybrid approach that combines value-weight ratios with a novel \"objective-space clustering\" heuristic to identify high-potential items for local improvement while maintaining feasibility through a capacity-aware two-phase adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios and objective-space clustering\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    v1_norm = (v1_ratio - np.mean(v1_ratio)) / (np.std(v1_ratio) + 1e-6)\n    v2_norm = (v2_ratio - np.mean(v2_ratio)) / (np.std(v2_ratio) + 1e-6)\n    cluster_scores = np.abs(v1_norm - v2_norm)\n\n    # Identify items to flip based on clustering and ratios\n    flip_candidates = np.argsort(cluster_scores)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8861061712158215,
            5.005724221467972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios and objective-space clustering\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    v1_norm = (v1_ratio - np.mean(v1_ratio)) / (np.std(v1_ratio) + 1e-6)\n    v2_norm = (v2_ratio - np.mean(v2_ratio)) / (np.std(v2_ratio) + 1e-6)\n    cluster_scores = np.abs(v1_norm - v2_norm)\n\n    # Identify items to flip based on clustering and ratios\n    flip_candidates = np.argsort(cluster_scores)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"pareto-frontier proximity\" heuristic that prioritizes items that lie close to the current solution's pareto-frontier, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest pareto-frontier proximity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    # Normalize objectives\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    # Calculate distance to pareto-frontier (approximated by max-min)\n    pareto_dist = np.maximum(obj1_norm, obj2_norm) - np.minimum(obj1_norm, obj2_norm)\n    selected_idx = np.argmax(pareto_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate pareto-frontier proximity for items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    v1_norm = (v1_ratio - np.min(v1_ratio)) / (np.max(v1_ratio) - np.min(v1_ratio) + 1e-6)\n    v2_norm = (v2_ratio - np.min(v2_ratio)) / (np.max(v2_ratio) - np.min(v2_ratio) + 1e-6)\n    item_pareto_dist = np.maximum(v1_norm, v2_norm) - np.minimum(v1_norm, v2_norm)\n    flip_candidates = np.argsort(item_pareto_dist)[::-1]\n\n    # Dynamic capacity-aware flipping with pareto consideration\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items closest to pareto-frontier\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items farthest from pareto-frontier\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(item_pareto_dist)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6590261086794733,
            2.9716658294200897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest pareto-frontier proximity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    # Normalize objectives\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    # Calculate distance to pareto-frontier (approximated by max-min)\n    pareto_dist = np.maximum(obj1_norm, obj2_norm) - np.minimum(obj1_norm, obj2_norm)\n    selected_idx = np.argmax(pareto_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate pareto-frontier proximity for items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    v1_norm = (v1_ratio - np.min(v1_ratio)) / (np.max(v1_ratio) - np.min(v1_ratio) + 1e-6)\n    v2_norm = (v2_ratio - np.min(v2_ratio)) / (np.max(v2_ratio) - np.min(v2_ratio) + 1e-6)\n    item_pareto_dist = np.maximum(v1_norm, v2_norm) - np.minimum(v1_norm, v2_norm)\n    flip_candidates = np.argsort(item_pareto_dist)[::-1]\n\n    # Dynamic capacity-aware flipping with pareto consideration\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items closest to pareto-frontier\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items farthest from pareto-frontier\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(item_pareto_dist)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high \"objective balance\" (measured by the variance between the two objectives), then generates a neighbor by strategically flipping items based on a novel \"multi-objective efficiency frontier\" heuristic that identifies items that lie on the Pareto frontier of both objectives, ensuring feasibility through a dynamic trade-off analysis that balances both objectives while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (variance between objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.var([obj1, obj2], axis=0)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective efficiency frontier\n    efficiency = (value1_lst / (weight_lst + 1e-6)) + (value2_lst / (weight_lst + 1e-6))\n    frontier_items = np.argsort(efficiency)[::-1]\n\n    # Dynamic trade-off analysis\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items on efficiency frontier\n    for idx in frontier_items:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items not on frontier if over capacity\n    if remaining_capacity < 0:\n        non_frontier = np.setdiff1d(np.arange(len(weight_lst)), frontier_items)\n        for idx in non_frontier:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8925995456083293,
            2.495395988225937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (variance between objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.var([obj1, obj2], axis=0)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective efficiency frontier\n    efficiency = (value1_lst / (weight_lst + 1e-6)) + (value2_lst / (weight_lst + 1e-6))\n    frontier_items = np.argsort(efficiency)[::-1]\n\n    # Dynamic trade-off analysis\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items on efficiency frontier\n    for idx in frontier_items:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items not on frontier if over capacity\n    if remaining_capacity < 0:\n        non_frontier = np.setdiff1d(np.arange(len(weight_lst)), frontier_items)\n        for idx in non_frontier:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This algorithm selects a solution from the archive by identifying those with the highest potential for improvement through a novel \"objective synergy\" metric that combines value ratios and weight efficiency, then generates a neighbor by strategically flipping items based on their contribution to both objectives, while dynamically adjusting for capacity constraints through an iterative refinement process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective synergy metric\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 * obj2) / (weight_lst.sum() * (obj1 + obj2 + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Identify flip candidates based on combined ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high value ratios\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low value ratios if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Final adjustment: flip one item to explore neighborhood\n    if len(flip_candidates) > 0:\n        flip_idx = flip_candidates[0]\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9614319002497607,
            2.2196278870105743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective synergy metric\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 * obj2) / (weight_lst.sum() * (obj1 + obj2 + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Identify flip candidates based on combined ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high value ratios\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low value ratios if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Final adjustment: flip one item to explore neighborhood\n    if len(flip_candidates) > 0:\n        flip_idx = flip_candidates[0]\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both individual and combined objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective improvement potential\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    normalized_obj1 = obj1 / (weights + 1e-6)\n    normalized_obj2 = obj2 / (weights + 1e-6)\n    improvement_potential = (normalized_obj1 + normalized_obj2) / (np.maximum(normalized_obj1, normalized_obj2) + 1e-6)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy metric\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    synergy_metric = (v1_synergy * v2_synergy) / (np.maximum(v1_synergy, v2_synergy) + 1e-6)\n\n    # Identify items with high synergy potential\n    flip_candidates = np.argsort(synergy_metric)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy consideration\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy_metric)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: balance objectives by flipping items near Pareto frontier\n    if np.random.rand() > 0.5:\n        balance_candidates = np.argsort(np.abs(v1_synergy - v2_synergy))\n        for idx in balance_candidates:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8982227073141975,
            4.524333357810974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective improvement potential\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    normalized_obj1 = obj1 / (weights + 1e-6)\n    normalized_obj2 = obj2 / (weights + 1e-6)\n    improvement_potential = (normalized_obj1 + normalized_obj2) / (np.maximum(normalized_obj1, normalized_obj2) + 1e-6)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy metric\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    synergy_metric = (v1_synergy * v2_synergy) / (np.maximum(v1_synergy, v2_synergy) + 1e-6)\n\n    # Identify items with high synergy potential\n    flip_candidates = np.argsort(synergy_metric)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy consideration\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy_metric)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: balance objectives by flipping items near Pareto frontier\n    if np.random.rand() > 0.5:\n        balance_candidates = np.argsort(np.abs(v1_synergy - v2_synergy))\n        for idx in balance_candidates:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between objectives and their normalized value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective balance\" heuristic that prioritizes items with high potential to improve both objectives while considering their individual contributions, ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 / (np.sum(obj1) + 1e-6)) / (obj2 / (np.sum(obj2) + 1e-6) + 1e-6)\n    selected_idx = np.argmin(np.abs(balance - 1))  # Select solution closest to balanced objectives\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized objective contributions\n    v1_norm = value1_lst / (np.sum(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.sum(value2_lst) + 1e-6)\n    vw_ratio1 = v1_norm / (weight_lst + 1e-6)\n    vw_ratio2 = v2_norm / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_ratio = vw_ratio1 + vw_ratio2\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high combined ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8311929293981609,
            2.4262052476406097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 / (np.sum(obj1) + 1e-6)) / (obj2 / (np.sum(obj2) + 1e-6) + 1e-6)\n    selected_idx = np.argmin(np.abs(balance - 1))  # Select solution closest to balanced objectives\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized objective contributions\n    v1_norm = value1_lst / (np.sum(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.sum(value2_lst) + 1e-6)\n    vw_ratio1 = v1_norm / (weight_lst + 1e-6)\n    vw_ratio2 = v2_norm / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_ratio = vw_ratio1 + vw_ratio2\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high combined ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8067134388415755,
            2.063385307788849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the geometric median of objectives and item contributions, then generates a neighbor by strategically flipping items based on a novel \"objective-centroid alignment\" heuristic that prioritizes items that align with the centroid of the Pareto front, while ensuring feasibility through a centroid-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective centroid\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    centroid_obj1 = np.mean(obj1)\n    centroid_obj2 = np.mean(obj2)\n\n    # Select solution closest to the centroid\n    distances = np.sqrt((obj1 - centroid_obj1)**2 + (obj2 - centroid_obj2)**2)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item contributions to centroid alignment\n    selected_items = np.where(base_solution == 1)[0]\n    unselected_items = np.where(base_solution == 0)[0]\n\n    # Calculate potential alignment scores\n    alignment_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Score for removing item\n            new_obj1 = obj1[selected_idx] - value1_lst[i]\n            new_obj2 = obj2[selected_idx] - value2_lst[i]\n            alignment_scores[i] = -np.sqrt((new_obj1 - centroid_obj1)**2 + (new_obj2 - centroid_obj2)**2)\n        else:\n            # Score for adding item\n            new_obj1 = obj1[selected_idx] + value1_lst[i]\n            new_obj2 = obj2[selected_idx] + value2_lst[i]\n            alignment_scores[i] = -np.sqrt((new_obj1 - centroid_obj1)**2 + (new_obj2 - centroid_obj2)**2)\n\n    # Sort items by alignment scores\n    flip_candidates = np.argsort(alignment_scores)\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items that best align with centroid\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items that least align with centroid\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in reversed(flip_candidates):\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8058395921567932,
            9.488833159208298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective centroid\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    centroid_obj1 = np.mean(obj1)\n    centroid_obj2 = np.mean(obj2)\n\n    # Select solution closest to the centroid\n    distances = np.sqrt((obj1 - centroid_obj1)**2 + (obj2 - centroid_obj2)**2)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item contributions to centroid alignment\n    selected_items = np.where(base_solution == 1)[0]\n    unselected_items = np.where(base_solution == 0)[0]\n\n    # Calculate potential alignment scores\n    alignment_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Score for removing item\n            new_obj1 = obj1[selected_idx] - value1_lst[i]\n            new_obj2 = obj2[selected_idx] - value2_lst[i]\n            alignment_scores[i] = -np.sqrt((new_obj1 - centroid_obj1)**2 + (new_obj2 - centroid_obj2)**2)\n        else:\n            # Score for adding item\n            new_obj1 = obj1[selected_idx] + value1_lst[i]\n            new_obj2 = obj2[selected_idx] + value2_lst[i]\n            alignment_scores[i] = -np.sqrt((new_obj1 - centroid_obj1)**2 + (new_obj2 - centroid_obj2)**2)\n\n    # Sort items by alignment scores\n    flip_candidates = np.argsort(alignment_scores)\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items that best align with centroid\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items that least align with centroid\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in reversed(flip_candidates):\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8564904961203347,
            10.390641450881958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance rank and objective diversity, then generates a neighbor by flipping items with high cross-objective value ratios while maintaining feasibility through a capacity-aware two-phase adjustment process that prioritizes items with complementary value profiles.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance rank and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1] and\n                          (objectives[j][0] > objectives[i][0] or objectives[j][1] > objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            ranks[i] = 1\n    diversity = np.std(objectives, axis=0)\n    scores = ranks * (diversity[0] + diversity[1])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio + v2_ratio) * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Identify flip candidates based on cross-objective value and weight\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9697062845190253,
            5.739321559667587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance rank and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1] and\n                          (objectives[j][0] > objectives[i][0] or objectives[j][1] > objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            ranks[i] = 1\n    diversity = np.std(objectives, axis=0)\n    scores = ranks * (diversity[0] + diversity[1])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio + v2_ratio) * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Identify flip candidates based on cross-objective value and weight\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a solution from the archive by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives while maintaining feasibility through a dynamic capacity-aware adjustment process that considers both individual and combined objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    combined_synergy = (v1_synergy + v2_synergy) * (1 + np.abs(np.corrcoef(v1_synergy, v2_synergy)[0, 1]))\n\n    # Identify items to flip based on synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final check to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9042507260879054,
            3.989087849855423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    combined_synergy = (v1_synergy + v2_synergy) * (1 + np.abs(np.corrcoef(v1_synergy, v2_synergy)[0, 1]))\n\n    # Identify items to flip based on synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final check to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance ratio\" score that balances both objectives, then generates a neighbor by flipping items using a \"value-to-weight dominance\" heuristic, ensuring feasibility through a dynamic capacity-aware adjustment process that prioritizes items with high cross-objective trade-off potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance ratio\n    objectives = np.array([obj for _, obj in archive])\n    v1_ratio = objectives[:, 0] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    v2_ratio = objectives[:, 1] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    dominance_ratio = np.abs(v1_ratio - v2_ratio) / (np.maximum(v1_ratio, v2_ratio) + 1e-6)\n    selected_idx = np.argmax(dominance_ratio)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    combined_dominance = (v1_dominance + v2_dominance) / (np.abs(v1_dominance - v2_dominance) + 1e-6)\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_direction = 1 if current_weight < 0.5 * capacity else -1\n\n    for idx in flip_candidates:\n        if flip_direction == 1:  # Adding items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Removing items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adjust flip direction based on capacity utilization\n        if flip_direction == 1 and current_weight > 0.8 * capacity:\n            flip_direction = -1\n        elif flip_direction == -1 and current_weight < 0.3 * capacity:\n            flip_direction = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8353638155188553,
            2.930378019809723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance ratio\n    objectives = np.array([obj for _, obj in archive])\n    v1_ratio = objectives[:, 0] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    v2_ratio = objectives[:, 1] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    dominance_ratio = np.abs(v1_ratio - v2_ratio) / (np.maximum(v1_ratio, v2_ratio) + 1e-6)\n    selected_idx = np.argmax(dominance_ratio)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    combined_dominance = (v1_dominance + v2_dominance) / (np.abs(v1_dominance - v2_dominance) + 1e-6)\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_direction = 1 if current_weight < 0.5 * capacity else -1\n\n    for idx in flip_candidates:\n        if flip_direction == 1:  # Adding items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Removing items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adjust flip direction based on capacity utilization\n        if flip_direction == 1 and current_weight > 0.8 * capacity:\n            flip_direction = -1\n        elif flip_direction == -1 and current_weight < 0.3 * capacity:\n            flip_direction = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution with the highest combined normalized objective scores, then generates a neighbor by strategically flipping items based on their potential to improve both objectives while considering their weight efficiency, using a hybrid approach of value-weighted dominance and capacity-aware swapping to ensure feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective scores\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = obj1 / (np.max(obj1) + 1e-6)\n    normalized_obj2 = obj2 / (np.max(obj2) + 1e-6)\n    combined_score = normalized_obj1 + normalized_obj2\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weighted dominance scores\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    combined_efficiency = v1_efficiency + v2_efficiency\n\n    # Identify items to potentially flip\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Hybrid local search: capacity-aware swapping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high efficiency\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: swap items to improve both objectives\n    if remaining_capacity > 0:\n        for idx in flip_candidates:\n            if new_solution[idx] == 1:\n                # Find item to swap out\n                swap_candidates = np.where(new_solution == 1)[0]\n                for swap_idx in swap_candidates:\n                    if (weight_lst[idx] - weight_lst[swap_idx]) <= remaining_capacity:\n                        new_solution[swap_idx] = 0\n                        new_solution[idx] = 1\n                        remaining_capacity -= (weight_lst[idx] - weight_lst[swap_idx])\n                        break\n\n    # Final check for feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest efficiency\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8562713340434038,
            6.189995348453522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective scores\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = obj1 / (np.max(obj1) + 1e-6)\n    normalized_obj2 = obj2 / (np.max(obj2) + 1e-6)\n    combined_score = normalized_obj1 + normalized_obj2\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weighted dominance scores\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    combined_efficiency = v1_efficiency + v2_efficiency\n\n    # Identify items to potentially flip\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Hybrid local search: capacity-aware swapping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high efficiency\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: swap items to improve both objectives\n    if remaining_capacity > 0:\n        for idx in flip_candidates:\n            if new_solution[idx] == 1:\n                # Find item to swap out\n                swap_candidates = np.where(new_solution == 1)[0]\n                for swap_idx in swap_candidates:\n                    if (weight_lst[idx] - weight_lst[swap_idx]) <= remaining_capacity:\n                        new_solution[swap_idx] = 0\n                        new_solution[idx] = 1\n                        remaining_capacity -= (weight_lst[idx] - weight_lst[swap_idx])\n                        break\n\n    # Final check for feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest efficiency\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective balance\" metric that considers both the current solution's objective values and their potential for improvement, then generates a neighbor by strategically flipping items using a hybrid approach that combines dominance-based selection with capacity-aware adjustment, ensuring feasibility through iterative refinement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance scores\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    combined_balance = v1_balance + v2_balance\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: swap items for better balance\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            for j in range(len(weight_lst)):\n                if new_solution[j] == 0 and (weight_lst[j] - weight_lst[i]) <= remaining_capacity:\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n                    remaining_capacity += (weight_lst[i] - weight_lst[j])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7116457267070744,
            6.562564551830292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance scores\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    combined_balance = v1_balance + v2_balance\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: swap items for better balance\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            for j in range(len(weight_lst)):\n                if new_solution[j] == 0 and (weight_lst[j] - weight_lst[i]) <= remaining_capacity:\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n                    remaining_capacity += (weight_lst[i] - weight_lst[j])\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"value-to-weight dominance\" score that combines both objectives with adaptive weights, then generates a neighbor by strategically flipping items based on a hybrid \"objective space dominance\" heuristic, ensuring feasibility through a probabilistic two-phase adjustment process that prioritizes items with high cross-objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance score for each solution\n    objectives = np.array([(obj[0], obj[1]) for _, obj in archive])\n    max_v1, max_v2 = np.max(objectives, axis=0)\n    dominance_scores = np.zeros(len(archive))\n\n    for i, (v1, v2) in enumerate(objectives):\n        dominance_scores[i] = (v1 / (max_v1 + 1e-6)) * (v2 / (max_v2 + 1e-6))\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid dominance metric\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    hybrid_dominance = (v1_dominance + v2_dominance) * np.maximum(v1_dominance, v2_dominance)\n\n    # Sort items by hybrid dominance\n    flip_candidates = np.argsort(hybrid_dominance)[::-1]\n\n    # Two-phase probabilistic adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                if np.random.rand() < 0.7:  # 70% chance to add high-dominance item\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove item\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8953052534707614,
            3.5109003484249115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance score for each solution\n    objectives = np.array([(obj[0], obj[1]) for _, obj in archive])\n    max_v1, max_v2 = np.max(objectives, axis=0)\n    dominance_scores = np.zeros(len(archive))\n\n    for i, (v1, v2) in enumerate(objectives):\n        dominance_scores[i] = (v1 / (max_v1 + 1e-6)) * (v2 / (max_v2 + 1e-6))\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid dominance metric\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    hybrid_dominance = (v1_dominance + v2_dominance) * np.maximum(v1_dominance, v2_dominance)\n\n    # Sort items by hybrid dominance\n    flip_candidates = np.argsort(hybrid_dominance)[::-1]\n\n    # Two-phase probabilistic adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                if np.random.rand() < 0.7:  # 70% chance to add high-dominance item\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove item\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7998557713722014,
            5.856144577264786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9372646690826618,
            5.467159777879715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping with probabilistic selection\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add high-dominance item\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove low-dominance item\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    # Third pass: swap items with high dominance for low dominance\n    if np.random.rand() < 0.5:  # 50% chance to perform swaps\n        swap_candidates = np.argsort(np.abs(v1_dominance - v2_dominance))[::-1]\n        for idx in swap_candidates:\n            if new_solution[idx] == 1:\n                # Find an item to swap with\n                for j in range(len(weight_lst)):\n                    if new_solution[j] == 0 and weight_lst[j] <= weight_lst[idx] + remaining_capacity:\n                        new_solution[idx] = 0\n                        new_solution[j] = 1\n                        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7671227565149524,
            8.816376388072968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping with probabilistic selection\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add high-dominance item\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove low-dominance item\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    # Third pass: swap items with high dominance for low dominance\n    if np.random.rand() < 0.5:  # 50% chance to perform swaps\n        swap_candidates = np.argsort(np.abs(v1_dominance - v2_dominance))[::-1]\n        for idx in swap_candidates:\n            if new_solution[idx] == 1:\n                # Find an item to swap with\n                for j in range(len(weight_lst)):\n                    if new_solution[j] == 0 and weight_lst[j] <= weight_lst[idx] + remaining_capacity:\n                        new_solution[idx] = 0\n                        new_solution[j] = 1\n                        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and their diversity, then generates a neighbor by strategically flipping items using a novel \"objective synergy\" heuristic, ensuring feasibility through a dynamic capacity adjustment process that prioritizes items with high cross-objective improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest weighted objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.abs(objectives[:, 0] - objectives[:, 1]) / (np.sum(objectives, axis=1) + 1e-6)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst * (1 + np.abs(np.corrcoef(value1_lst, value2_lst)[0, 1]))\n    v2_synergy = value2_lst * (1 + np.abs(np.corrcoef(value1_lst, value2_lst)[0, 1]))\n    synergy_scores = (v1_synergy + v2_synergy) / (weight_lst + 1e-6)\n\n    # Identify items to flip based on synergy and current solution\n    flip_candidates = np.argsort(synergy_scores * (1 - new_solution))[::-1]\n\n    # Dynamic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    target_weight = min(capacity, current_weight + 0.3 * capacity)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= target_weight:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight > target_weight:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8548837992279368,
            5.64128252863884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest weighted objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.abs(objectives[:, 0] - objectives[:, 1]) / (np.sum(objectives, axis=1) + 1e-6)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst * (1 + np.abs(np.corrcoef(value1_lst, value2_lst)[0, 1]))\n    v2_synergy = value2_lst * (1 + np.abs(np.corrcoef(value1_lst, value2_lst)[0, 1]))\n    synergy_scores = (v1_synergy + v2_synergy) / (weight_lst + 1e-6)\n\n    # Identify items to flip based on synergy and current solution\n    flip_candidates = np.argsort(synergy_scores * (1 - new_solution))[::-1]\n\n    # Dynamic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    target_weight = min(capacity, current_weight + 0.3 * capacity)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= target_weight:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight > target_weight:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective dominance score that combines normalized objective values with their variance, then generates a neighbor by strategically flipping items with high cross-objective variance and low weight, ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores based on normalized objectives and their variance\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / (max_values + 1e-6)\n    variance = np.var(normalized, axis=0)\n    dominance_scores = np.sum(normalized * variance, axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective variance and weight-adjusted scores\n    v1_normalized = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_normalized = value2_lst / (np.max(value2_lst) + 1e-6)\n    cross_variance = np.abs(v1_normalized - v2_normalized)\n    weight_adjusted = cross_variance / (weight_lst + 1e-6)\n    flip_candidates = np.argsort(weight_adjusted)[::-1]\n\n    # Dynamic flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7385721168775528,
            3.8173285126686096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores based on normalized objectives and their variance\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / (max_values + 1e-6)\n    variance = np.var(normalized, axis=0)\n    dominance_scores = np.sum(normalized * variance, axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective variance and weight-adjusted scores\n    v1_normalized = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_normalized = value2_lst / (np.max(value2_lst) + 1e-6)\n    cross_variance = np.abs(v1_normalized - v2_normalized)\n    weight_adjusted = cross_variance / (weight_lst + 1e-6)\n    flip_candidates = np.argsort(weight_adjusted)[::-1]\n\n    # Dynamic flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8414250117481529,
            5.568859249353409
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance score and value-weight ratios, then generates a neighbor by strategically flipping items using a hybrid of dominance-based selection and value-weight ratio prioritization, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores for each solution in the archive\n    dominance_scores = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        score = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j:\n                if obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1]:\n                    score += 1\n        dominance_scores.append(score)\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios and their product\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    product_ratio = v1_ratio * v2_ratio\n\n    # Identify items to flip based on dominance and product ratio\n    flip_candidates = np.argsort(product_ratio)[::-1]\n\n    # Dynamic flipping strategy based on remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            remaining_capacity = capacity - current_weight\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:  # 30% chance to remove items\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            remaining_capacity = capacity - current_weight\n\n    return new_solution\n\n",
        "score": [
            -0.46944001559824533,
            3.7225972712039948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores for each solution in the archive\n    dominance_scores = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        score = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j:\n                if obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1]:\n                    score += 1\n        dominance_scores.append(score)\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios and their product\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    product_ratio = v1_ratio * v2_ratio\n\n    # Identify items to flip based on dominance and product ratio\n    flip_candidates = np.argsort(product_ratio)[::-1]\n\n    # Dynamic flipping strategy based on remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            remaining_capacity = capacity - current_weight\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:  # 30% chance to remove items\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            remaining_capacity = capacity - current_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9634840349609798,
            2.096929758787155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic trade-off between objectives, then generates a neighbor by strategically flipping items that balance both objectives using a novel \"objective synergy\" heuristic, ensuring feasibility through an adaptive capacity adjustment process that prioritizes items with complementary value profiles.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with dynamic trade-off between objectives\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n\n    # Dynamic trade-off factor based on archive diversity\n    v1_std = np.std(v1_scores)\n    v2_std = np.std(v2_scores)\n    tradeoff = v1_std / (v1_std + v2_std + 1e-6)\n\n    scores = tradeoff * v1_scores + (1 - tradeoff) * v2_scores\n    scores = scores / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    synergy = (v1_norm * v2_norm) * (1 + np.abs(v1_norm - v2_norm))\n\n    # Identify items to flip based on synergy and current solution\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_candidates = np.argsort(synergy * (1 - new_solution))[::-1]\n\n    # Adaptive flipping process\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8859688512702091,
            5.3108702301979065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with dynamic trade-off between objectives\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n\n    # Dynamic trade-off factor based on archive diversity\n    v1_std = np.std(v1_scores)\n    v2_std = np.std(v2_scores)\n    tradeoff = v1_std / (v1_std + v2_std + 1e-6)\n\n    scores = tradeoff * v1_scores + (1 - tradeoff) * v2_scores\n    scores = scores / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    synergy = (v1_norm * v2_norm) * (1 + np.abs(v1_norm - v2_norm))\n\n    # Identify items to flip based on synergy and current solution\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_candidates = np.argsort(synergy * (1 - new_solution))[::-1]\n\n    # Adaptive flipping process\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel dominance score that combines normalized objective values with weight efficiency, then generates a neighbor by strategically flipping items using a two-phase approach that prioritizes items with high cross-objective value-to-weight ratios, ensuring feasibility through dynamic capacity thresholds.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance score combining normalized objectives and weight efficiency\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-6)\n    dominance_scores = np.sum(normalized_obj, axis=1) * (1 / (np.sum([np.sum(weight_lst * sol) for sol, _ in archive], axis=0) + 1e-6))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio + v2_ratio) * np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1])\n\n    # Two-phase flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Dynamic phase transition based on weight utilization\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8343092515921424,
            6.879869639873505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance score combining normalized objectives and weight efficiency\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-6)\n    dominance_scores = np.sum(normalized_obj, axis=1) * (1 / (np.sum([np.sum(weight_lst * sol) for sol, _ in archive], axis=0) + 1e-6))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio + v2_ratio) * np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1])\n\n    # Two-phase flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Dynamic phase transition based on weight utilization\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This algorithm selects a solution from the archive by identifying the one with the highest \"objective diversity\" (difference between objectives), then generates a neighbor by strategically flipping items based on their \"cross-objective contribution\" (product of normalized value1 and value2 ratios), ensuring feasibility through a probabilistic acceptance mechanism that allows controlled exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.abs(obj1 - obj2)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective contribution scores\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    contribution = norm_value1 * norm_value2\n    flip_candidates = np.argsort(contribution)[::-1]\n\n    # Probabilistic acceptance mechanism\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    temperature = 0.1 * capacity  # Controls exploration\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            # Always accept if feasible\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Accept with probability based on contribution and temperature\n            if np.random.rand() < np.exp(-contribution[idx] / temperature):\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3196695453507743,
            6.825987607240677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.abs(obj1 - obj2)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective contribution scores\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-6)\n    contribution = norm_value1 * norm_value2\n    flip_candidates = np.argsort(contribution)[::-1]\n\n    # Probabilistic acceptance mechanism\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    temperature = 0.1 * capacity  # Controls exploration\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            # Always accept if feasible\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Accept with probability based on contribution and temperature\n            if np.random.rand() < np.exp(-contribution[idx] / temperature):\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that alternates between adding and removing items based on their cross-objective impact.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    normalized_obj1 = obj1 / (max_obj1 + 1e-6)\n    normalized_obj2 = obj2 / (max_obj2 + 1e-6)\n    synergy = normalized_obj1 * normalized_obj2\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores for items\n    v1_synergy = value1_lst * (value2_lst / (weight_lst + 1e-6))\n    v2_synergy = value2_lst * (value1_lst / (weight_lst + 1e-6))\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Alternate phases based on capacity usage\n        if remaining_capacity < 0.3 * capacity:\n            phase = 1\n        elif remaining_capacity > 0.7 * capacity:\n            phase = 0\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7762659643975008,
            3.210504502058029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    normalized_obj1 = obj1 / (max_obj1 + 1e-6)\n    normalized_obj2 = obj2 / (max_obj2 + 1e-6)\n    synergy = normalized_obj1 * normalized_obj2\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores for items\n    v1_synergy = value1_lst * (value2_lst / (weight_lst + 1e-6))\n    v2_synergy = value2_lst * (value1_lst / (weight_lst + 1e-6))\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Alternate phases based on capacity usage\n        if remaining_capacity < 0.3 * capacity:\n            phase = 1\n        elif remaining_capacity > 0.7 * capacity:\n            phase = 0\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing items with high cross-objective synergy, then generates a neighbor by strategically flipping items based on a novel \"value-weight dominance\" heuristic, ensuring feasibility through a two-phase adjustment process that alternates between adding and removing items with the highest combined dominance scores.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance scores\n    v1_dominance = value1_lst * (1 / (weight_lst + 1e-6))\n    v2_dominance = value2_lst * (1 / (weight_lst + 1e-6))\n    combined_dominance = v1_dominance + v2_dominance\n\n    # Identify items to flip based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Alternate phases based on remaining capacity\n        if np.random.rand() > 0.5 and current_weight > 0.6 * capacity:\n            phase = 1 - phase\n\n    return new_solution\n\n",
        "score": [
            -0.5465261815300019,
            6.29997918009758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance scores\n    v1_dominance = value1_lst * (1 / (weight_lst + 1e-6))\n    v2_dominance = value2_lst * (1 / (weight_lst + 1e-6))\n    combined_dominance = v1_dominance + v2_dominance\n\n    # Identify items to flip based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Alternate phases based on remaining capacity\n        if np.random.rand() > 0.5 and current_weight > 0.6 * capacity:\n            phase = 1 - phase\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers the correlation between objectives and their marginal contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    synergy = (obj1 / (max_obj1 + 1e-6)) * (obj2 / (max_obj2 + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    current_obj1 = obj1[selected_idx]\n    current_obj2 = obj2[selected_idx]\n    marginal_obj1 = (value1_lst - current_obj1) / (weight_lst + 1e-6)\n    marginal_obj2 = (value2_lst - current_obj2) / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_marginal = marginal_obj1 * marginal_obj2\n    flip_candidates = np.argsort(combined_marginal)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high marginal synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low marginal synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_marginal)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Additional pass: consider objective correlation\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n\n    if correlation > 0.3:  # Strong positive correlation\n        # Try to balance the objectives by flipping items\n        for idx in flip_candidates:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                if (current_obj1 > current_obj2 and marginal_obj1[idx] < marginal_obj2[idx]) or \\\n                   (current_obj2 > current_obj1 and marginal_obj2[idx] < marginal_obj1[idx]):\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8830034449180187,
            5.869237512350082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    synergy = (obj1 / (max_obj1 + 1e-6)) * (obj2 / (max_obj2 + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    current_obj1 = obj1[selected_idx]\n    current_obj2 = obj2[selected_idx]\n    marginal_obj1 = (value1_lst - current_obj1) / (weight_lst + 1e-6)\n    marginal_obj2 = (value2_lst - current_obj2) / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_marginal = marginal_obj1 * marginal_obj2\n    flip_candidates = np.argsort(combined_marginal)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high marginal synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low marginal synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_marginal)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Additional pass: consider objective correlation\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n\n    if correlation > 0.3:  # Strong positive correlation\n        # Try to balance the objectives by flipping items\n        for idx in flip_candidates:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                if (current_obj1 > current_obj2 and marginal_obj1[idx] < marginal_obj2[idx]) or \\\n                   (current_obj2 > current_obj1 and marginal_obj2[idx] < marginal_obj1[idx]):\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight and diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([np.sum(sol) for sol, _ in archive])  # Number of items selected\n    scores = (objectives / (weights + 1e-6)) * (1 + 0.1 * (diversity / len(weight_lst)))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and objective dominance\n    if abs_correlation > 0.3:  # Moderate correlation, prioritize high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives with dominance check\n        if archive[selected_idx][1][0] > archive[selected_idx][1][1]:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility with dynamic threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    threshold = 0.8 * capacity if current_weight < 0.5 * capacity else 0.6 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is near threshold\n        if current_weight > threshold:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7832492590706266,
            7.194798916578293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight and diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([np.sum(sol) for sol, _ in archive])  # Number of items selected\n    scores = (objectives / (weights + 1e-6)) * (1 + 0.1 * (diversity / len(weight_lst)))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and objective dominance\n    if abs_correlation > 0.3:  # Moderate correlation, prioritize high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives with dominance check\n        if archive[selected_idx][1][0] > archive[selected_idx][1][1]:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility with dynamic threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    threshold = 0.8 * capacity if current_weight < 0.5 * capacity else 0.6 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is near threshold\n        if current_weight > threshold:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the Pareto-frontier proximity and item contribution diversity, then generates a neighbor by strategically flipping items based on a novel \"multi-objective contribution index\" that combines normalized objective gains with weight efficiency, while ensuring feasibility through a dynamic resource allocation process that prioritizes items with complementary objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto-frontier proximity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    proximity = (obj1/max_obj1 + obj2/max_obj2) / 2\n    selected_idx = np.argmin(proximity)  # Select least dominated solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective contribution index\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Normalized objective gains\n    norm_v1 = value1_lst / (max_obj1 + 1e-6)\n    norm_v2 = value2_lst / (max_obj2 + 1e-6)\n\n    # Weight efficiency\n    weight_efficiency = (norm_v1 + norm_v2) / (weight_lst + 1e-6)\n\n    # Contribution index: combination of normalized gains and weight efficiency\n    contribution_index = weight_efficiency * (1 + norm_v1 * norm_v2)\n\n    # Dynamic resource allocation\n    flip_candidates = np.argsort(contribution_index)[::-1]\n\n    # First pass: add items with high contribution\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low contribution if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(contribution_index)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8785450958522948,
            2.7827649116516113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto-frontier proximity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    proximity = (obj1/max_obj1 + obj2/max_obj2) / 2\n    selected_idx = np.argmin(proximity)  # Select least dominated solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective contribution index\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Normalized objective gains\n    norm_v1 = value1_lst / (max_obj1 + 1e-6)\n    norm_v2 = value2_lst / (max_obj2 + 1e-6)\n\n    # Weight efficiency\n    weight_efficiency = (norm_v1 + norm_v2) / (weight_lst + 1e-6)\n\n    # Contribution index: combination of normalized gains and weight efficiency\n    contribution_index = weight_efficiency * (1 + norm_v1 * norm_v2)\n\n    # Dynamic resource allocation\n    flip_candidates = np.argsort(contribution_index)[::-1]\n\n    # First pass: add items with high contribution\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low contribution if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(contribution_index)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"multi-objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both objective improvements and weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective improvement potential\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = (obj1 + obj2) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective synergy score\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = v1_ratio * v2_ratio * np.sqrt(value1_lst * value2_lst)\n\n    # Identify items to flip based on synergy score\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic capacity-aware flipping with two phases\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = np.random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.833657112637409,
            4.780043810606003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined normalized objective improvement potential\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = (obj1 + obj2) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective synergy score\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = v1_ratio * v2_ratio * np.sqrt(value1_lst * value2_lst)\n\n    # Identify items to flip based on synergy score\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic capacity-aware flipping with two phases\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = np.random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance\" metric that considers both objective values and their trade-off, then generates a neighbor by strategically flipping items using a \"value-difference\" heuristic to explore Pareto front expansion, while maintaining feasibility through an adaptive weight adjustment process that prioritizes items with high cross-objective trade-off potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0]\n    v2_scores = objectives[:, 1]\n    dominance_scores = (v1_scores / (v2_scores + 1e-6)) * (v2_scores / (v1_scores + 1e-6))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value differences and trade-off potential\n    v1_diff = value1_lst - v1_scores[selected_idx]\n    v2_diff = value2_lst - v2_scores[selected_idx]\n    trade_off = (v1_diff * v2_diff) / (weight_lst + 1e-6)\n\n    # Identify items to flip based on trade-off potential\n    flip_candidates = np.argsort(trade_off)[::-1]\n\n    # Adaptive weight adjustment to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    target_weight = capacity * np.random.uniform(0.6, 0.9)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= target_weight:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        if current_weight >= target_weight:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7698912535705844,
            1.2808305621147156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0]\n    v2_scores = objectives[:, 1]\n    dominance_scores = (v1_scores / (v2_scores + 1e-6)) * (v2_scores / (v1_scores + 1e-6))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value differences and trade-off potential\n    v1_diff = value1_lst - v1_scores[selected_idx]\n    v2_diff = value2_lst - v2_scores[selected_idx]\n    trade_off = (v1_diff * v2_diff) / (weight_lst + 1e-6)\n\n    # Identify items to flip based on trade-off potential\n    flip_candidates = np.argsort(trade_off)[::-1]\n\n    # Adaptive weight adjustment to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    target_weight = capacity * np.random.uniform(0.6, 0.9)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= target_weight:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        if current_weight >= target_weight:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on an innovative \"objective balance\" heuristic that prioritizes items with high potential to improve both objectives proportionally, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (ratio of sum to product)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (obj1 * obj2 + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives proportionally\n    combined_balance = v1_balance + v2_balance\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8724304683802548,
            2.3651762902736664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (ratio of sum to product)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (obj1 * obj2 + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives proportionally\n    combined_balance = v1_balance + v2_balance\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9032602929042496,
            6.655260473489761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the geometric properties of the objective space and item characteristics, then generates a neighbor by strategically flipping items based on a novel \"objective vector alignment\" heuristic that prioritizes items with high potential to improve both objectives while maintaining feasibility through a dynamic geometric adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest geometric potential (angle between objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    angles = np.arctan2(obj2, obj1 + 1e-6)\n    selected_idx = np.argmax(angles)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective vector alignment scores\n    v1_norm = value1_lst / (np.linalg.norm(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.linalg.norm(value2_lst) + 1e-6)\n    alignment = np.abs(v1_norm - v2_norm)\n    flip_candidates = np.argsort(alignment)\n\n    # Dynamic geometric flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high alignment\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low alignment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in flip_candidates[::-1]:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Apply geometric perturbation\n    if np.random.rand() < 0.3:\n        perturbation_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[perturbation_idx] = 0\n        current_weight -= weight_lst[perturbation_idx]\n        if current_weight <= capacity:\n            possible_adds = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n            if len(possible_adds) > 0:\n                add_idx = np.random.choice(possible_adds)\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9507240402980495,
            2.463189274072647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest geometric potential (angle between objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    angles = np.arctan2(obj2, obj1 + 1e-6)\n    selected_idx = np.argmax(angles)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective vector alignment scores\n    v1_norm = value1_lst / (np.linalg.norm(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.linalg.norm(value2_lst) + 1e-6)\n    alignment = np.abs(v1_norm - v2_norm)\n    flip_candidates = np.argsort(alignment)\n\n    # Dynamic geometric flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high alignment\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low alignment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in flip_candidates[::-1]:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Apply geometric perturbation\n    if np.random.rand() < 0.3:\n        perturbation_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[perturbation_idx] = 0\n        current_weight -= weight_lst[perturbation_idx]\n        if current_weight <= capacity:\n            possible_adds = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n            if len(possible_adds) > 0:\n                add_idx = np.random.choice(possible_adds)\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy, while also incorporating a dynamic weighting mechanism to balance exploration and exploitation during the flipping process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weights for objectives based on current solution\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    total_value = current_value1 + current_value2\n    if total_value > 0:\n        weight1 = current_value1 / total_value\n        weight2 = current_value2 / total_value\n    else:\n        weight1, weight2 = 0.5, 0.5\n\n    # Calculate weighted value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    weighted_ratio = weight1 * v1_ratio + weight2 * v2_ratio\n\n    # Identify items to flip based on dynamic weighted ratio\n    flip_candidates = np.argsort(weighted_ratio)[::-1]\n\n    # Two-phase flipping with dynamic adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_count = 0\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                flip_count += 1\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                flip_count += 1\n\n        # Dynamic phase switching based on flip count and capacity utilization\n        if flip_count > 3 or current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest weighted ratio until feasible\n        sorted_indices = np.argsort(weighted_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9022203233744642,
            3.812424600124359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weights for objectives based on current solution\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    total_value = current_value1 + current_value2\n    if total_value > 0:\n        weight1 = current_value1 / total_value\n        weight2 = current_value2 / total_value\n    else:\n        weight1, weight2 = 0.5, 0.5\n\n    # Calculate weighted value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    weighted_ratio = weight1 * v1_ratio + weight2 * v2_ratio\n\n    # Identify items to flip based on dynamic weighted ratio\n    flip_candidates = np.argsort(weighted_ratio)[::-1]\n\n    # Two-phase flipping with dynamic adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_count = 0\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                flip_count += 1\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                flip_count += 1\n\n        # Dynamic phase switching based on flip count and capacity utilization\n        if flip_count > 3 or current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest weighted ratio until feasible\n        sorted_indices = np.argsort(weighted_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.75589922903847,
            5.1319244503974915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing both objective values and their interaction through a novel \"multi-objective trade-off exploration\" heuristic, then generates a neighbor by strategically flipping items based on their ability to balance objective improvements while ensuring feasibility through an adaptive capacity management process that dynamically adjusts based on the current solution's objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    tradeoff = np.abs(obj1 - obj2)\n    selected_idx = np.argmax(tradeoff)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item trade-off scores\n    item_tradeoff = np.abs(value1_lst - value2_lst)\n    item_efficiency = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    combined_score = item_tradeoff * item_efficiency\n\n    # Identify items to flip based on combined score\n    flip_candidates = np.argsort(combined_score)[::-1]\n\n    # Adaptive capacity management\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high trade-off potential\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low trade-off potential\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Final adjustment to ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined score\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            break\n        remove_idx = candidate_items[np.argmin(combined_score[candidate_items])]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7316505622607414,
            10.16039365530014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    tradeoff = np.abs(obj1 - obj2)\n    selected_idx = np.argmax(tradeoff)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item trade-off scores\n    item_tradeoff = np.abs(value1_lst - value2_lst)\n    item_efficiency = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    combined_score = item_tradeoff * item_efficiency\n\n    # Identify items to flip based on combined score\n    flip_candidates = np.argsort(combined_score)[::-1]\n\n    # Adaptive capacity management\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high trade-off potential\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low trade-off potential\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Final adjustment to ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined score\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            break\n        remove_idx = candidate_items[np.argmin(combined_score[candidate_items])]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score combining normalized objective values and their geometric mean, then generates a neighbor by flipping items with high \"value-to-weight\" dominance, using a three-phase adjustment process that balances both objectives through adaptive removal and addition of items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest geometric mean of normalized objectives\n    objectives = np.array([(obj[0], obj[1]) for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-6)\n    geo_mean = np.sqrt(normalized_obj[:, 0] * normalized_obj[:, 1])\n    selected_idx = np.argmax(geo_mean)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight dominance scores\n    v1_dom = value1_lst / (weight_lst + 1e-6)\n    v2_dom = value2_lst / (weight_lst + 1e-6)\n    dom_score = (v1_dom + v2_dom) / 2\n\n    # Three-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: balance objectives\n\n    for idx in np.argsort(dom_score)[::-1]:\n        if phase == 0:  # First try to add high-dominance items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Then try to remove low-dominance items\n            if new_solution[idx] == 1 and dom_score[idx] < np.median(dom_score):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Finally balance objectives by flipping borderline items\n            if new_solution[idx] == 1 and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phases based on capacity utilization\n        if current_weight > 0.6 * capacity and phase == 0:\n            phase = 1\n        elif current_weight > 0.8 * capacity and phase == 1:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.9169920624115186,
            4.022067606449127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest geometric mean of normalized objectives\n    objectives = np.array([(obj[0], obj[1]) for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-6)\n    geo_mean = np.sqrt(normalized_obj[:, 0] * normalized_obj[:, 1])\n    selected_idx = np.argmax(geo_mean)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight dominance scores\n    v1_dom = value1_lst / (weight_lst + 1e-6)\n    v2_dom = value2_lst / (weight_lst + 1e-6)\n    dom_score = (v1_dom + v2_dom) / 2\n\n    # Three-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: balance objectives\n\n    for idx in np.argsort(dom_score)[::-1]:\n        if phase == 0:  # First try to add high-dominance items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Then try to remove low-dominance items\n            if new_solution[idx] == 1 and dom_score[idx] < np.median(dom_score):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Finally balance objectives by flipping borderline items\n            if new_solution[idx] == 1 and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phases based on capacity utilization\n        if current_weight > 0.6 * capacity and phase == 0:\n            phase = 1\n        elif current_weight > 0.8 * capacity and phase == 1:\n            phase = 2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8930150388369783,
            4.9574295580387115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7865657291752117,
            10.17066764831543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance score\" that considers both objective values and their ratio, then generates a neighbor by strategically flipping items with high potential for cross-objective improvement using a two-phase adjustment process that prioritizes items with high value-to-weight ratios while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    dominance_scores = (v1_scores / (v2_scores + 1e-6)) + (v2_scores / (v1_scores + 1e-6))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to flip based on dominance\n    if v1_scores[selected_idx] > v2_scores[selected_idx]:\n        flip_candidates = np.argsort(v1_ratio)[::-1]\n    else:\n        flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8793740675736901,
            1.740551769733429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    dominance_scores = (v1_scores / (v2_scores + 1e-6)) + (v2_scores / (v1_scores + 1e-6))\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to flip based on dominance\n    if v1_scores[selected_idx] > v2_scores[selected_idx]:\n        flip_candidates = np.argsort(v1_ratio)[::-1]\n    else:\n        flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy, and further refines the solution by dynamically adjusting the exploration/exploitation trade-off based on the current solution's dominance properties.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dominance properties\n    dominance_scores = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        dominated = 0\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] >= obj[0] and other_obj[1] >= obj[1] and (other_obj[0] > obj[0] or other_obj[1] > obj[1]):\n                dominated += 1\n        dominance_scores[i] = dominated\n\n    # Adjust exploration/exploitation based on dominance\n    exploration_rate = min(0.9, 0.5 + 0.4 * (dominance_scores[selected_idx] / len(archive)))\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and exploration rate\n    if np.random.rand() < exploration_rate:\n        if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n            combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n            flip_candidates = np.argsort(combined_ratio)[::-1]\n        else:  # Weak correlation, alternate between objectives\n            if np.random.rand() > 0.5:\n                flip_candidates = np.argsort(v1_ratio)[::-1]\n            else:\n                flip_candidates = np.argsort(v2_ratio)[::-1]\n    else:\n        # Exploitation phase: prioritize items that improve both objectives\n        v1_gain = value1_lst * (1 - new_solution) - value1_lst * new_solution\n        v2_gain = value2_lst * (1 - new_solution) - value2_lst * new_solution\n        combined_gain = v1_gain + v2_gain\n        flip_candidates = np.argsort(combined_gain)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    # Dynamic adjustment: flip one random item to escape local optima\n    if np.random.rand() < 0.2:\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0 and current_weight + weight_lst[available_items[0]] <= capacity:\n            new_solution[available_items[0]] = 1\n        else:\n            removed_items = np.where(new_solution == 1)[0]\n            if len(removed_items) > 0:\n                new_solution[removed_items[0]] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9261237033910239,
            6.193866580724716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dominance properties\n    dominance_scores = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        dominated = 0\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] >= obj[0] and other_obj[1] >= obj[1] and (other_obj[0] > obj[0] or other_obj[1] > obj[1]):\n                dominated += 1\n        dominance_scores[i] = dominated\n\n    # Adjust exploration/exploitation based on dominance\n    exploration_rate = min(0.9, 0.5 + 0.4 * (dominance_scores[selected_idx] / len(archive)))\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation and exploration rate\n    if np.random.rand() < exploration_rate:\n        if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n            combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n            flip_candidates = np.argsort(combined_ratio)[::-1]\n        else:  # Weak correlation, alternate between objectives\n            if np.random.rand() > 0.5:\n                flip_candidates = np.argsort(v1_ratio)[::-1]\n            else:\n                flip_candidates = np.argsort(v2_ratio)[::-1]\n    else:\n        # Exploitation phase: prioritize items that improve both objectives\n        v1_gain = value1_lst * (1 - new_solution) - value1_lst * new_solution\n        v2_gain = value2_lst * (1 - new_solution) - value2_lst * new_solution\n        combined_gain = v1_gain + v2_gain\n        flip_candidates = np.argsort(combined_gain)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    # Dynamic adjustment: flip one random item to escape local optima\n    if np.random.rand() < 0.2:\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0 and current_weight + weight_lst[available_items[0]] <= capacity:\n            new_solution[available_items[0]] = 1\n        else:\n            removed_items = np.where(new_solution == 1)[0]\n            if len(removed_items) > 0:\n                new_solution[removed_items[0]] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8351390701345012,
            5.082477867603302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously while ensuring feasibility through a dynamic capacity-aware adjustment process that alternates between adding and removing items based on their cross-objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 / (np.max(obj1) + 1e-6)) * (obj2 / (np.max(obj2) + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores for items\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    w_norm = weight_lst / (np.max(weight_lst) + 1e-6)\n    synergy_scores = (v1_norm * v2_norm) / (w_norm + 1e-6)\n\n    # Identify items to flip based on synergy scores\n    flip_candidates = np.argsort(synergy_scores)[::-1]\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items with high synergy\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items with low synergy\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Alternate phase when capacity is 60% full or empty\n        if (phase == 0 and current_weight > 0.6 * capacity) or (phase == 1 and current_weight < 0.4 * capacity):\n            phase = 1 - phase\n\n    # Final check to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(synergy_scores)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8497467740764656,
            2.7093593776226044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 / (np.max(obj1) + 1e-6)) * (obj2 / (np.max(obj2) + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores for items\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    w_norm = weight_lst / (np.max(weight_lst) + 1e-6)\n    synergy_scores = (v1_norm * v2_norm) / (w_norm + 1e-6)\n\n    # Identify items to flip based on synergy scores\n    flip_candidates = np.argsort(synergy_scores)[::-1]\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items with high synergy\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items with low synergy\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Alternate phase when capacity is 60% full or empty\n        if (phase == 0 and current_weight > 0.6 * capacity) or (phase == 1 and current_weight < 0.4 * capacity):\n            phase = 1 - phase\n\n    # Final check to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(synergy_scores)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance ratio\" heuristic, then generates a neighbor by strategically flipping items using a multi-objective value-density metric, ensuring feasibility through a capacity-aware two-phase adjustment process that prioritizes items with high cross-objective complementarity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance ratio\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(dominance_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective value-density metric\n    value_density1 = value1_lst / (weight_lst + 1e-6)\n    value_density2 = value2_lst / (weight_lst + 1e-6)\n    combined_density = (value_density1 + value_density2) * (1 + np.abs(np.corrcoef(value_density1, value_density2)[0, 1]))\n\n    # Identify flip candidates based on combined density\n    flip_candidates = np.argsort(combined_density)[::-1]\n\n    # Two-phase flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when reaching 60% capacity\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9000729907312092,
            3.4029144942760468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance ratio\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(dominance_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective value-density metric\n    value_density1 = value1_lst / (weight_lst + 1e-6)\n    value_density2 = value2_lst / (weight_lst + 1e-6)\n    combined_density = (value_density1 + value_density2) * (1 + np.abs(np.corrcoef(value_density1, value_density2)[0, 1]))\n\n    # Identify flip candidates based on combined density\n    flip_candidates = np.argsort(combined_density)[::-1]\n\n    # Two-phase flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when reaching 60% capacity\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8554991535894196,
            2.0332261323928833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing both objective values and their trade-offs, then generates a neighbor by strategically flipping items based on a novel \"objective correlation\" heuristic that prioritizes items with high correlation between the two objectives, while ensuring feasibility through a dynamic capacity-aware adjustment process and using a probabilistic selection mechanism to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective correlation\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    selected_idx = np.argmax(np.abs(correlation))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlation scores\n    correlation_scores = (value1_lst - np.mean(value1_lst)) * (value2_lst - np.mean(value2_lst))\n    flip_candidates = np.argsort(correlation_scores)[::-1]\n\n    # Dynamic capacity-aware flipping with probability\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high correlation\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low correlation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(correlation_scores)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% probability to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9293925793296417,
            4.735917150974274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective correlation\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    selected_idx = np.argmax(np.abs(correlation))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlation scores\n    correlation_scores = (value1_lst - np.mean(value1_lst)) * (value2_lst - np.mean(value2_lst))\n    flip_candidates = np.argsort(correlation_scores)[::-1]\n\n    # Dynamic capacity-aware flipping with probability\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high correlation\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low correlation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(correlation_scores)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% probability to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8560225101656578,
            4.97271728515625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8246615008456994,
            5.458629906177521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective balance\" metric, then generates a neighbor by strategically flipping items in a two-phase process that prioritizes items with high value-to-weight ratios for both objectives, while maintaining feasibility through dynamic capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with best objective balance\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    balance_scores = (v1_scores + v2_scores) / (np.abs(v1_scores - v2_scores) + 1e-6)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized value-weight ratios\n    v1_norm = value1_lst / (weight_lst + 1e-6)\n    v2_norm = value2_lst / (weight_lst + 1e-6)\n    combined_norm = (v1_norm + v2_norm) / 2\n\n    # Identify flip candidates based on normalized ratios\n    flip_candidates = np.argsort(combined_norm)[::-1]\n\n    # Two-phase flipping with dynamic capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    threshold = min(0.6 * capacity, current_weight + 0.3 * capacity)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= threshold:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                if current_weight > threshold:\n                    phase = 1\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8739457645689193,
            2.053043454885483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with best objective balance\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    balance_scores = (v1_scores + v2_scores) / (np.abs(v1_scores - v2_scores) + 1e-6)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized value-weight ratios\n    v1_norm = value1_lst / (weight_lst + 1e-6)\n    v2_norm = value2_lst / (weight_lst + 1e-6)\n    combined_norm = (v1_norm + v2_norm) / 2\n\n    # Identify flip candidates based on normalized ratios\n    flip_candidates = np.argsort(combined_norm)[::-1]\n\n    # Two-phase flipping with dynamic capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    threshold = min(0.6 * capacity, current_weight + 0.3 * capacity)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= threshold:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                if current_weight > threshold:\n                    phase = 1\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective weighted by diversity\n    objectives = np.array([(obj[0] * 0.7 + obj[1] * 0.3) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([np.sum(np.abs(sol[0] - sol[1])) for sol, _ in archive])\n    scores = (objectives * diversity) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives with weighted approach\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation with weighted objective importance\n    if abs_correlation > 0.3:  # Moderate correlation, flip items with weighted combined ratio\n        combined_ratio = (v1_ratio * 0.7 + v2_ratio * 0.3) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives with probability\n        if np.random.rand() > 0.6:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping with adaptive capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    adaptive_threshold = max(0.5, 0.9 - (current_weight / capacity))\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is adaptively full\n        if current_weight > adaptive_threshold * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8900128261772718,
            7.60453987121582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective weighted by diversity\n    objectives = np.array([(obj[0] * 0.7 + obj[1] * 0.3) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([np.sum(np.abs(sol[0] - sol[1])) for sol, _ in archive])\n    scores = (objectives * diversity) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives with weighted approach\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation with weighted objective importance\n    if abs_correlation > 0.3:  # Moderate correlation, flip items with weighted combined ratio\n        combined_ratio = (v1_ratio * 0.7 + v2_ratio * 0.3) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives with probability\n        if np.random.rand() > 0.6:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping with adaptive capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    adaptive_threshold = max(0.5, 0.9 - (current_weight / capacity))\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is adaptively full\n        if current_weight > adaptive_threshold * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their normalized value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective-balance\" heuristic that prioritizes items with high potential to improve both objectives proportionally, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 / (obj1 + obj2 + 1e-6)) / (obj2 / (obj1 + obj2 + 1e-6) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives proportionally\n    combined_ratio = v1_ratio + v2_ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8508659629624353,
            10.639089107513428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 / (obj1 + obj2 + 1e-6)) / (obj2 / (obj1 + obj2 + 1e-6) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives proportionally\n    combined_ratio = v1_ratio + v2_ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9416278205997699,
            5.361677467823029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This algorithm selects a solution from the archive by evaluating the balance between objectives and item characteristics, then generates a neighbor by applying a hybrid local search that combines random swaps with value-weighted probabilistic flips, ensuring feasibility through a capacity-aware adjustment process that prioritizes items with high marginal gains in both objectives while maintaining solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective value\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    combined_obj = obj1 + obj2\n    selected_idx = np.argmax(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal gains for both objectives\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Randomly select items to consider for flipping\n    items_to_consider = np.random.permutation(len(weight_lst))[:max(1, len(weight_lst)//4)]\n\n    # Hybrid local search: combine random swaps with probabilistic flips\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: probabilistic flips based on marginal gains\n    for idx in items_to_consider:\n        if np.random.rand() < 0.5 and combined_gain[idx] > np.mean(combined_gain):\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    # Second pass: random swaps to maintain diversity\n    swap_candidates = np.random.permutation(len(weight_lst))[:2]\n    if len(swap_candidates) == 2:\n        i, j = swap_candidates\n        if new_solution[i] != new_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(combined_gain)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and weight_lst[idx] <= excess:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4779295584357337,
            4.884926080703735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective value\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    combined_obj = obj1 + obj2\n    selected_idx = np.argmax(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal gains for both objectives\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Randomly select items to consider for flipping\n    items_to_consider = np.random.permutation(len(weight_lst))[:max(1, len(weight_lst)//4)]\n\n    # Hybrid local search: combine random swaps with probabilistic flips\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: probabilistic flips based on marginal gains\n    for idx in items_to_consider:\n        if np.random.rand() < 0.5 and combined_gain[idx] > np.mean(combined_gain):\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    # Second pass: random swaps to maintain diversity\n    swap_candidates = np.random.permutation(len(weight_lst))[:2]\n    if len(swap_candidates) == 2:\n        i, j = swap_candidates\n        if new_solution[i] != new_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(combined_gain)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and weight_lst[idx] <= excess:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining normalized objectives and weight efficiency, then generates neighbors by flipping items prioritizing those with high cross-objective value-to-weight ratios while maintaining feasibility through a dynamic adjustment phase that alternates between addition and removal based on capacity thresholds.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate hybrid score combining objectives and weight efficiency\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = (objectives * (1.5 - (weights / capacity))) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = (v1_ratio * value2_lst + v2_ratio * value1_lst) / (weight_lst + 1e-6)\n\n    # Select flip candidates based on combined ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic adjustment phase\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove items phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8704481496398779,
            3.752890944480896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate hybrid score combining objectives and weight efficiency\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = (objectives * (1.5 - (weights / capacity))) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-to-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = (v1_ratio * value2_lst + v2_ratio * value1_lst) / (weight_lst + 1e-6)\n\n    # Select flip candidates based on combined ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic adjustment phase\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove items phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive by identifying the most under-explored region in the objective space, then generates a neighbor by strategically flipping items based on a novel \"objective gap\" heuristic that prioritizes items that bridge the largest gaps between current solution values and potential maximum values, while ensuring feasibility through a probabilistic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential maximum values\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n\n    # Find solution with largest objective gaps\n    gaps = []\n    for sol, (obj1, obj2) in archive:\n        gap1 = max_value1 - obj1\n        gap2 = max_value2 - obj2\n        gaps.append(gap1 + gap2)\n    selected_idx = np.argmax(gaps)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective gaps for each item\n    obj1_gaps = value1_lst / (max_value1 + 1e-6)\n    obj2_gaps = value2_lst / (max_value2 + 1e-6)\n    combined_gaps = obj1_gaps + obj2_gaps\n    flip_candidates = np.argsort(combined_gaps)[::-1]\n\n    # Probabilistic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with largest gaps\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with smallest gaps\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_gaps)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% probability to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8543754499521877,
            2.0712657272815704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential maximum values\n    max_value1 = np.sum(value1_lst)\n    max_value2 = np.sum(value2_lst)\n\n    # Find solution with largest objective gaps\n    gaps = []\n    for sol, (obj1, obj2) in archive:\n        gap1 = max_value1 - obj1\n        gap2 = max_value2 - obj2\n        gaps.append(gap1 + gap2)\n    selected_idx = np.argmax(gaps)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective gaps for each item\n    obj1_gaps = value1_lst / (max_value1 + 1e-6)\n    obj2_gaps = value2_lst / (max_value2 + 1e-6)\n    combined_gaps = obj1_gaps + obj2_gaps\n    flip_candidates = np.argsort(combined_gaps)[::-1]\n\n    # Probabilistic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with largest gaps\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with smallest gaps\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_gaps)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% probability to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8769727302427086,
            5.768166929483414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with balanced objective improvements, then generates a neighbor by strategically flipping items based on a novel \"objective divergence\" heuristic that identifies items with potential to improve both objectives while maintaining feasibility through a dynamic capacity-aware two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective divergence (max - min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    divergence = np.maximum(obj1, obj2) - np.minimum(obj1, obj2)\n    selected_idx = np.argmax(divergence)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective divergence ratios\n    v1_divergence = value1_lst / (value2_lst + 1e-6)\n    v2_divergence = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_divergence = v1_divergence + v2_divergence\n    flip_candidates = np.argsort(combined_divergence)[::-1]\n\n    # Dynamic capacity-aware two-phase flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_divergence)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9084278349467578,
            2.1850633323192596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective divergence (max - min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    divergence = np.maximum(obj1, obj2) - np.minimum(obj1, obj2)\n    selected_idx = np.argmax(divergence)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective divergence ratios\n    v1_divergence = value1_lst / (value2_lst + 1e-6)\n    v2_divergence = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_divergence = v1_divergence + v2_divergence\n    flip_candidates = np.argsort(combined_divergence)[::-1]\n\n    # Dynamic capacity-aware two-phase flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_divergence)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"multi-objective knapsack dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process and using a hybrid of greedy and random selection to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios and value-weight ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    v1_weight_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_weight_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Combined metric: dominance + weight ratio\n    combined_metric = (v1_dominance + v2_dominance) * (v1_weight_ratio + v2_weight_ratio)\n    flip_candidates = np.argsort(combined_metric)[::-1]\n\n    # Dynamic capacity-aware flipping with randomness\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high metric\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low metric\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_metric)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    # Third pass: random flip to explore neighborhood\n    if np.random.rand() < 0.5:  # 50% chance for random flip\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 0 and weight_lst[flip_idx] <= remaining_capacity:\n            new_solution[flip_idx] = 1\n        elif new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8357757694763727,
            2.0994197130203247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios and value-weight ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    v1_weight_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_weight_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Combined metric: dominance + weight ratio\n    combined_metric = (v1_dominance + v2_dominance) * (v1_weight_ratio + v2_weight_ratio)\n    flip_candidates = np.argsort(combined_metric)[::-1]\n\n    # Dynamic capacity-aware flipping with randomness\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high metric\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low metric\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_metric)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% chance to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    # Third pass: random flip to explore neighborhood\n    if np.random.rand() < 0.5:  # 50% chance for random flip\n        flip_idx = np.random.choice(len(new_solution))\n        if new_solution[flip_idx] == 0 and weight_lst[flip_idx] <= remaining_capacity:\n            new_solution[flip_idx] = 1\n        elif new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8838098594598736,
            5.490662008523941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8477040667796344,
            10.355092495679855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8782196119828625,
            1.808861494064331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8460033273029177,
            5.0854381918907166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both objectives' contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = obj1 * obj2 / (weight_lst.sum() + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst * value2_lst\n    v2_synergy = value1_lst * value2_lst\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: balance objectives by flipping items\n    if current_weight <= capacity:\n        for idx in flip_candidates:\n            if new_solution[idx] == 1 and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight < 0.8 * capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8038312472793219,
            2.472316950559616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = obj1 * obj2 / (weight_lst.sum() + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_synergy = value1_lst * value2_lst\n    v2_synergy = value1_lst * value2_lst\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: balance objectives by flipping items\n    if current_weight <= capacity:\n        for idx in flip_candidates:\n            if new_solution[idx] == 1 and np.random.rand() < 0.3:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight < 0.8 * capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their dominance, then generates a neighbor by strategically flipping items based on a novel \"value dominance ratio\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (value1 / value2 ratio)\n    objectives = np.array([obj for _, obj in archive])\n    dominance = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value dominance ratio for both objectives\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    combined_dominance = v1_dominance + v2_dominance\n\n    # Identify items to flip based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8844777483934578,
            0.7978863418102264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (value1 / value2 ratio)\n    objectives = np.array([obj for _, obj in archive])\n    dominance = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value dominance ratio for both objectives\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    combined_dominance = v1_dominance + v2_dominance\n\n    # Identify items to flip based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high objective values and low weight, then generates a neighbor by strategically flipping items based on a novel \"cross-objective value-weight ratio\" heuristic, using a three-phase adjustment process that alternates between adding and removing high-potential items while ensuring feasibility through dynamic weight tracking.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])  # Product instead of sum\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio + v2_ratio) * (value1_lst * value2_lst) ** 0.5  # Geometric mean of values\n\n    # Three-phase flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add high-ratio items, 1: remove low-ratio items, 2: balance\n\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add high-ratio items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Remove low-ratio items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Balance phase\n            if new_solution[idx] == 1 and cross_ratio[idx] < np.median(cross_ratio):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Dynamic phase transition\n        if current_weight > 0.6 * capacity:\n            phase = 1\n        elif current_weight < 0.4 * capacity:\n            phase = 0\n        else:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.8642333715732269,
            9.312613815069199
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])  # Product instead of sum\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio + v2_ratio) * (value1_lst * value2_lst) ** 0.5  # Geometric mean of values\n\n    # Three-phase flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add high-ratio items, 1: remove low-ratio items, 2: balance\n\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add high-ratio items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Remove low-ratio items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Balance phase\n            if new_solution[idx] == 1 and cross_ratio[idx] < np.median(cross_ratio):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Dynamic phase transition\n        if current_weight > 0.6 * capacity:\n            phase = 1\n        elif current_weight < 0.4 * capacity:\n            phase = 0\n        else:\n            phase = 2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the Pareto-frontier dominance and item diversity, then generates a neighbor by strategically flipping items based on a novel \"diversity-aware Pareto dominance\" heuristic that prioritizes items with high potential to improve both objectives while maintaining diversity in the solution space, ensuring feasibility through a three-phase adjustment process that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto-frontier dominance and diversity\n    solutions = np.array([sol for sol, _ in archive])\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[:, 0], objectives[:, 1]\n\n    # Calculate dominance scores\n    dominance_scores = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    diversity_scores = np.sum(np.abs(solutions - np.mean(solutions, axis=0)), axis=1)\n    combined_scores = dominance_scores * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate diversity-aware Pareto dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    item_diversity = np.sum(np.abs(solutions - base_solution), axis=0) / len(solutions)\n    combined_dominance = (v1_dominance + v2_dominance) * (1 + item_diversity)\n\n    # Three-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Finally try to swap items\n            if new_solution[idx] == 0 and current_weight - weight_lst[np.where(new_solution == 1)[0][0]] + weight_lst[idx] <= capacity:\n                remove_idx = np.where(new_solution == 1)[0][0]\n                new_solution[remove_idx] = 0\n                new_solution[idx] = 1\n                current_weight = current_weight - weight_lst[remove_idx] + weight_lst[idx]\n\n        # Switch phase based on capacity utilization\n        if current_weight > 0.8 * capacity:\n            phase = 1\n        elif current_weight > 0.9 * capacity:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.833471169905327,
            2.8654418289661407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto-frontier dominance and diversity\n    solutions = np.array([sol for sol, _ in archive])\n    objectives = np.array([obj for _, obj in archive])\n    obj1, obj2 = objectives[:, 0], objectives[:, 1]\n\n    # Calculate dominance scores\n    dominance_scores = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    diversity_scores = np.sum(np.abs(solutions - np.mean(solutions, axis=0)), axis=1)\n    combined_scores = dominance_scores * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate diversity-aware Pareto dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    item_diversity = np.sum(np.abs(solutions - base_solution), axis=0) / len(solutions)\n    combined_dominance = (v1_dominance + v2_dominance) * (1 + item_diversity)\n\n    # Three-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Finally try to swap items\n            if new_solution[idx] == 0 and current_weight - weight_lst[np.where(new_solution == 1)[0][0]] + weight_lst[idx] <= capacity:\n                remove_idx = np.where(new_solution == 1)[0][0]\n                new_solution[remove_idx] = 0\n                new_solution[idx] = 1\n                current_weight = current_weight - weight_lst[remove_idx] + weight_lst[idx]\n\n        # Switch phase based on capacity utilization\n        if current_weight > 0.8 * capacity:\n            phase = 1\n        elif current_weight > 0.9 * capacity:\n            phase = 2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This algorithm selects a solution from the archive by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both individual and combined objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 * obj2) / (np.sqrt(obj1**2 + obj2**2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy ratios\n    v1_synergy = (value1_lst * value2_lst) / (np.sqrt(value1_lst**2 + value2_lst**2) + 1e-6)\n    v2_synergy = (value2_lst * value1_lst) / (np.sqrt(value2_lst**2 + value1_lst**2) + 1e-6)\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-based prioritization\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: flip items with high individual improvement potential\n    if np.random.rand() > 0.5:\n        v1_ratio = value1_lst / (weight_lst + 1e-6)\n        flip_candidates = np.argsort(v1_ratio)[::-1]\n    else:\n        v2_ratio = value2_lst / (weight_lst + 1e-6)\n        flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            if current_weight <= capacity:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8958882570858095,
            1.1609545052051544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 * obj2) / (np.sqrt(obj1**2 + obj2**2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy ratios\n    v1_synergy = (value1_lst * value2_lst) / (np.sqrt(value1_lst**2 + value2_lst**2) + 1e-6)\n    v2_synergy = (value2_lst * value1_lst) / (np.sqrt(value2_lst**2 + value1_lst**2) + 1e-6)\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-based prioritization\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: flip items with high individual improvement potential\n    if np.random.rand() > 0.5:\n        v1_ratio = value1_lst / (weight_lst + 1e-6)\n        flip_candidates = np.argsort(v1_ratio)[::-1]\n    else:\n        v2_ratio = value2_lst / (weight_lst + 1e-6)\n        flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            if current_weight <= capacity:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by using a novel \"multi-objective synergy score\" that combines value ratios and weight efficiency, then generates a neighbor by strategically flipping items based on a dynamic \"objective trade-off\" heuristic that adapts to the current solution's dominance structure, ensuring feasibility through a three-phase adjustment process that prioritizes items with high cross-objective leverage.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores for each solution in archive\n    dominance_scores = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominance_scores[i] += 1\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective synergy score\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = v1_ratio * v2_ratio * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Identify items to flip based on dynamic trade-off heuristic\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    # Sort items by synergy score\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add high-synergy items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Remove low-synergy items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Swap items to improve trade-off\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Switch phase based on current weight\n        if phase == 0 and current_weight > 0.6 * capacity:\n            phase = 1\n        elif phase == 1 and current_weight > 0.8 * capacity:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.8581099383992581,
            3.2673091292381287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores for each solution in archive\n    dominance_scores = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominance_scores[i] += 1\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective synergy score\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = v1_ratio * v2_ratio * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Identify items to flip based on dynamic trade-off heuristic\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    # Sort items by synergy score\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add high-synergy items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Remove low-synergy items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Swap items to improve trade-off\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Switch phase based on current weight\n        if phase == 0 and current_weight > 0.6 * capacity:\n            phase = 1\n        elif phase == 1 and current_weight > 0.8 * capacity:\n            phase = 2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8254346146633333,
            8.86925733089447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high objective values and low weight, then generates a neighbor by strategically flipping items based on a hybrid value-weight ratio and dominance relationship heuristic, ensuring feasibility through an adaptive adjustment process that balances both objectives while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight and dominance potential\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])  # Product of objectives\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight ratio and dominance metric\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    dominance = (v1_ratio > np.median(v1_ratio)) & (v2_ratio > np.median(v2_ratio))\n    hybrid_score = (v1_ratio + v2_ratio) * (1 + dominance.astype(float))\n\n    # Sort items by hybrid score and dominance\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n\n    # Adaptive flipping based on current capacity utilization\n    current_weight = np.sum(weight_lst * new_solution)\n    utilization = current_weight / capacity\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Add item if underutilized or if it's a dominant item\n            if utilization < 0.8 or dominance[idx]:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Remove item if overutilized or if it's a non-dominant item\n            if utilization > 0.9 or not dominance[idx]:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8578513298326659,
            3.5041111409664154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight and dominance potential\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])  # Product of objectives\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight ratio and dominance metric\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    dominance = (v1_ratio > np.median(v1_ratio)) & (v2_ratio > np.median(v2_ratio))\n    hybrid_score = (v1_ratio + v2_ratio) * (1 + dominance.astype(float))\n\n    # Sort items by hybrid score and dominance\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n\n    # Adaptive flipping based on current capacity utilization\n    current_weight = np.sum(weight_lst * new_solution)\n    utilization = current_weight / capacity\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Add item if underutilized or if it's a dominant item\n            if utilization < 0.8 or dominance[idx]:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Remove item if overutilized or if it's a non-dominant item\n            if utilization > 0.9 or not dominance[idx]:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9355856758472361,
            3.200508326292038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel entropy-weighted score that balances both objectives and their variability, then generates a neighbor by flipping items with high cross-objective entropy, ensuring feasibility through a dynamic capacity threshold adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate entropy-weighted scores for selection\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n\n    # Normalize objectives\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n\n    # Calculate entropy for each objective\n    hist1, _ = np.histogram(obj1_norm, bins=5, density=True)\n    hist2, _ = np.histogram(obj2_norm, bins=5, density=True)\n    entropy1 = -np.sum(hist1 * np.log(hist1 + 1e-6))\n    entropy2 = -np.sum(hist2 * np.log(hist2 + 1e-6))\n\n    # Combine with weights based on entropy\n    scores = (entropy1 * obj1_norm + entropy2 * obj2_norm) / (np.array([np.sum(weight_lst * sol) for sol, _ in archive]) + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective entropy for flipping\n    v1_entropy = -np.sum(value1_lst * np.log(value1_lst + 1e-6)) / (np.sum(value1_lst) + 1e-6)\n    v2_entropy = -np.sum(value2_lst * np.log(value2_lst + 1e-6)) / (np.sum(value2_lst) + 1e-6)\n    combined_entropy = v1_entropy * value1_lst + v2_entropy * value2_lst\n\n    flip_candidates = np.argsort(combined_entropy)[::-1]\n\n    # Dynamic capacity threshold adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    threshold = 0.8 * capacity\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        # Adjust threshold dynamically\n        if current_weight > threshold:\n            threshold = max(0.5 * capacity, threshold - 0.1 * capacity)\n\n    return new_solution\n\n",
        "score": [
            -0.7980886041562073,
            9.846079736948013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate entropy-weighted scores for selection\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n\n    # Normalize objectives\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n\n    # Calculate entropy for each objective\n    hist1, _ = np.histogram(obj1_norm, bins=5, density=True)\n    hist2, _ = np.histogram(obj2_norm, bins=5, density=True)\n    entropy1 = -np.sum(hist1 * np.log(hist1 + 1e-6))\n    entropy2 = -np.sum(hist2 * np.log(hist2 + 1e-6))\n\n    # Combine with weights based on entropy\n    scores = (entropy1 * obj1_norm + entropy2 * obj2_norm) / (np.array([np.sum(weight_lst * sol) for sol, _ in archive]) + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective entropy for flipping\n    v1_entropy = -np.sum(value1_lst * np.log(value1_lst + 1e-6)) / (np.sum(value1_lst) + 1e-6)\n    v2_entropy = -np.sum(value2_lst * np.log(value2_lst + 1e-6)) / (np.sum(value2_lst) + 1e-6)\n    combined_entropy = v1_entropy * value1_lst + v2_entropy * value2_lst\n\n    flip_candidates = np.argsort(combined_entropy)[::-1]\n\n    # Dynamic capacity threshold adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    threshold = 0.8 * capacity\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        # Adjust threshold dynamically\n        if current_weight > threshold:\n            threshold = max(0.5 * capacity, threshold - 0.1 * capacity)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the Pareto front curvature and leveraging a novel \"objective space transformation\" heuristic that identifies items to flip based on their position relative to the Pareto front's convex hull, while ensuring feasibility through a multi-phase adjustment process that prioritizes items with high potential to create new Pareto-optimal points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto front curvature\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = objectives[np.lexsort((objectives[:, 1], -objectives[:, 0]))]\n    selected_idx = np.argmax(np.diff(pareto_front, axis=0).sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space transformation metrics\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    angle = np.arctan2(v2_norm, v1_norm)\n\n    # Identify items to flip based on angle and current solution\n    flip_candidates = np.argsort(angle)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Multi-phase flipping to maintain feasibility\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.argsort(angle)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8931582711088486,
            3.3344603776931763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto front curvature\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = objectives[np.lexsort((objectives[:, 1], -objectives[:, 0]))]\n    selected_idx = np.argmax(np.diff(pareto_front, axis=0).sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space transformation metrics\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    angle = np.arctan2(v2_norm, v1_norm)\n\n    # Identify items to flip based on angle and current solution\n    flip_candidates = np.argsort(angle)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Multi-phase flipping to maintain feasibility\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        remove_candidates = np.argsort(angle)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective balance\" metric that combines normalized objective values and their ratios, then generates a neighbor by applying a hybrid local search that strategically flips items based on a dynamic \"value-density\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes high-value items while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with best objective balance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-density ratios\n    density1 = value1_lst / (weight_lst + 1e-6)\n    density2 = value2_lst / (weight_lst + 1e-6)\n    combined_density = density1 + density2\n\n    # Phase 1: Add high-density items\n    flip_candidates = np.argsort(combined_density)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Phase 2: Remove low-density items if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_density)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8125657465951598,
            2.230866551399231
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with best objective balance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-density ratios\n    density1 = value1_lst / (weight_lst + 1e-6)\n    density2 = value2_lst / (weight_lst + 1e-6)\n    combined_density = density1 + density2\n\n    # Phase 1: Add high-density items\n    flip_candidates = np.argsort(combined_density)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Phase 2: Remove low-density items if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_density)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score combining objective values, weight efficiency, and diversity metrics, then generates a neighbor by strategically flipping items based on a hybrid \"value-weight ratio and marginal contribution\" heuristic, ensuring feasibility through an adaptive phase adjustment process that prioritizes items with high cross-objective potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection score\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([np.sum(sol != archive[0][0]) for sol, _ in archive])\n    scores = (objectives * 0.6 + diversity * 0.4) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight metrics\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    marginal_v1 = value1_lst - np.mean(value1_lst[base_solution == 1]) if np.any(base_solution) else value1_lst\n    marginal_v2 = value2_lst - np.mean(value2_lst[base_solution == 1]) if np.any(base_solution) else value2_lst\n    hybrid_score = (v1_ratio + v2_ratio) * 0.7 + (marginal_v1 + marginal_v2) * 0.3\n\n    # Adaptive flipping strategy\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adaptive phase transition\n        if current_weight > 0.6 * capacity and np.random.rand() > 0.7:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8680488044745676,
            8.159997969865799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection score\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([np.sum(sol != archive[0][0]) for sol, _ in archive])\n    scores = (objectives * 0.6 + diversity * 0.4) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight metrics\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    marginal_v1 = value1_lst - np.mean(value1_lst[base_solution == 1]) if np.any(base_solution) else value1_lst\n    marginal_v2 = value2_lst - np.mean(value2_lst[base_solution == 1]) if np.any(base_solution) else value2_lst\n    hybrid_score = (v1_ratio + v2_ratio) * 0.7 + (marginal_v1 + marginal_v2) * 0.3\n\n    # Adaptive flipping strategy\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adaptive phase transition\n        if current_weight > 0.6 * capacity and np.random.rand() > 0.7:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by combining objective values with a novel \"value-density synergy\" metric, then generates a neighbor by strategically flipping items based on their cross-objective contribution, using a two-phase adjustment process that prioritizes items with high combined utility while maintaining feasibility through a dynamic capacity threshold.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest value-density synergy\n    objectives = np.array([(obj[0] * obj[1]) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate combined value-density synergy\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    synergy = (v1_density * value2_lst + v2_density * value1_lst) / (np.sqrt(v1_density * v2_density) + 1e-6)\n\n    # Identify items to flip based on synergy\n    flip_candidates = np.argsort(synergy)[::-1]\n\n    # Two-phase flipping with dynamic capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    dynamic_threshold = 0.8 * capacity if current_weight < 0.5 * capacity else 0.9 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when reaching dynamic threshold\n        if current_weight > dynamic_threshold:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.0101505532252322,
            4.571231335401535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest value-density synergy\n    objectives = np.array([(obj[0] * obj[1]) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate combined value-density synergy\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    synergy = (v1_density * value2_lst + v2_density * value1_lst) / (np.sqrt(v1_density * v2_density) + 1e-6)\n\n    # Identify items to flip based on synergy\n    flip_candidates = np.argsort(synergy)[::-1]\n\n    # Two-phase flipping with dynamic capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    dynamic_threshold = 0.8 * capacity if current_weight < 0.5 * capacity else 0.9 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when reaching dynamic threshold\n        if current_weight > dynamic_threshold:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive by identifying the one with the highest combined value-weight ratio for both objectives, then generates a neighbor by strategically replacing items based on their potential to improve both objectives while maintaining feasibility through a hybrid greedy-randomized approach that balances exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined value-weight ratio\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = vw_ratio1 + vw_ratio2\n    selected_idx = np.argmax([np.sum(sol[0] * combined_ratio) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to remove (lowest combined ratio)\n    remove_candidates = np.argsort(new_solution * combined_ratio)\n    for idx in remove_candidates:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            remaining_capacity += weight_lst[idx]\n            break\n\n    # Identify items to add (highest combined ratio not currently in solution)\n    add_candidates = np.argsort((1 - new_solution) * combined_ratio)[::-1]\n    for idx in add_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Randomly flip some items to maintain diversity\n    flip_prob = 0.1\n    for i in range(len(new_solution)):\n        if np.random.random() < flip_prob:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(new_solution * combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.26874512715697796,
            4.430964350700378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined value-weight ratio\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = vw_ratio1 + vw_ratio2\n    selected_idx = np.argmax([np.sum(sol[0] * combined_ratio) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to remove (lowest combined ratio)\n    remove_candidates = np.argsort(new_solution * combined_ratio)\n    for idx in remove_candidates:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            remaining_capacity += weight_lst[idx]\n            break\n\n    # Identify items to add (highest combined ratio not currently in solution)\n    add_candidates = np.argsort((1 - new_solution) * combined_ratio)[::-1]\n    for idx in add_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Randomly flip some items to maintain diversity\n    flip_prob = 0.1\n    for i in range(len(new_solution)):\n        if np.random.random() < flip_prob:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(new_solution * combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective balance\" heuristic that prioritizes items with high potential to improve one objective while maintaining balance in the other, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.abs(obj1 - obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmin(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve one objective while maintaining balance\n    combined_balance = np.abs(v1_balance - v2_balance)\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7569296644230785,
            2.2848560512065887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.abs(obj1 - obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmin(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve one objective while maintaining balance\n    combined_balance = np.abs(v1_balance - v2_balance)\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Hybrid local search: combine two-phase flipping with adaptive item selection\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    # First pass: prioritize items with high cross-objective synergy\n    if abs_correlation > 0.5:\n        synergy_items = np.argsort((v1_ratio + v2_ratio) * (1 + abs_correlation))[::-1]\n    else:\n        synergy_items = np.argsort(v1_ratio + v2_ratio)[::-1]\n\n    for idx in synergy_items:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    # Second pass: adaptive flipping based on current solution's objective imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    imbalance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-6)\n\n    if imbalance > 0.3:  # Strong imbalance, focus on the weaker objective\n        if obj1 < obj2:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n    else:  # Balanced, use combined ratio\n        flip_candidates = np.argsort(v1_ratio + v2_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8675785482398619,
            6.491661012172699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Hybrid local search: combine two-phase flipping with adaptive item selection\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    # First pass: prioritize items with high cross-objective synergy\n    if abs_correlation > 0.5:\n        synergy_items = np.argsort((v1_ratio + v2_ratio) * (1 + abs_correlation))[::-1]\n    else:\n        synergy_items = np.argsort(v1_ratio + v2_ratio)[::-1]\n\n    for idx in synergy_items:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    # Second pass: adaptive flipping based on current solution's objective imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    imbalance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-6)\n\n    if imbalance > 0.3:  # Strong imbalance, focus on the weaker objective\n        if obj1 < obj2:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n    else:  # Balanced, use combined ratio\n        flip_candidates = np.argsort(v1_ratio + v2_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance score\" that combines both objectives with adaptive weighting, then generates a neighbor by strategically flipping items using a hybrid of \"value-to-weight ratio\" and \"objective dominance\" heuristics, ensuring feasibility through a dynamic capacity management process that prioritizes items with high cross-objective potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective dominance scores\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    dominance_scores = (v1_scores * v2_scores) / (v1_scores + v2_scores + 1e-6)\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight metrics\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    hybrid_metric = (v1_ratio + v2_ratio) * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Dynamic flip strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_candidates = np.argsort(hybrid_metric)[::-1]\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            if np.random.rand() < 0.3:  # 30% chance to remove items\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5747338840227348,
            4.9417538940906525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective dominance scores\n    v1_scores = np.array([obj[0] for _, obj in archive])\n    v2_scores = np.array([obj[1] for _, obj in archive])\n    dominance_scores = (v1_scores * v2_scores) / (v1_scores + v2_scores + 1e-6)\n\n    # Select solution with highest dominance score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight metrics\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    hybrid_metric = (v1_ratio + v2_ratio) * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Dynamic flip strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_candidates = np.argsort(hybrid_metric)[::-1]\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            if np.random.rand() < 0.3:  # 30% chance to remove items\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.825819820544652,
            5.310835748910904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance score\" that considers both objective values and their relative improvement potential, then generates a neighbor by strategically flipping items that show high cross-objective trade-off potential using a \"value-weight dominance\" heuristic, while maintaining feasibility through a dynamic capacity adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0] / (np.max(objectives[:, 0]) + 1e-6)\n    v2_scores = objectives[:, 1] / (np.max(objectives[:, 1]) + 1e-6)\n    dominance_scores = 0.6 * v1_scores + 0.4 * v2_scores - 0.2 * np.abs(v1_scores - v2_scores)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6) * (1 + np.tanh(value2_lst - value1_lst))\n    v2_dominance = value2_lst / (weight_lst + 1e-6) * (1 + np.tanh(value1_lst - value2_lst))\n    flip_candidates = np.argsort(v1_dominance + v2_dominance)[::-1]\n\n    # Dynamic capacity adjustment flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    threshold = 0.8 * capacity if current_weight < 0.5 * capacity else 0.9 * capacity\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8706307178504826,
            3.749930590391159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0] / (np.max(objectives[:, 0]) + 1e-6)\n    v2_scores = objectives[:, 1] / (np.max(objectives[:, 1]) + 1e-6)\n    dominance_scores = 0.6 * v1_scores + 0.4 * v2_scores - 0.2 * np.abs(v1_scores - v2_scores)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6) * (1 + np.tanh(value2_lst - value1_lst))\n    v2_dominance = value2_lst / (weight_lst + 1e-6) * (1 + np.tanh(value1_lst - value2_lst))\n    flip_candidates = np.argsort(v1_dominance + v2_dominance)[::-1]\n\n    # Dynamic capacity adjustment flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    threshold = 0.8 * capacity if current_weight < 0.5 * capacity else 0.9 * capacity\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= threshold:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor solution by strategically flipping items based on a novel \"multi-objective knapsack dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously while ensuring feasibility through a dynamic capacity-aware adjustment process using a hybrid of greedy selection and probabilistic swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hypervolume contribution\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n\n    # Calculate hypervolume contribution for each solution\n    hypervolume = (max_obj1 - obj1) * (max_obj2 - obj2)\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective knapsack dominance metric\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Identify items with high potential to improve both objectives\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping with probabilistic swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: probabilistic greedy addition\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: probabilistic removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in flip_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% probability to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    # Third pass: targeted swaps for better trade-offs\n    if np.random.rand() < 0.5:  # 50% chance to perform swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        for in_idx in in_items:\n            for out_idx in out_items:\n                if (weight_lst[out_idx] - weight_lst[in_idx]) <= remaining_capacity:\n                    if (value1_lst[out_idx] - value1_lst[in_idx] > 0) and (value2_lst[out_idx] - value2_lst[in_idx] > 0):\n                        new_solution[in_idx] = 0\n                        new_solution[out_idx] = 1\n                        remaining_capacity += weight_lst[in_idx] - weight_lst[out_idx]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8535596694661609,
            6.42498505115509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hypervolume contribution\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n\n    # Calculate hypervolume contribution for each solution\n    hypervolume = (max_obj1 - obj1) * (max_obj2 - obj2)\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-objective knapsack dominance metric\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Identify items with high potential to improve both objectives\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping with probabilistic swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: probabilistic greedy addition\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: probabilistic removal\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        for idx in flip_candidates:\n            if new_solution[idx] == 1:\n                if np.random.rand() < 0.3:  # 30% probability to remove\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    # Third pass: targeted swaps for better trade-offs\n    if np.random.rand() < 0.5:  # 50% chance to perform swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        for in_idx in in_items:\n            for out_idx in out_items:\n                if (weight_lst[out_idx] - weight_lst[in_idx]) <= remaining_capacity:\n                    if (value1_lst[out_idx] - value1_lst[in_idx] > 0) and (value2_lst[out_idx] - value2_lst[in_idx] > 0):\n                        new_solution[in_idx] = 0\n                        new_solution[out_idx] = 1\n                        remaining_capacity += weight_lst[in_idx] - weight_lst[out_idx]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for trade-off improvement by analyzing the Pareto front shape and item contributions, then generates a neighbor by strategically flipping items based on a novel \"objective trade-off dominance\" heuristic that prioritizes items with high potential to improve one objective while minimally sacrificing the other, ensuring feasibility through a dynamic trade-off-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential (min of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    trade_off = np.min(objectives, axis=1)\n    selected_idx = np.argmax(trade_off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate trade-off dominance for items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    trade_off_ratio = (v1_ratio + v2_ratio) / (np.abs(v1_ratio - v2_ratio) + 1e-6)\n\n    # Identify items to flip based on trade-off dominance\n    flip_candidates = np.argsort(trade_off_ratio)[::-1]\n\n    # Dynamic trade-off-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high trade-off dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low trade-off dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(trade_off_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: local refinement to improve trade-off\n    for _ in range(3):\n        for idx in flip_candidates:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7534045749920282,
            2.666940838098526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential (min of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    trade_off = np.min(objectives, axis=1)\n    selected_idx = np.argmax(trade_off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate trade-off dominance for items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    trade_off_ratio = (v1_ratio + v2_ratio) / (np.abs(v1_ratio - v2_ratio) + 1e-6)\n\n    # Identify items to flip based on trade-off dominance\n    flip_candidates = np.argsort(trade_off_ratio)[::-1]\n\n    # Dynamic trade-off-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high trade-off dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low trade-off dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(trade_off_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: local refinement to improve trade-off\n    for _ in range(3):\n        for idx in flip_candidates:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process, and incorporates a hybrid local search strategy that combines random swaps with a guided exploration of the solution space to escape local optima and discover high-quality solutions across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios and value-weight ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection strategy: combine dominance and value-weight ratios\n    combined_score = v1_dominance + v2_dominance + vw_ratio1 + vw_ratio2\n    flip_candidates = np.argsort(combined_score)[::-1]\n\n    # Dynamic capacity-aware flipping with randomness\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high combined score\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add high-scoring item\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: guided exploration with random swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove low-scoring items first\n        remove_candidates = np.argsort(combined_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: random swaps to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance for random exploration\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Check feasibility after swap\n            weight_diff = weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]]\n            if current_weight + weight_diff <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.7869359487805916,
            5.471981197595596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios and value-weight ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection strategy: combine dominance and value-weight ratios\n    combined_score = v1_dominance + v2_dominance + vw_ratio1 + vw_ratio2\n    flip_candidates = np.argsort(combined_score)[::-1]\n\n    # Dynamic capacity-aware flipping with randomness\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high combined score\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to add high-scoring item\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: guided exploration with random swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove low-scoring items first\n        remove_candidates = np.argsort(combined_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: random swaps to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance for random exploration\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Check feasibility after swap\n            weight_diff = weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]]\n            if current_weight + weight_diff <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance potential and generates neighbors by strategically flipping items using a hybrid of value-density and cross-objective synergy metrics, with a dynamic adjustment phase that balances exploration of high-value items with feasibility maintenance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance score (combined normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj1 = objectives[:, 0] / (np.max(objectives[:, 0]) + 1e-6)\n    norm_obj2 = objectives[:, 1] / (np.max(objectives[:, 1]) + 1e-6)\n    dominance_scores = norm_obj1 + norm_obj2\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value metrics\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    synergy = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    hybrid_score = 0.6 * v1_density + 0.3 * v2_density + 0.1 * synergy\n\n    # Sort items by hybrid score\n    sorted_items = np.argsort(hybrid_score)[::-1]\n\n    # Dynamic flipping with feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_count = int(0.3 * len(weight_lst))  # Flip up to 30% of items\n\n    for idx in sorted_items[:flip_count]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Additional random flip for diversification\n    if np.random.rand() > 0.5:\n        random_idx = np.random.randint(0, len(weight_lst))\n        if new_solution[random_idx] == 0 and current_weight + weight_lst[random_idx] <= capacity:\n            new_solution[random_idx] = 1\n        elif new_solution[random_idx] == 1:\n            new_solution[random_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7797619604067402,
            2.5424598455429077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance score (combined normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj1 = objectives[:, 0] / (np.max(objectives[:, 0]) + 1e-6)\n    norm_obj2 = objectives[:, 1] / (np.max(objectives[:, 1]) + 1e-6)\n    dominance_scores = norm_obj1 + norm_obj2\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value metrics\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    synergy = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    hybrid_score = 0.6 * v1_density + 0.3 * v2_density + 0.1 * synergy\n\n    # Sort items by hybrid score\n    sorted_items = np.argsort(hybrid_score)[::-1]\n\n    # Dynamic flipping with feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_count = int(0.3 * len(weight_lst))  # Flip up to 30% of items\n\n    for idx in sorted_items[:flip_count]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Additional random flip for diversification\n    if np.random.rand() > 0.5:\n        random_idx = np.random.randint(0, len(weight_lst))\n        if new_solution[random_idx] == 0 and current_weight + weight_lst[random_idx] <= capacity:\n            new_solution[random_idx] = 1\n        elif new_solution[random_idx] == 1:\n            new_solution[random_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their balance, then generates a neighbor by strategically flipping items based on a novel \"value-weight balance\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with optimal value-to-weight ratios for both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest value balance\n    objectives = np.array([obj for _, obj in archive])\n    balance = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight balance for both objectives\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    combined_balance = (v1_balance + v2_balance) / 2\n\n    # Identify items to flip based on balance\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8954859756545309,
            3.0510161221027374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest value balance\n    objectives = np.array([obj for _, obj in archive])\n    balance = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight balance for both objectives\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    combined_balance = (v1_balance + v2_balance) / 2\n\n    # Identify items to flip based on balance\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing both objective values and their trade-off relationships, then generates a neighbor by strategically flipping items based on a novel \"multi-objective dominance frontier\" heuristic, ensuring feasibility through a dynamic capacity-adaptive adjustment process that prioritizes items with high Pareto-efficient potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    v2_scores = objectives[:, 1] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    tradeoff_scores = (v1_scores + v2_scores) / (np.abs(v1_scores - v2_scores) + 1e-6)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate Pareto-efficient potential\n    v1_ratios = value1_lst / (weight_lst + 1e-6)\n    v2_ratios = value2_lst / (weight_lst + 1e-6)\n    pareto_scores = v1_ratios * v2_ratios * (1 + np.abs(v1_ratios - v2_ratios))\n\n    # Dynamic adjustment process\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_candidates = np.argsort(pareto_scores)[::-1]\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            if np.random.rand() < 0.3:  # 30% chance to remove items\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Final capacity check\n    if np.sum(weight_lst * new_solution) > capacity:\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        remove_candidates = np.where(new_solution == 1)[0]\n        remove_weights = weight_lst[remove_candidates]\n        remove_idx = np.argmax(remove_weights)\n        new_solution[remove_candidates[remove_idx]] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.711112958093806,
            5.304057955741882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    v2_scores = objectives[:, 1] / (np.sum(weight_lst * archive[0][0]) + 1e-6)\n    tradeoff_scores = (v1_scores + v2_scores) / (np.abs(v1_scores - v2_scores) + 1e-6)\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate Pareto-efficient potential\n    v1_ratios = value1_lst / (weight_lst + 1e-6)\n    v2_ratios = value2_lst / (weight_lst + 1e-6)\n    pareto_scores = v1_ratios * v2_ratios * (1 + np.abs(v1_ratios - v2_ratios))\n\n    # Dynamic adjustment process\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_candidates = np.argsort(pareto_scores)[::-1]\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            if np.random.rand() < 0.3:  # 30% chance to remove items\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Final capacity check\n    if np.sum(weight_lst * new_solution) > capacity:\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        remove_candidates = np.where(new_solution == 1)[0]\n        remove_weights = weight_lst[remove_candidates]\n        remove_idx = np.argmax(remove_weights)\n        new_solution[remove_candidates[remove_idx]] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"trade-off sensitivity\" score that combines normalized objective values and their ratios, then generates a neighbor by strategically flipping items with high potential to improve both objectives while maintaining feasibility through a two-phase adjustment process that prioritizes high-impact items first.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate trade-off sensitivity score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = obj1 / (np.max(obj1) + 1e-6)\n    normalized_obj2 = obj2 / (np.max(obj2) + 1e-6)\n    tradeoff_score = np.abs(normalized_obj1 - normalized_obj2)\n    selected_idx = np.argmax(tradeoff_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item importance scores\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Item importance: product of normalized values and inverse weight\n    item_score = (value1_lst / (np.max(value1_lst) + 1e-6)) * (value2_lst / (np.max(value2_lst) + 1e-6)) * (capacity / (weight_lst + 1e-6))\n    flip_candidates = np.argsort(item_score)[::-1]\n\n    # First pass: add high-score items\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove low-score items if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(item_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9024121830784955,
            3.429789811372757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate trade-off sensitivity score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = obj1 / (np.max(obj1) + 1e-6)\n    normalized_obj2 = obj2 / (np.max(obj2) + 1e-6)\n    tradeoff_score = np.abs(normalized_obj1 - normalized_obj2)\n    selected_idx = np.argmax(tradeoff_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item importance scores\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Item importance: product of normalized values and inverse weight\n    item_score = (value1_lst / (np.max(value1_lst) + 1e-6)) * (value2_lst / (np.max(value2_lst) + 1e-6)) * (capacity / (weight_lst + 1e-6))\n    flip_candidates = np.argsort(item_score)[::-1]\n\n    # First pass: add high-score items\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove low-score items if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(item_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8489228890098048,
            6.9591202437877655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the objective space using a novel \"Pareto front curvature\" heuristic, then generates a neighbor by strategically flipping items based on their contribution to both objectives and their position relative to the Pareto front, ensuring feasibility through a dynamic multi-phase adjustment process that prioritizes items with high potential to create convex Pareto front segments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate Pareto front curvature\n    objectives = np.array([obj for _, obj in archive])\n    v1 = objectives[:, 0]\n    v2 = objectives[:, 1]\n\n    # Normalize objectives\n    v1_norm = (v1 - np.min(v1)) / (np.max(v1) - np.min(v1) + 1e-6)\n    v2_norm = (v2 - np.min(v2)) / (np.max(v2) - np.min(v2) + 1e-6)\n\n    # Calculate curvature (second derivative approximation)\n    curvature = np.gradient(np.gradient(v2_norm, v1_norm), v1_norm)\n\n    # Select solution with highest curvature (most \"interesting\" part of Pareto front)\n    selected_idx = np.argmax(curvature)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item contributions to both objectives\n    v1_contrib = value1_lst / (weight_lst + 1e-6)\n    v2_contrib = value2_lst / (weight_lst + 1e-6)\n\n    # Calculate item positions relative to Pareto front\n    v1_max = np.max(value1_lst)\n    v2_max = np.max(value2_lst)\n    v1_pos = value1_lst / (v1_max + 1e-6)\n    v2_pos = value2_lst / (v2_max + 1e-6)\n\n    # Combined score: contribution to both objectives weighted by position on Pareto front\n    combined_score = (v1_contrib * v1_pos + v2_contrib * v2_pos) * (1 + curvature[selected_idx])\n\n    # Multi-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    # Sort items by combined score\n    sorted_items = np.argsort(combined_score)[::-1]\n\n    for idx in sorted_items:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        elif phase == 1:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n        else:  # Swap items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                # Find an item to remove to make space\n                for remove_idx in sorted_items:\n                    if new_solution[remove_idx] == 1:\n                        new_solution[remove_idx] = 0\n                        remaining_capacity += weight_lst[remove_idx]\n                        new_solution[idx] = 1\n                        remaining_capacity -= weight_lst[idx]\n                        break\n\n        # Switch phases based on capacity usage\n        if current_weight > 0.8 * capacity and phase == 0:\n            phase = 1\n        elif current_weight > 0.9 * capacity and phase == 1:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.8880749217991646,
            5.406675785779953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate Pareto front curvature\n    objectives = np.array([obj for _, obj in archive])\n    v1 = objectives[:, 0]\n    v2 = objectives[:, 1]\n\n    # Normalize objectives\n    v1_norm = (v1 - np.min(v1)) / (np.max(v1) - np.min(v1) + 1e-6)\n    v2_norm = (v2 - np.min(v2)) / (np.max(v2) - np.min(v2) + 1e-6)\n\n    # Calculate curvature (second derivative approximation)\n    curvature = np.gradient(np.gradient(v2_norm, v1_norm), v1_norm)\n\n    # Select solution with highest curvature (most \"interesting\" part of Pareto front)\n    selected_idx = np.argmax(curvature)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item contributions to both objectives\n    v1_contrib = value1_lst / (weight_lst + 1e-6)\n    v2_contrib = value2_lst / (weight_lst + 1e-6)\n\n    # Calculate item positions relative to Pareto front\n    v1_max = np.max(value1_lst)\n    v2_max = np.max(value2_lst)\n    v1_pos = value1_lst / (v1_max + 1e-6)\n    v2_pos = value2_lst / (v2_max + 1e-6)\n\n    # Combined score: contribution to both objectives weighted by position on Pareto front\n    combined_score = (v1_contrib * v1_pos + v2_contrib * v2_pos) * (1 + curvature[selected_idx])\n\n    # Multi-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    # Sort items by combined score\n    sorted_items = np.argsort(combined_score)[::-1]\n\n    for idx in sorted_items:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        elif phase == 1:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n        else:  # Swap items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                # Find an item to remove to make space\n                for remove_idx in sorted_items:\n                    if new_solution[remove_idx] == 1:\n                        new_solution[remove_idx] = 0\n                        remaining_capacity += weight_lst[remove_idx]\n                        new_solution[idx] = 1\n                        remaining_capacity -= weight_lst[idx]\n                        break\n\n        # Switch phases based on capacity usage\n        if current_weight > 0.8 * capacity and phase == 0:\n            phase = 1\n        elif current_weight > 0.9 * capacity and phase == 1:\n            phase = 2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process, but uses a probabilistic selection mechanism to explore diverse neighborhoods more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized values)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = obj1 / (np.max(obj1) + 1e-6)\n    normalized_obj2 = obj2 / (np.max(obj2) + 1e-6)\n    synergy = normalized_obj1 * normalized_obj2\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight synergy scores\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    combined_synergy = v1_synergy * v2_synergy\n\n    # Probabilistic selection of flip candidates\n    probabilities = combined_synergy / (np.sum(combined_synergy) + 1e-6)\n    flip_candidates = np.random.choice(len(weight_lst), size=min(5, len(weight_lst)), p=probabilities, replace=False)\n\n    # Dynamic capacity-aware flipping with probabilistic acceptance\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to accept addition\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            if np.random.rand() < 0.3:  # 30% chance to accept removal\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.312247145264478,
            6.321933716535568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized values)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = obj1 / (np.max(obj1) + 1e-6)\n    normalized_obj2 = obj2 / (np.max(obj2) + 1e-6)\n    synergy = normalized_obj1 * normalized_obj2\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight synergy scores\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    combined_synergy = v1_synergy * v2_synergy\n\n    # Probabilistic selection of flip candidates\n    probabilities = combined_synergy / (np.sum(combined_synergy) + 1e-6)\n    flip_candidates = np.random.choice(len(weight_lst), size=min(5, len(weight_lst)), p=probabilities, replace=False)\n\n    # Dynamic capacity-aware flipping with probabilistic acceptance\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% chance to accept addition\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            if np.random.rand() < 0.3:  # 30% chance to accept removal\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    # Final feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This algorithm selects a solution from the archive with high potential by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-diversity\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with high cross-objective synergy while maintaining diversity in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    diversity = np.array([np.sum(np.abs(sol - np.mean(archive[0][0]))) for sol, _ in archive])\n    scores = objectives / (diversity + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-diversity scores for both objectives\n    v1_diversity = (value1_lst - np.mean(value1_lst)) / (np.std(value1_lst) + 1e-6)\n    v2_diversity = (value2_lst - np.mean(value2_lst)) / (np.std(value2_lst) + 1e-6)\n    combined_diversity = (v1_diversity + v2_diversity) / 2\n\n    # Identify items to flip based on diversity and current solution\n    flip_candidates = np.argsort(combined_diversity * (1 - new_solution))[::-1]\n\n    # Dynamic flipping with feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8453037800649674,
            8.950651168823242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    diversity = np.array([np.sum(np.abs(sol - np.mean(archive[0][0]))) for sol, _ in archive])\n    scores = objectives / (diversity + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-diversity scores for both objectives\n    v1_diversity = (value1_lst - np.mean(value1_lst)) / (np.std(value1_lst) + 1e-6)\n    v2_diversity = (value2_lst - np.mean(value2_lst)) / (np.std(value2_lst) + 1e-6)\n    combined_diversity = (v1_diversity + v2_diversity) / 2\n\n    # Identify items to flip based on diversity and current solution\n    flip_candidates = np.argsort(combined_diversity * (1 - new_solution))[::-1]\n\n    # Dynamic flipping with feasibility check\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance score and generates a neighbor by strategically flipping items with high marginal value improvements in both objectives, using a two-phase approach that first adds promising items and then refines the solution by removing less valuable items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance score\n    dominance_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] >= obj[0] and other_obj[1] > obj[1]) or (other_obj[0] > obj[0] and other_obj[1] >= obj[1]):\n                dominated += 1\n        dominance_scores.append(-dominated)  # Negative to maximize\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal improvements\n    current_weight = np.sum(weight_lst * new_solution)\n    marginal_v1 = value1_lst / (weight_lst + 1e-6)\n    marginal_v2 = value2_lst / (weight_lst + 1e-6)\n    marginal_combined = marginal_v1 + marginal_v2\n\n    # Two-phase flipping\n    phase = 0  # 0: add items, 1: remove items\n    flip_candidates = np.argsort(marginal_combined)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.858780672885981,
            2.713097035884857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance score\n    dominance_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] >= obj[0] and other_obj[1] > obj[1]) or (other_obj[0] > obj[0] and other_obj[1] >= obj[1]):\n                dominated += 1\n        dominance_scores.append(-dominated)  # Negative to maximize\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal improvements\n    current_weight = np.sum(weight_lst * new_solution)\n    marginal_v1 = value1_lst / (weight_lst + 1e-6)\n    marginal_v2 = value2_lst / (weight_lst + 1e-6)\n    marginal_combined = marginal_v1 + marginal_v2\n\n    # Two-phase flipping\n    phase = 0  # 0: add items, 1: remove items\n    flip_candidates = np.argsort(marginal_combined)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing both objective values and their trade-off, then generates a neighbor by strategically flipping items based on a novel \"value-dominance\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with high cross-objective trade-off potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    trade_offs = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    scores = trade_offs / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value dominance scores\n    v1_dominance = value1_lst / (np.sum(value1_lst) + 1e-6)\n    v2_dominance = value2_lst / (np.sum(value2_lst) + 1e-6)\n    trade_off_scores = (v1_dominance - v2_dominance) ** 2 * weight_lst\n\n    # Identify items to flip based on trade-off potential\n    flip_candidates = np.argsort(trade_off_scores)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_mode = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if flip_mode == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch mode when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            flip_mode = 1\n\n    return new_solution\n\n",
        "score": [
            -0.955462998953149,
            3.955014169216156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off potential\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    trade_offs = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    scores = trade_offs / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value dominance scores\n    v1_dominance = value1_lst / (np.sum(value1_lst) + 1e-6)\n    v2_dominance = value2_lst / (np.sum(value2_lst) + 1e-6)\n    trade_off_scores = (v1_dominance - v2_dominance) ** 2 * weight_lst\n\n    # Identify items to flip based on trade-off potential\n    flip_candidates = np.argsort(trade_off_scores)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_mode = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if flip_mode == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch mode when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            flip_mode = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the correlation between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective correlation\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective correlation\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    selected_idx = np.argmax(np.abs(correlation))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlation scores\n    v1_scores = value1_lst / (weight_lst + 1e-6)\n    v2_scores = value2_lst / (weight_lst + 1e-6)\n    correlation_scores = np.abs(np.corrcoef(v1_scores, v2_scores)[0, 1]) * (v1_scores + v2_scores)\n\n    # Identify items with high potential to improve both objectives\n    flip_candidates = np.argsort(correlation_scores)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high correlation\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low correlation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(correlation_scores)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8647075073351391,
            3.903602749109268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective correlation\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    selected_idx = np.argmax(np.abs(correlation))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlation scores\n    v1_scores = value1_lst / (weight_lst + 1e-6)\n    v2_scores = value2_lst / (weight_lst + 1e-6)\n    correlation_scores = np.abs(np.corrcoef(v1_scores, v2_scores)[0, 1]) * (v1_scores + v2_scores)\n\n    # Identify items with high potential to improve both objectives\n    flip_candidates = np.argsort(correlation_scores)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high correlation\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low correlation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(correlation_scores)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score combining normalized objectives with weight variance, then generates a neighbor by flipping items with high marginal utility, using a two-phase approach that prioritizes items with balanced value-weight ratios across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate score combining normalized objectives with weight variance\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    weight_var = np.var(weights)\n    scores = np.sum(norm_obj, axis=1) * (1 + weight_var)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utility for both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = (v1_ratio + v2_ratio) / 2\n\n    # Identify flip candidates based on marginal utility\n    flip_candidates = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            flip_candidates.append((i, combined_ratio[i]))\n        elif new_solution[i] == 1:\n            flip_candidates.append((i, -combined_ratio[i]))\n\n    # Sort candidates by marginal utility\n    flip_candidates.sort(key=lambda x: x[1], reverse=True)\n\n    # Two-phase flipping to maintain feasibility\n    phase = 0  # 0: add items, 1: remove items\n    for idx, _ in flip_candidates:\n        if phase == 0 and new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1 and new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.979517543885079,
            4.423159062862396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate score combining normalized objectives with weight variance\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    weight_var = np.var(weights)\n    scores = np.sum(norm_obj, axis=1) * (1 + weight_var)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utility for both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = (v1_ratio + v2_ratio) / 2\n\n    # Identify flip candidates based on marginal utility\n    flip_candidates = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            flip_candidates.append((i, combined_ratio[i]))\n        elif new_solution[i] == 1:\n            flip_candidates.append((i, -combined_ratio[i]))\n\n    # Sort candidates by marginal utility\n    flip_candidates.sort(key=lambda x: x[1], reverse=True)\n\n    # Two-phase flipping to maintain feasibility\n    phase = 0  # 0: add items, 1: remove items\n    for idx, _ in flip_candidates:\n        if phase == 0 and new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1 and new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the Pareto front curvature and generating neighbors through a novel \"objective space partitioning\" heuristic that divides the solution space into regions with different trade-off characteristics, then applies region-specific flipping strategies to explore high-value areas while maintaining feasibility through a dynamic capacity management system.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto front curvature (second derivative approximation)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_idx = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_idx]\n    diffs = np.diff(objectives_sorted, axis=0)\n    curvature = np.abs(np.diff(diffs[:, 1]) / (np.diff(diffs[:, 0]) + 1e-6))\n    selected_idx = sorted_idx[np.argmax(curvature) + 1]  # +1 because diff reduces length by 1\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space partitioning\n    v1_max, v2_max = np.max(objectives, axis=0)\n    v1_partitions = np.linspace(0, v1_max, 5)\n    v2_partitions = np.linspace(0, v2_max, 5)\n\n    # Identify items in different trade-off regions\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    tradeoff_ratio = v1_ratio / (v2_ratio + 1e-6)\n\n    # Dynamic capacity management\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Region-specific flipping strategies\n    for i in range(len(v1_partitions)-1):\n        for j in range(len(v2_partitions)-1):\n            region_mask = ((value1_lst >= v1_partitions[i]) & (value1_lst < v1_partitions[i+1]) &\n                          (value2_lst >= v2_partitions[j]) & (value2_lst < v2_partitions[j+1]))\n\n            # Different strategies for different regions\n            if i == 0 and j == 0:  # Low value region - remove\n                for idx in np.where(region_mask)[0]:\n                    if new_solution[idx] == 1:\n                        new_solution[idx] = 0\n                        remaining_capacity += weight_lst[idx]\n\n            elif i == len(v1_partitions)-2 and j == len(v2_partitions)-2:  # High value region - add\n                for idx in np.where(region_mask)[0]:\n                    if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                        new_solution[idx] = 1\n                        remaining_capacity -= weight_lst[idx]\n\n            else:  # Intermediate regions - trade-off based flipping\n                for idx in np.where(region_mask)[0]:\n                    if tradeoff_ratio[idx] > 1 and new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                        new_solution[idx] = 1\n                        remaining_capacity -= weight_lst[idx]\n                    elif tradeoff_ratio[idx] < 1 and new_solution[idx] == 1:\n                        new_solution[idx] = 0\n                        remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9518695533049971,
            6.293559163808823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Pareto front curvature (second derivative approximation)\n    objectives = np.array([obj for _, obj in archive])\n    sorted_idx = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_idx]\n    diffs = np.diff(objectives_sorted, axis=0)\n    curvature = np.abs(np.diff(diffs[:, 1]) / (np.diff(diffs[:, 0]) + 1e-6))\n    selected_idx = sorted_idx[np.argmax(curvature) + 1]  # +1 because diff reduces length by 1\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space partitioning\n    v1_max, v2_max = np.max(objectives, axis=0)\n    v1_partitions = np.linspace(0, v1_max, 5)\n    v2_partitions = np.linspace(0, v2_max, 5)\n\n    # Identify items in different trade-off regions\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    tradeoff_ratio = v1_ratio / (v2_ratio + 1e-6)\n\n    # Dynamic capacity management\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Region-specific flipping strategies\n    for i in range(len(v1_partitions)-1):\n        for j in range(len(v2_partitions)-1):\n            region_mask = ((value1_lst >= v1_partitions[i]) & (value1_lst < v1_partitions[i+1]) &\n                          (value2_lst >= v2_partitions[j]) & (value2_lst < v2_partitions[j+1]))\n\n            # Different strategies for different regions\n            if i == 0 and j == 0:  # Low value region - remove\n                for idx in np.where(region_mask)[0]:\n                    if new_solution[idx] == 1:\n                        new_solution[idx] = 0\n                        remaining_capacity += weight_lst[idx]\n\n            elif i == len(v1_partitions)-2 and j == len(v2_partitions)-2:  # High value region - add\n                for idx in np.where(region_mask)[0]:\n                    if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                        new_solution[idx] = 1\n                        remaining_capacity -= weight_lst[idx]\n\n            else:  # Intermediate regions - trade-off based flipping\n                for idx in np.where(region_mask)[0]:\n                    if tradeoff_ratio[idx] > 1 and new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                        new_solution[idx] = 1\n                        remaining_capacity -= weight_lst[idx]\n                    elif tradeoff_ratio[idx] < 1 and new_solution[idx] == 1:\n                        new_solution[idx] = 0\n                        remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"multi-dimensional utility\" heuristic that combines objective dominance with weight efficiency, while ensuring feasibility through a dynamic capacity-aware adjustment process that prioritizes items with the highest utility per unit weight.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-dimensional utility: (value1/weight + value2/weight) * (value1/value2 + value2/value1)\n    weight_efficiency = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    objective_tradeoff = (value1_lst / (value2_lst + 1e-6)) + (value2_lst / (value1_lst + 1e-6))\n    combined_utility = weight_efficiency * objective_tradeoff\n    flip_candidates = np.argsort(combined_utility)[::-1]\n\n    # Dynamic capacity-aware flipping with utility threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    utility_threshold = np.percentile(combined_utility, 75)  # Only consider top 25% utility items\n\n    # First pass: add items with high utility\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity and combined_utility[idx] >= utility_threshold:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low utility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_utility)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8434220275177573,
            3.5425368547439575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate multi-dimensional utility: (value1/weight + value2/weight) * (value1/value2 + value2/value1)\n    weight_efficiency = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    objective_tradeoff = (value1_lst / (value2_lst + 1e-6)) + (value2_lst / (value1_lst + 1e-6))\n    combined_utility = weight_efficiency * objective_tradeoff\n    flip_candidates = np.argsort(combined_utility)[::-1]\n\n    # Dynamic capacity-aware flipping with utility threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    utility_threshold = np.percentile(combined_utility, 75)  # Only consider top 25% utility items\n\n    # First pass: add items with high utility\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity and combined_utility[idx] >= utility_threshold:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low utility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_utility)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers the correlation between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    synergy = (obj1 / (max_obj1 + 1e-6)) * (obj2 / (max_obj2 + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_norm = value1_lst / (max_obj1 + 1e-6)\n    v2_norm = value2_lst / (max_obj2 + 1e-6)\n    synergy_score = v1_norm * v2_norm\n\n    # Identify items to flip based on synergy and weight\n    flip_candidates = np.argsort(synergy_score / (weight_lst + 1e-6))[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-aware adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: flip items based on synergy to improve both objectives\n    flip_candidates = np.argsort(synergy_score)[::-1]\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8158175882168878,
            3.445734888315201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (product of normalized objectives)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj1, max_obj2 = np.max(obj1), np.max(obj2)\n    synergy = (obj1 / (max_obj1 + 1e-6)) * (obj2 / (max_obj2 + 1e-6))\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_norm = value1_lst / (max_obj1 + 1e-6)\n    v2_norm = value2_lst / (max_obj2 + 1e-6)\n    synergy_score = v1_norm * v2_norm\n\n    # Identify items to flip based on synergy and weight\n    flip_candidates = np.argsort(synergy_score / (weight_lst + 1e-6))[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-aware adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: flip items based on synergy to improve both objectives\n    flip_candidates = np.argsort(synergy_score)[::-1]\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This new algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their relative importance, then generates a neighbor by strategically flipping items based on a novel \"objective importance weighted ratio\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with high cross-objective impact.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight and objective diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([abs(obj[0] - obj[1]) for _, obj in archive])\n    scores = (objectives / (weights + 1e-6)) * (1 + diversity / (np.sum(objectives) + 1e-6))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective importance weighted ratios\n    total_v1 = np.sum(value1_lst * new_solution)\n    total_v2 = np.sum(value2_lst * new_solution)\n    importance_v1 = total_v1 / (total_v1 + total_v2 + 1e-6)\n    importance_v2 = total_v2 / (total_v1 + total_v2 + 1e-6)\n\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    weighted_ratio = importance_v1 * v1_ratio + importance_v2 * v2_ratio\n\n    # Identify items to flip based on weighted ratio and current solution\n    flip_candidates = np.argsort(weighted_ratio)[::-1]\n\n    # Dynamic adjustment to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9785387278986422,
            3.633656471967697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight and objective diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([abs(obj[0] - obj[1]) for _, obj in archive])\n    scores = (objectives / (weights + 1e-6)) * (1 + diversity / (np.sum(objectives) + 1e-6))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective importance weighted ratios\n    total_v1 = np.sum(value1_lst * new_solution)\n    total_v2 = np.sum(value2_lst * new_solution)\n    importance_v1 = total_v1 / (total_v1 + total_v2 + 1e-6)\n    importance_v2 = total_v2 / (total_v1 + total_v2 + 1e-6)\n\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    weighted_ratio = importance_v1 * v1_ratio + importance_v2 * v2_ratio\n\n    # Identify items to flip based on weighted ratio and current solution\n    flip_candidates = np.argsort(weighted_ratio)[::-1]\n\n    # Dynamic adjustment to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining normalized objective values and their geometric mean, then generates neighbors by flipping items with high cross-objective value-weight ratios while ensuring feasibility through a capacity-aware two-phase adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hybrid score combining objectives and their geometric mean\n    objectives = np.array([(obj[0] + obj[1]) / 2 + np.sqrt(obj[0] * obj[1]) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio * v2_ratio) ** 0.5\n\n    # Identify items to flip based on cross-objective ratio\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    # Two-phase flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when approaching capacity\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.926326100888389,
            3.790242552757263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hybrid score combining objectives and their geometric mean\n    objectives = np.array([(obj[0] + obj[1]) / 2 + np.sqrt(obj[0] * obj[1]) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio * v2_ratio) ** 0.5\n\n    # Identify items to flip based on cross-objective ratio\n    flip_candidates = np.argsort(cross_ratio)[::-1]\n\n    # Two-phase flipping with capacity awareness\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when approaching capacity\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance ratio\" metric, then generates neighbors by strategically flipping items using a hybrid approach combining value-density and dominance-based selection, while maintaining feasibility through a capacity-aware two-phase adjustment process that prioritizes Pareto-optimal item combinations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance ratio for each solution\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1] and (objectives[j][0] > objectives[i][0] or objectives[j][1] > objectives[i][1]):\n                dominated += 1\n        dominance_scores[i] = dominated\n\n    # Select solution with highest dominance score (least dominated)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid selection metric\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    hybrid_metric = (v1_density + v2_density) * (1 + np.abs(np.corrcoef(v1_density, v2_density)[0, 1]))\n\n    # Identify flip candidates based on hybrid metric and dominance\n    flip_candidates = np.argsort(hybrid_metric)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Two-phase flipping with capacity awareness\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8541314206686433,
            6.585270494222641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance ratio for each solution\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1] and (objectives[j][0] > objectives[i][0] or objectives[j][1] > objectives[i][1]):\n                dominated += 1\n        dominance_scores[i] = dominated\n\n    # Select solution with highest dominance score (least dominated)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid selection metric\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    hybrid_metric = (v1_density + v2_density) * (1 + np.abs(np.corrcoef(v1_density, v2_density)[0, 1]))\n\n    # Identify flip candidates based on hybrid metric and dominance\n    flip_candidates = np.argsort(hybrid_metric)[::-1]\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Two-phase flipping with capacity awareness\n    phase = 0  # 0: add items, 1: remove items\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering the trade-off between objectives through a novel \"value dominance\" heuristic, then generates a neighbor by strategically flipping items based on a dynamic priority score that combines marginal gains in both objectives and their correlation, ensuring feasibility through an adaptive capacity management process that prioritizes items with high cross-objective synergy while maintaining diversity in the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest value dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_dominance = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    v2_dominance = objectives[:, 1] / (objectives[:, 0] + 1e-6)\n    dominance_scores = np.maximum(v1_dominance, v2_dominance)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic priority scores\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains and correlation\n    v1_marginal = value1_lst / (weight_lst + 1e-6)\n    v2_marginal = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_marginal, v2_marginal)[0, 1]\n\n    # Dynamic priority calculation\n    priority_scores = (v1_marginal + v2_marginal) * (1 + abs(correlation))\n    priority_scores[new_solution == 1] *= 0.7  # De-prioritize currently included items\n\n    # Sort items by priority\n    flip_candidates = np.argsort(priority_scores)[::-1]\n\n    # Adaptive capacity management\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:  # Random removal for diversity\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8951226655330242,
            3.7445581555366516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest value dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_dominance = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    v2_dominance = objectives[:, 1] / (objectives[:, 0] + 1e-6)\n    dominance_scores = np.maximum(v1_dominance, v2_dominance)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic priority scores\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains and correlation\n    v1_marginal = value1_lst / (weight_lst + 1e-6)\n    v2_marginal = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_marginal, v2_marginal)[0, 1]\n\n    # Dynamic priority calculation\n    priority_scores = (v1_marginal + v2_marginal) * (1 + abs(correlation))\n    priority_scores[new_solution == 1] *= 0.7  # De-prioritize currently included items\n\n    # Sort items by priority\n    flip_candidates = np.argsort(priority_scores)[::-1]\n\n    # Adaptive capacity management\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:  # Random removal for diversity\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7745497278039575,
            9.220166504383087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their normalized value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest normalized objective dominance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj = np.max(np.vstack((obj1, obj2)), axis=0)\n    normalized_dominance = (max_obj - np.minimum(obj1, obj2)) / (max_obj + 1e-6)\n    selected_idx = np.argmax(normalized_dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized objective dominance ratios\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    combined_dominance = v1_norm + v2_norm\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9022540046943939,
            2.08609601855278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest normalized objective dominance\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    max_obj = np.max(np.vstack((obj1, obj2)), axis=0)\n    normalized_dominance = (max_obj - np.minimum(obj1, obj2)) / (max_obj + 1e-6)\n    selected_idx = np.argmax(normalized_dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized objective dominance ratios\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    combined_dominance = v1_norm + v2_norm\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that alternates between adding and removing items in a way that maximizes the combined value of both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = (v1_ratio * v2_ratio) / (np.abs(v1_ratio - v2_ratio) + 1e-6)\n\n    # Identify items to flip based on synergy and current status\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8608952524587439,
            4.418534576892853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = (v1_ratio * v2_ratio) / (np.abs(v1_ratio - v2_ratio) + 1e-6)\n\n    # Identify items to flip based on synergy and current status\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic capacity-aware flipping with alternating phases\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance score\" that combines both objectives with adaptive weighting, then generates a neighbor by iteratively flipping items with high cross-objective value-to-weight ratios while maintaining feasibility through a dynamic capacity threshold adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    dominance_scores = (objectives[:, 0] * objectives[:, 1]) / (weights + 1e-6)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate adaptive value-weight ratios\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    weight_factor = 1 / (1 + np.exp(-(remaining_capacity / capacity - 0.5) * 5))\n    v1_ratio = value1_lst / (weight_lst + 1e-6) * (1 + weight_factor)\n    v2_ratio = value2_lst / (weight_lst + 1e-6) * (1 + weight_factor)\n\n    # Sort items by combined ratio\n    combined_ratio = (v1_ratio + v2_ratio) * (1 + np.random.rand() * 0.2)\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic flipping with capacity adjustment\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6541132139973883,
            6.413572698831558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    dominance_scores = (objectives[:, 0] * objectives[:, 1]) / (weights + 1e-6)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate adaptive value-weight ratios\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    weight_factor = 1 / (1 + np.exp(-(remaining_capacity / capacity - 0.5) * 5))\n    v1_ratio = value1_lst / (weight_lst + 1e-6) * (1 + weight_factor)\n    v2_ratio = value2_lst / (weight_lst + 1e-6) * (1 + weight_factor)\n\n    # Sort items by combined ratio\n    combined_ratio = (v1_ratio + v2_ratio) * (1 + np.random.rand() * 0.2)\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic flipping with capacity adjustment\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1 and np.random.rand() < 0.3:\n            new_solution[idx] = 0\n            remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering the dominance relationship between objectives, then generates a neighbor by strategically flipping items based on a novel \"value-weight balance\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with high cross-objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0]\n    v2_scores = objectives[:, 1]\n    dominance_scores = v1_scores + v2_scores - np.sqrt(v1_scores**2 + v2_scores**2)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight balance for both objectives\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    balance_diff = np.abs(v1_balance - v2_balance)\n\n    # Identify items to flip based on balance difference\n    flip_candidates = np.argsort(balance_diff)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_mode = 0  # 0: add, 1: remove\n\n    for idx in flip_candidates:\n        if flip_mode == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch mode when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            flip_mode = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8253804408665835,
            2.957975924015045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest dominance score\n    objectives = np.array([obj for _, obj in archive])\n    v1_scores = objectives[:, 0]\n    v2_scores = objectives[:, 1]\n    dominance_scores = v1_scores + v2_scores - np.sqrt(v1_scores**2 + v2_scores**2)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight balance for both objectives\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    balance_diff = np.abs(v1_balance - v2_balance)\n\n    # Identify items to flip based on balance difference\n    flip_candidates = np.argsort(balance_diff)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    flip_mode = 0  # 0: add, 1: remove\n\n    for idx in flip_candidates:\n        if flip_mode == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch mode when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            flip_mode = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm selects a solution from the archive by identifying the one with the highest \"objective diversity\" (difference between normalized objectives), then generates a neighbor by applying a novel \"multi-objective swap and shift\" operator that simultaneously considers both objectives, using a probabilistic approach to balance exploration and exploitation while ensuring feasibility through a dynamic weight adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.abs(obj1 - obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized objective values\n    norm_obj1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_obj2 = value2_lst / (np.max(value2_lst) + 1e-6)\n\n    # Calculate item scores based on objective diversity and weight\n    item_scores = np.abs(norm_obj1 - norm_obj2) / (weight_lst + 1e-6)\n    sorted_items = np.argsort(item_scores)[::-1]\n\n    # Dynamic weight adjustment mechanism\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    # Multi-objective swap and shift operator\n    for idx in sorted_items:\n        if phase == 0:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                # Probabilistic swap with another item\n                if np.random.rand() < 0.3 and len(np.where(new_solution == 1)[0]) > 1:\n                    swap_idx = np.random.choice(np.where(new_solution == 1)[0])\n                    if swap_idx != idx:\n                        new_solution[idx] = 0\n                        new_solution[swap_idx] = 1\n                        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if remaining_capacity < 0.2 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8335706634136479,
            2.3985375463962555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.abs(obj1 - obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized objective values\n    norm_obj1 = value1_lst / (np.max(value1_lst) + 1e-6)\n    norm_obj2 = value2_lst / (np.max(value2_lst) + 1e-6)\n\n    # Calculate item scores based on objective diversity and weight\n    item_scores = np.abs(norm_obj1 - norm_obj2) / (weight_lst + 1e-6)\n    sorted_items = np.argsort(item_scores)[::-1]\n\n    # Dynamic weight adjustment mechanism\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    # Multi-objective swap and shift operator\n    for idx in sorted_items:\n        if phase == 0:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                # Probabilistic swap with another item\n                if np.random.rand() < 0.3 and len(np.where(new_solution == 1)[0]) > 1:\n                    swap_idx = np.random.choice(np.where(new_solution == 1)[0])\n                    if swap_idx != idx:\n                        new_solution[idx] = 0\n                        new_solution[swap_idx] = 1\n                        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if remaining_capacity < 0.2 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective synergy score\" that combines item diversity and cross-objective contribution, then generates a neighbor by strategically flipping items based on a \"value-density synergy\" heuristic that prioritizes items with high potential to improve both objectives while maintaining feasibility through a two-phase adjustment process that dynamically balances objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective synergy score for each solution in archive\n    solutions = np.array([sol for sol, _ in archive])\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n\n    # Calculate diversity score (number of unique items)\n    diversity = np.sum(solutions, axis=1)\n    # Calculate cross-objective correlation\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    # Combine into synergy score\n    synergy_scores = diversity * (1 + abs(correlation))\n    selected_idx = np.argmax(synergy_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-density synergy for both objectives\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    # Calculate synergy score for each item\n    item_synergy = (v1_density + v2_density) * (1 + abs(np.corrcoef(v1_density, v2_density)[0, 1]))\n\n    # Identify items to flip based on synergy score\n    flip_candidates = np.argsort(item_synergy)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8347089141519937,
            6.046819031238556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective synergy score for each solution in archive\n    solutions = np.array([sol for sol, _ in archive])\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n\n    # Calculate diversity score (number of unique items)\n    diversity = np.sum(solutions, axis=1)\n    # Calculate cross-objective correlation\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    # Combine into synergy score\n    synergy_scores = diversity * (1 + abs(correlation))\n    selected_idx = np.argmax(synergy_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-density synergy for both objectives\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    # Calculate synergy score for each item\n    item_synergy = (v1_density + v2_density) * (1 + abs(np.corrcoef(v1_density, v2_density)[0, 1]))\n\n    # Identify items to flip based on synergy score\n    flip_candidates = np.argsort(item_synergy)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized values and weight efficiency, then generates a neighbor by strategically flipping items using a two-tiered approach that first considers items with high cross-objective synergy and then refines the solution by removing low-impact items to maintain feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hybrid objective score\n    objectives = np.array([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective synergy score\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    synergy_score = (v1_norm + v2_norm) * (1 - abs(v1_norm - v2_norm))\n\n    # First phase: Add items with high synergy and sufficient capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in np.argsort(synergy_score)[::-1]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Second phase: Remove low-impact items to free up space\n    impact_score = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    for idx in np.argsort(impact_score):\n        if new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8046942827050215,
            4.947042107582092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest hybrid objective score\n    objectives = np.array([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective synergy score\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    synergy_score = (v1_norm + v2_norm) * (1 - abs(v1_norm - v2_norm))\n\n    # First phase: Add items with high synergy and sufficient capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in np.argsort(synergy_score)[::-1]:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Second phase: Remove low-impact items to free up space\n    impact_score = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    for idx in np.argsort(impact_score):\n        if new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7848144319571662,
            10.682984173297882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8102503919261185,
            10.685490429401398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy, while using a different score function that emphasizes the ratio of objective values to their respective weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])  # Product of objectives\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio * v2_ratio) * (1 + abs_correlation)  # Product of ratios\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio * value2_lst)[::-1]  # Combined ratio\n        else:\n            flip_candidates = np.argsort(v2_ratio * value1_lst)[::-1]  # Combined ratio\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8812966852831849,
            6.124764174222946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] * obj[1] for _, obj in archive])  # Product of objectives\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio * v2_ratio) * (1 + abs_correlation)  # Product of ratios\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio * value2_lst)[::-1]  # Combined ratio\n        else:\n            flip_candidates = np.argsort(v2_ratio * value1_lst)[::-1]  # Combined ratio\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This new algorithm selects a solution from the archive with high potential for improvement by considering the ratio of objective values to weight, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio dominance\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high individual objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest ratio of objective values to weight\n    objectives = np.array([(obj[0] * obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    dominance_diff = np.abs(v1_dominance - v2_dominance)\n\n    # Identify items to flip based on dominance\n    if np.random.rand() > 0.5:\n        flip_candidates = np.argsort(v1_dominance)[::-1]\n    else:\n        flip_candidates = np.argsort(v2_dominance)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9071125402973561,
            5.44380196928978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest ratio of objective values to weight\n    objectives = np.array([(obj[0] * obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n    dominance_diff = np.abs(v1_dominance - v2_dominance)\n\n    # Identify items to flip based on dominance\n    if np.random.rand() > 0.5:\n        flip_candidates = np.argsort(v1_dominance)[::-1]\n    else:\n        flip_candidates = np.argsort(v2_dominance)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm selects a solution from the archive with high potential by considering the geometric mean of normalized objective values and weight efficiency, then generates a neighbor by flipping items based on a hybrid value-weight ratio metric that balances both objectives, ensuring feasibility through a capacity-adaptive flipping strategy that prioritizes items with high value synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest geometric mean of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / (max_values + 1e-6)\n    scores = np.sqrt(normalized[:, 0] * normalized[:, 1])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = scores * (weights / (weights + 1e-6))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight ratio\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    hybrid_ratio = (v1_ratio * value2_lst + v2_ratio * value1_lst) / (value1_lst + value2_lst + 1e-6)\n    flip_candidates = np.argsort(hybrid_ratio)[::-1]\n\n    # Capacity-adaptive flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8103744313002956,
            5.624519944190979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest geometric mean of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / (max_values + 1e-6)\n    scores = np.sqrt(normalized[:, 0] * normalized[:, 1])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = scores * (weights / (weights + 1e-6))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight ratio\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    hybrid_ratio = (v1_ratio * value2_lst + v2_ratio * value1_lst) / (value1_lst + value2_lst + 1e-6)\n    flip_candidates = np.argsort(hybrid_ratio)[::-1]\n\n    # Capacity-adaptive flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective diversity\" metric that considers both value and weight distributions, then generates a neighbor by strategically flipping items using a hybrid \"value-weight entropy\" heuristic that prioritizes items with high uncertainty in their contribution to both objectives, while ensuring feasibility through a probabilistic capacity-aware adjustment process that dynamically balances exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective diversity scores\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.std([obj1, obj2], axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight entropy\n    v1_entropy = - (value1_lst * np.log(value1_lst + 1e-6) + (1 - value1_lst) * np.log(1 - value1_lst + 1e-6))\n    v2_entropy = - (value2_lst * np.log(value2_lst + 1e-6) + (1 - value2_lst) * np.log(1 - value2_lst + 1e-6))\n    combined_entropy = v1_entropy + v2_entropy\n    flip_candidates = np.argsort(combined_entropy)[::-1]\n\n    # Probabilistic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high entropy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low entropy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_entropy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: random flip to explore\n    for idx in np.random.permutation(len(weight_lst)):\n        if np.random.rand() < 0.1:  # 10% probability to flip\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2752055297653835,
            6.380620151758194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective diversity scores\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.std([obj1, obj2], axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight entropy\n    v1_entropy = - (value1_lst * np.log(value1_lst + 1e-6) + (1 - value1_lst) * np.log(1 - value1_lst + 1e-6))\n    v2_entropy = - (value2_lst * np.log(value2_lst + 1e-6) + (1 - value2_lst) * np.log(1 - value2_lst + 1e-6))\n    combined_entropy = v1_entropy + v2_entropy\n    flip_candidates = np.argsort(combined_entropy)[::-1]\n\n    # Probabilistic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high entropy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            if np.random.rand() < 0.7:  # 70% probability to add\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low entropy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_entropy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: random flip to explore\n    for idx in np.random.permutation(len(weight_lst)):\n        if np.random.rand() < 0.1:  # 10% probability to flip\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the geometric median of objective values and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective space partitioning\" heuristic that prioritizes items located in the most promising regions of the objective space, while ensuring feasibility through a dynamic capacity-aware adjustment process that balances both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution closest to the geometric median of objective space\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    median_obj1 = np.median(obj1)\n    median_obj2 = np.median(obj2)\n    distances = np.sqrt((obj1 - median_obj1)**2 + (obj2 - median_obj2)**2)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space partitioning metrics\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    w_norm = weight_lst / (np.max(weight_lst) + 1e-6)\n\n    # Identify items in promising regions of objective space\n    promising_items = (v1_norm > 0.7) & (v2_norm > 0.7) & (w_norm < 0.6)\n    flip_candidates = np.where(promising_items)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.argsort(v1_norm + v2_norm)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add promising items\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: refine solution by flipping non-promising items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(v1_norm + v2_norm)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Final pass: add any remaining capacity with best value-weight ratio\n    if remaining_capacity > 0:\n        vw_ratio = (v1_norm + v2_norm) / (w_norm + 1e-6)\n        add_candidates = np.argsort(vw_ratio)[::-1]\n        for idx in add_candidates:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                if remaining_capacity <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9014680647938746,
            3.6578018069267273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution closest to the geometric median of objective space\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    median_obj1 = np.median(obj1)\n    median_obj2 = np.median(obj2)\n    distances = np.sqrt((obj1 - median_obj1)**2 + (obj2 - median_obj2)**2)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space partitioning metrics\n    v1_norm = value1_lst / (np.max(value1_lst) + 1e-6)\n    v2_norm = value2_lst / (np.max(value2_lst) + 1e-6)\n    w_norm = weight_lst / (np.max(weight_lst) + 1e-6)\n\n    # Identify items in promising regions of objective space\n    promising_items = (v1_norm > 0.7) & (v2_norm > 0.7) & (w_norm < 0.6)\n    flip_candidates = np.where(promising_items)[0]\n    if len(flip_candidates) == 0:\n        flip_candidates = np.argsort(v1_norm + v2_norm)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add promising items\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: refine solution by flipping non-promising items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(v1_norm + v2_norm)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Final pass: add any remaining capacity with best value-weight ratio\n    if remaining_capacity > 0:\n        vw_ratio = (v1_norm + v2_norm) / (w_norm + 1e-6)\n        add_candidates = np.argsort(vw_ratio)[::-1]\n        for idx in add_candidates:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                if remaining_capacity <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the geometric median of objective values and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective space partitioning\" heuristic that prioritizes items in the least explored regions of the Pareto front, while ensuring feasibility through a dynamic capacity-aware partitioning process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution closest to the geometric median of the objective space\n    objectives = np.array([obj for _, obj in archive])\n    median_obj = np.median(objectives, axis=0)\n    distances = np.linalg.norm(objectives - median_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios and objective space partitioning\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    v1_normalized = (v1_ratio - np.min(v1_ratio)) / (np.max(v1_ratio) - np.min(v1_ratio) + 1e-6)\n    v2_normalized = (v2_ratio - np.min(v2_ratio)) / (np.max(v2_ratio) - np.min(v2_ratio) + 1e-6)\n\n    # Partition the objective space into 4 quadrants and prioritize items in the least explored quadrant\n    quadrant_counts = np.zeros(4)\n    for sol, obj in archive:\n        v1, v2 = obj\n        if v1 >= median_obj[0] and v2 >= median_obj[1]:\n            quadrant_counts[0] += 1\n        elif v1 < median_obj[0] and v2 >= median_obj[1]:\n            quadrant_counts[1] += 1\n        elif v1 < median_obj[0] and v2 < median_obj[1]:\n            quadrant_counts[2] += 1\n        else:\n            quadrant_counts[3] += 1\n\n    least_explored_quadrant = np.argmin(quadrant_counts)\n\n    # Select items to flip based on quadrant priority\n    if least_explored_quadrant == 0:  # High value1, high value2\n        flip_candidates = np.argsort(v1_normalized + v2_normalized)[::-1]\n    elif least_explored_quadrant == 1:  # Low value1, high value2\n        flip_candidates = np.argsort(v2_normalized - v1_normalized)[::-1]\n    elif least_explored_quadrant == 2:  # Low value1, low value2\n        flip_candidates = np.argsort(-(v1_normalized + v2_normalized))[::-1]\n    else:  # High value1, low value2\n        flip_candidates = np.argsort(v1_normalized - v2_normalized)[::-1]\n\n    # Dynamic capacity-aware flipping with quadrant-aware adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items prioritized by quadrant\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items that violate capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(flip_candidates)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8320865350461328,
            3.014421194791794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution closest to the geometric median of the objective space\n    objectives = np.array([obj for _, obj in archive])\n    median_obj = np.median(objectives, axis=0)\n    distances = np.linalg.norm(objectives - median_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios and objective space partitioning\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    v1_normalized = (v1_ratio - np.min(v1_ratio)) / (np.max(v1_ratio) - np.min(v1_ratio) + 1e-6)\n    v2_normalized = (v2_ratio - np.min(v2_ratio)) / (np.max(v2_ratio) - np.min(v2_ratio) + 1e-6)\n\n    # Partition the objective space into 4 quadrants and prioritize items in the least explored quadrant\n    quadrant_counts = np.zeros(4)\n    for sol, obj in archive:\n        v1, v2 = obj\n        if v1 >= median_obj[0] and v2 >= median_obj[1]:\n            quadrant_counts[0] += 1\n        elif v1 < median_obj[0] and v2 >= median_obj[1]:\n            quadrant_counts[1] += 1\n        elif v1 < median_obj[0] and v2 < median_obj[1]:\n            quadrant_counts[2] += 1\n        else:\n            quadrant_counts[3] += 1\n\n    least_explored_quadrant = np.argmin(quadrant_counts)\n\n    # Select items to flip based on quadrant priority\n    if least_explored_quadrant == 0:  # High value1, high value2\n        flip_candidates = np.argsort(v1_normalized + v2_normalized)[::-1]\n    elif least_explored_quadrant == 1:  # Low value1, high value2\n        flip_candidates = np.argsort(v2_normalized - v1_normalized)[::-1]\n    elif least_explored_quadrant == 2:  # Low value1, low value2\n        flip_candidates = np.argsort(-(v1_normalized + v2_normalized))[::-1]\n    else:  # High value1, low value2\n        flip_candidates = np.argsort(v1_normalized - v2_normalized)[::-1]\n\n    # Dynamic capacity-aware flipping with quadrant-aware adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items prioritized by quadrant\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items that violate capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(flip_candidates)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high objective diversity and generates a neighbor by strategically flipping items based on a novel \"objective trade-off dominance\" heuristic, which identifies items that could improve both objectives when combined with existing items, while ensuring feasibility through a dynamic capacity-aware two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective trade-off dominance\n    v1_tradeoff = value1_lst / (value2_lst + 1e-6)\n    v2_tradeoff = value2_lst / (value1_lst + 1e-6)\n    combined_tradeoff = v1_tradeoff + v2_tradeoff\n\n    # Identify items to flip based on trade-off dominance\n    flip_candidates = np.argsort(combined_tradeoff)[::-1]\n\n    # Dynamic capacity-aware two-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.796374313417997,
            1.5386342108249664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective trade-off dominance\n    v1_tradeoff = value1_lst / (value2_lst + 1e-6)\n    v2_tradeoff = value2_lst / (value1_lst + 1e-6)\n    combined_tradeoff = v1_tradeoff + v2_tradeoff\n\n    # Identify items to flip based on trade-off dominance\n    flip_candidates = np.argsort(combined_tradeoff)[::-1]\n\n    # Dynamic capacity-aware two-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8258548167757633,
            4.795395195484161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7811177580293711,
            9.417846590280533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their normalized value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective balance\" heuristic that prioritizes items with high potential to improve both objectives proportionally, while ensuring feasibility through an adaptive capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_ratio = v1_ratio + v2_ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Adaptive capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8214884910178537,
            9.683619260787964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (normalized ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate normalized value-weight ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_ratio = v1_ratio + v2_ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Adaptive capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel dominance-aware score that combines objective values and their relative improvements, then generates a neighbor by strategically flipping items based on a two-phase \"objective-balanced ratio\" heuristic, ensuring feasibility through adaptive weight adjustment that prioritizes items with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance-aware scores\n    objectives = np.array([obj for _, obj in archive])\n    max_v1, max_v2 = np.max(objectives, axis=0)\n    scores = np.zeros(len(archive))\n\n    for i, (sol, (v1, v2)) in enumerate(archive):\n        dominance = (v1 / max_v1 if max_v1 > 0 else 0) + (v2 / max_v2 if max_v2 > 0 else 0)\n        improvement_potential = (max_v1 - v1) * (max_v2 - v2)\n        scores[i] = dominance * improvement_potential\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective-balanced ratios\n    total_v1 = archive[selected_idx][1][0]\n    total_v2 = archive[selected_idx][1][1]\n    balance_factor = total_v1 / (total_v2 + 1e-6) if total_v2 > 0 else 1.0\n\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    balanced_ratio = v1_ratio * (1 + balance_factor) + v2_ratio * (1 - balance_factor)\n\n    # Two-phase flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_candidates = np.argsort(balanced_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adaptive phase switching\n        if phase == 0 and current_weight > 0.8 * capacity:\n            phase = 1\n        elif phase == 1 and current_weight < 0.5 * capacity:\n            phase = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7750031754900379,
            3.871782124042511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance-aware scores\n    objectives = np.array([obj for _, obj in archive])\n    max_v1, max_v2 = np.max(objectives, axis=0)\n    scores = np.zeros(len(archive))\n\n    for i, (sol, (v1, v2)) in enumerate(archive):\n        dominance = (v1 / max_v1 if max_v1 > 0 else 0) + (v2 / max_v2 if max_v2 > 0 else 0)\n        improvement_potential = (max_v1 - v1) * (max_v2 - v2)\n        scores[i] = dominance * improvement_potential\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective-balanced ratios\n    total_v1 = archive[selected_idx][1][0]\n    total_v2 = archive[selected_idx][1][1]\n    balance_factor = total_v1 / (total_v2 + 1e-6) if total_v2 > 0 else 1.0\n\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    balanced_ratio = v1_ratio * (1 + balance_factor) + v2_ratio * (1 - balance_factor)\n\n    # Two-phase flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_candidates = np.argsort(balanced_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Adaptive phase switching\n        if phase == 0 and current_weight > 0.8 * capacity:\n            phase = 1\n        elif phase == 1 and current_weight < 0.5 * capacity:\n            phase = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then generates a neighbor by strategically swapping items between the current solution and a random high-value subset, using a novel \"value-weight synergy\" heuristic that prioritizes items with high potential to improve both objectives while maintaining feasibility through a probabilistic capacity adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective value\n    combined_obj = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight synergy scores\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    combined_synergy = v1_synergy + v2_synergy\n\n    # Create a random high-value subset\n    high_value_indices = np.argsort(combined_synergy)[::-1][:len(weight_lst)//2]\n    random_subset = np.random.choice(high_value_indices, size=min(5, len(high_value_indices)), replace=False)\n\n    # Swap items between current solution and random subset\n    for idx in random_subset:\n        if np.random.rand() < 0.7:  # 70% chance to consider swapping\n            if new_solution[idx] == 0:\n                # Try to add item if it fits\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n            else:\n                # Try to remove item to make space\n                new_solution[idx] = 0\n\n    # Probabilistic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for idx in excess_items:\n            if excess <= 0:\n                break\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.45132906144433615,
            1.6421393752098083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective value\n    combined_obj = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmax(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight synergy scores\n    v1_synergy = value1_lst / (weight_lst + 1e-6)\n    v2_synergy = value2_lst / (weight_lst + 1e-6)\n    combined_synergy = v1_synergy + v2_synergy\n\n    # Create a random high-value subset\n    high_value_indices = np.argsort(combined_synergy)[::-1][:len(weight_lst)//2]\n    random_subset = np.random.choice(high_value_indices, size=min(5, len(high_value_indices)), replace=False)\n\n    # Swap items between current solution and random subset\n    for idx in random_subset:\n        if np.random.rand() < 0.7:  # 70% chance to consider swapping\n            if new_solution[idx] == 0:\n                # Try to add item if it fits\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n            else:\n                # Try to remove item to make space\n                new_solution[idx] = 0\n\n    # Probabilistic capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for idx in excess_items:\n            if excess <= 0:\n                break\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_ratio = v1_ratio + v2_ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9312895419223943,
            2.0052679777145386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_ratio = v1_ratio + v2_ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high ratio\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_ratio)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with balanced objective values, then generates a neighbor by strategically flipping items based on a novel \"value-efficiency\" heuristic that considers both objectives' marginal contributions while maintaining feasibility through a dynamic weight adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most balanced objectives (minimize difference)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.abs(obj1 - obj2)\n    selected_idx = np.argmin(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value efficiency for each objective\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high combined efficiency\n    combined_efficiency = v1_efficiency + v2_efficiency\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Dynamic weight-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high efficiency\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low efficiency\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7314399441441617,
            11.135817527770996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most balanced objectives (minimize difference)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.abs(obj1 - obj2)\n    selected_idx = np.argmin(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value efficiency for each objective\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high combined efficiency\n    combined_efficiency = v1_efficiency + v2_efficiency\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Dynamic weight-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high efficiency\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low efficiency\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive based on the Pareto dominance front, then generates a neighbor by strategically flipping items using a hybrid approach combining value-density and dominance-aware selection, followed by a feasibility-preserving adjustment phase that prioritizes items with high cross-objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution from Pareto front if possible, otherwise select randomly\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] >= obj[0] and other_obj[1] >= obj[1] and (other_obj[0] > obj[0] or other_obj[1] > obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-density scores\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection of flip candidates\n    if np.random.rand() > 0.5:\n        # Dominance-aware selection\n        flip_candidates = np.argsort(base_solution * v1_density + (1 - base_solution) * v2_density)[::-1]\n    else:\n        # Value-density combined selection\n        combined_density = v1_density + v2_density\n        flip_candidates = np.argsort(combined_density)[::-1]\n\n    # Feasibility-preserving adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7449848115461356,
            3.2515814304351807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution from Pareto front if possible, otherwise select randomly\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] >= obj[0] and other_obj[1] >= obj[1] and (other_obj[0] > obj[0] or other_obj[1] > obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-density scores\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid selection of flip candidates\n    if np.random.rand() > 0.5:\n        # Dominance-aware selection\n        flip_candidates = np.argsort(base_solution * v1_density + (1 - base_solution) * v2_density)[::-1]\n    else:\n        # Value-density combined selection\n        combined_density = v1_density + v2_density\n        flip_candidates = np.argsort(combined_density)[::-1]\n\n    # Feasibility-preserving adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.800880811095612,
            1.9028286337852478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective balance\" heuristic that prioritizes items with high potential to improve one objective while maintaining a balanced trade-off with the other, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (min-max ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.minimum(obj1, obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve one objective while maintaining balance\n    combined_balance = (v1_balance + v2_balance) / 2\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8568359621653517,
            11.112950444221497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (min-max ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.minimum(obj1, obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve one objective while maintaining balance\n    combined_balance = (v1_balance + v2_balance) / 2\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9681586038101224,
            5.825189769268036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7534621024307104,
            2.9952037632465363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.783762949541952,
            5.359463751316071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objectives, then generates a neighbor by strategically flipping items with high cross-objective synergy using a hybrid of value-weight ratio and dominance-based selection, ensuring feasibility through a capacity-aware multi-phase adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid selection metric: value-weight ratio weighted by dominance\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    dominance = np.maximum(v1_ratio, v2_ratio) * (1 + np.abs(v1_ratio - v2_ratio))\n    hybrid_metric = dominance * (v1_ratio + v2_ratio)\n    flip_candidates = np.argsort(hybrid_metric)[::-1]\n\n    # Multi-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Finally try to swap items\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] + weight_lst[(idx + 1) % len(weight_lst)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[(idx + 1) % len(weight_lst)] = 1\n                current_weight = current_weight - weight_lst[idx] + weight_lst[(idx + 1) % len(weight_lst)]\n\n        # Switch phase based on capacity utilization\n        if current_weight > 0.6 * capacity and phase == 0:\n            phase = 1\n        elif current_weight < 0.3 * capacity and phase == 1:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.7503944693498465,
            3.6984683573246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective diversity (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid selection metric: value-weight ratio weighted by dominance\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    dominance = np.maximum(v1_ratio, v2_ratio) * (1 + np.abs(v1_ratio - v2_ratio))\n    hybrid_metric = dominance * (v1_ratio + v2_ratio)\n    flip_candidates = np.argsort(hybrid_metric)[::-1]\n\n    # Multi-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items, 2: swap items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Finally try to swap items\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] + weight_lst[(idx + 1) % len(weight_lst)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[(idx + 1) % len(weight_lst)] = 1\n                current_weight = current_weight - weight_lst[idx] + weight_lst[(idx + 1) % len(weight_lst)]\n\n        # Switch phase based on capacity utilization\n        if current_weight > 0.6 * capacity and phase == 0:\n            phase = 1\n        elif current_weight < 0.3 * capacity and phase == 1:\n            phase = 2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective balance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (min-max ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.minimum(obj1, obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_balance = (v1_balance + v2_balance) / 2\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.770016842861623,
            3.1082628667354584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective balance (min-max ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance = np.minimum(obj1, obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective balance ratios\n    v1_balance = value1_lst / (value2_lst + 1e-6)\n    v2_balance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_balance = (v1_balance + v2_balance) / 2\n    flip_candidates = np.argsort(combined_balance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high balance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low balance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_balance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7128661018184487,
            2.2391145825386047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7955378365212165,
            3.089795410633087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.976073469480651,
            2.1383263170719147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects a solution from the archive using a dynamic scoring mechanism that combines objective values with their variance and weight efficiency, then generates a neighbor by strategically flipping items based on a hybrid value-weight ratio and dominance ranking heuristic, ensuring feasibility through a three-phase adjustment process that prioritizes items with high cross-objective synergy and dominance potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dynamic scores combining objectives and their variance\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    obj1_var = np.var(obj1)\n    obj2_var = np.var(obj2)\n    scores = (obj1 + obj2) * (1 + obj1_var + obj2_var) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight ratios and dominance ranking\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    dominance = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    hybrid_score = (v1_ratio + v2_ratio + dominance) * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Three-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add high-scoring items, 1: swap items, 2: remove low-scoring items\n\n    for idx in np.argsort(hybrid_score)[::-1]:\n        if phase == 0:  # Add high-scoring items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Swap items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Remove low-scoring items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phases based on capacity utilization\n        if current_weight > 0.8 * capacity:\n            phase = 1\n        elif current_weight > 0.95 * capacity:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.8299338940225736,
            8.527674049139023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dynamic scores combining objectives and their variance\n    objectives = np.array([obj for _, obj in archive])\n    obj1 = objectives[:, 0]\n    obj2 = objectives[:, 1]\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    obj1_var = np.var(obj1)\n    obj2_var = np.var(obj2)\n    scores = (obj1 + obj2) * (1 + obj1_var + obj2_var) / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid value-weight ratios and dominance ranking\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    dominance = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n    hybrid_score = (v1_ratio + v2_ratio + dominance) * (1 + np.abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n\n    # Three-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add high-scoring items, 1: swap items, 2: remove low-scoring items\n\n    for idx in np.argsort(hybrid_score)[::-1]:\n        if phase == 0:  # Add high-scoring items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Swap items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Remove low-scoring items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phases based on capacity utilization\n        if current_weight > 0.8 * capacity:\n            phase = 1\n        elif current_weight > 0.95 * capacity:\n            phase = 2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the Pareto front properties and then generates a neighbor through a novel \"objective space partitioning\" approach that systematically explores trade-off regions by flipping items based on their contribution to both objectives, while dynamically balancing capacity constraints through a hybrid of greedy and probabilistic selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution closest to the knee point (trade-off region)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    normalized_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    distances = normalized_obj1 + normalized_obj2 - normalized_obj1 * normalized_obj2\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space partitioning\n    v1_partition = value1_lst / (np.sum(value1_lst) + 1e-6)\n    v2_partition = value2_lst / (np.sum(value2_lst) + 1e-6)\n    partition_score = v1_partition * v2_partition\n\n    # Hybrid selection strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First phase: probabilistic selection based on partition score\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            if np.random.rand() < partition_score[i]:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    # Second phase: greedy removal of low partition score items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(partition_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7338526465199142,
            2.2505495250225067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution closest to the knee point (trade-off region)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    normalized_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-6)\n    normalized_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-6)\n    distances = normalized_obj1 + normalized_obj2 - normalized_obj1 * normalized_obj2\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective space partitioning\n    v1_partition = value1_lst / (np.sum(value1_lst) + 1e-6)\n    v2_partition = value2_lst / (np.sum(value2_lst) + 1e-6)\n    partition_score = v1_partition * v2_partition\n\n    # Hybrid selection strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First phase: probabilistic selection based on partition score\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            if np.random.rand() < partition_score[i]:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    # Second phase: greedy removal of low partition score items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(partition_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values weighted by their variance and the current solution's dominance, then generates a neighbor by strategically flipping items based on a novel \"value-variance ratio\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with high cross-objective variance and dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective variances\n    v1_values = np.array([obj[0] for _, obj in archive])\n    v2_values = np.array([obj[1] for _, obj in archive])\n    v1_var = np.var(v1_values)\n    v2_var = np.var(v2_values)\n\n    # Select solution with highest weighted objective score\n    objectives = np.array([(obj[0] * v1_var + obj[1] * v2_var) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-variance ratios\n    v1_ratio = value1_lst * (1 + v1_var)\n    v2_ratio = value2_lst * (1 + v2_var)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Identify items to flip based on value-variance ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        # Early termination if capacity is reached\n        if current_weight >= capacity:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.45088462527826156,
            5.1660716235637665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective variances\n    v1_values = np.array([obj[0] for _, obj in archive])\n    v2_values = np.array([obj[1] for _, obj in archive])\n    v1_var = np.var(v1_values)\n    v2_var = np.var(v2_values)\n\n    # Select solution with highest weighted objective score\n    objectives = np.array([(obj[0] * v1_var + obj[1] * v2_var) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-variance ratios\n    v1_ratio = value1_lst * (1 + v1_var)\n    v2_ratio = value2_lst * (1 + v2_var)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Identify items to flip based on value-variance ratio\n    flip_candidates = np.argsort(combined_ratio)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        # Early termination if capacity is reached\n        if current_weight >= capacity:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both objective correlations and dominance relationships.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy = (v1_ratio + v2_ratio) * np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n\n    # Identify items to flip based on synergy\n    flip_candidates = np.argsort(synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with two-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9092626186478681,
            5.884048968553543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy scores\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy = (v1_ratio + v2_ratio) * np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n\n    # Identify items to flip based on synergy\n    flip_candidates = np.argsort(synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with two-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    if current_weight > capacity:\n        remove_candidates = np.argsort(synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the correlation between objectives and their normalized value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective correlation\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective correlation (pearson correlation)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    selected_idx = np.argmax(np.abs(correlation))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlation ratios\n    v1_correlation = value1_lst / (np.mean(value1_lst) + 1e-6)\n    v2_correlation = value2_lst / (np.mean(value2_lst) + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_correlation = v1_correlation * v2_correlation\n    flip_candidates = np.argsort(combined_correlation)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high correlation\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low correlation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_correlation)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9118222267065783,
            3.8611471951007843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective correlation (pearson correlation)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    correlation = np.corrcoef(obj1, obj2)[0, 1]\n    selected_idx = np.argmax(np.abs(correlation))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective correlation ratios\n    v1_correlation = value1_lst / (np.mean(value1_lst) + 1e-6)\n    v2_correlation = value2_lst / (np.mean(value2_lst) + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_correlation = v1_correlation * v2_correlation\n    flip_candidates = np.argsort(combined_correlation)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high correlation\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low correlation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_correlation)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in both objectives and its potential for improvement, then generates a neighbor by strategically flipping items with high cross-objective value ratios while maintaining feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio * v2_ratio) ** 0.5  # Geometric mean for synergy\n\n    # Sort items by cross-ratio and current inclusion status\n    flip_order = np.argsort(cross_ratio)[::-1]\n    current_in = np.where(new_solution == 1)[0]\n    current_out = np.where(new_solution == 0)[0]\n\n    # Dynamic adjustment phases\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add high-ratio items, 1: remove low-ratio items\n\n    for idx in flip_order:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity and phase == 0:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    while current_weight > capacity:\n        remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7700618456155288,
            4.783805429935455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate cross-objective value ratios\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    cross_ratio = (v1_ratio * v2_ratio) ** 0.5  # Geometric mean for synergy\n\n    # Sort items by cross-ratio and current inclusion status\n    flip_order = np.argsort(cross_ratio)[::-1]\n    current_in = np.where(new_solution == 1)[0]\n    current_out = np.where(new_solution == 0)[0]\n\n    # Dynamic adjustment phases\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add high-ratio items, 1: remove low-ratio items\n\n    for idx in flip_order:\n        if phase == 0:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity and phase == 0:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    while current_weight > capacity:\n        remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This algorithm selects a solution from the archive by identifying items with high cross-objective trade-off potential, then generates a neighbor by strategically flipping items based on a novel \"value-weight trade-off diversity\" heuristic, ensuring feasibility through a multi-phase adjustment process that balances both objectives while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off diversity (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    tradeoff = np.abs(obj1 - obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(tradeoff)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight trade-off diversity\n    v1_tradeoff = value1_lst / (weight_lst + 1e-6)\n    v2_tradeoff = value2_lst / (weight_lst + 1e-6)\n    diversity = np.abs(v1_tradeoff - v2_tradeoff)\n\n    # Identify items with high trade-off diversity\n    flip_candidates = np.argsort(diversity)[::-1]\n\n    # Multi-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(weight_lst / (value1_lst + value2_lst + 1e-6))\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8434621033858999,
            2.419334053993225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest trade-off diversity (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    tradeoff = np.abs(obj1 - obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(tradeoff)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight trade-off diversity\n    v1_tradeoff = value1_lst / (weight_lst + 1e-6)\n    v2_tradeoff = value2_lst / (weight_lst + 1e-6)\n    diversity = np.abs(v1_tradeoff - v2_tradeoff)\n\n    # Identify items with high trade-off diversity\n    flip_candidates = np.argsort(diversity)[::-1]\n\n    # Multi-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(weight_lst / (value1_lst + value2_lst + 1e-6))\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest \"objective balance\" (minimizing the variance between objectives) and generates a neighbor by strategically flipping items based on a novel \"weight-adjusted dominance\" heuristic that prioritizes items with high potential to improve both objectives while considering their weight efficiency, ensuring feasibility through a multi-phase adjustment process that balances capacity utilization and objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most balanced objectives (minimize variance)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    obj_variance = np.var(np.column_stack((obj1, obj2)), axis=1)\n    selected_idx = np.argmin(obj_variance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate weight-adjusted dominance scores\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    combined_efficiency = v1_efficiency + v2_efficiency\n\n    # Identify items with high potential to improve both objectives\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Multi-phase adjustment process\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Phase 1: Add high-efficiency items\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Phase 2: Remove low-efficiency items if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Phase 3: Local swaps for better objective balance\n    for _ in range(3):\n        # Find potential swaps\n        excluded = np.where(new_solution == 0)[0]\n        included = np.where(new_solution == 1)[0]\n\n        for in_idx in included:\n            for ex_idx in excluded:\n                if weight_lst[ex_idx] <= weight_lst[in_idx] + remaining_capacity:\n                    # Calculate objective improvements\n                    delta_v1 = value1_lst[ex_idx] - value1_lst[in_idx]\n                    delta_v2 = value2_lst[ex_idx] - value2_lst[in_idx]\n\n                    # Accept swap if improves at least one objective\n                    if delta_v1 > 0 or delta_v2 > 0:\n                        new_solution[in_idx], new_solution[ex_idx] = 0, 1\n                        remaining_capacity += weight_lst[in_idx] - weight_lst[ex_idx]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8863898266457315,
            5.882972568273544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most balanced objectives (minimize variance)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    obj_variance = np.var(np.column_stack((obj1, obj2)), axis=1)\n    selected_idx = np.argmin(obj_variance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate weight-adjusted dominance scores\n    v1_efficiency = value1_lst / (weight_lst + 1e-6)\n    v2_efficiency = value2_lst / (weight_lst + 1e-6)\n    combined_efficiency = v1_efficiency + v2_efficiency\n\n    # Identify items with high potential to improve both objectives\n    flip_candidates = np.argsort(combined_efficiency)[::-1]\n\n    # Multi-phase adjustment process\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Phase 1: Add high-efficiency items\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Phase 2: Remove low-efficiency items if over capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_efficiency)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Phase 3: Local swaps for better objective balance\n    for _ in range(3):\n        # Find potential swaps\n        excluded = np.where(new_solution == 0)[0]\n        included = np.where(new_solution == 1)[0]\n\n        for in_idx in included:\n            for ex_idx in excluded:\n                if weight_lst[ex_idx] <= weight_lst[in_idx] + remaining_capacity:\n                    # Calculate objective improvements\n                    delta_v1 = value1_lst[ex_idx] - value1_lst[in_idx]\n                    delta_v2 = value2_lst[ex_idx] - value2_lst[in_idx]\n\n                    # Accept swap if improves at least one objective\n                    if delta_v1 > 0 or delta_v2 > 0:\n                        new_solution[in_idx], new_solution[ex_idx] = 0, 1\n                        remaining_capacity += weight_lst[in_idx] - weight_lst[ex_idx]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance score\" that combines normalized objective values with item density, then generates a neighbor by strategically flipping items using a two-phase approach that prioritizes high-density items while maintaining feasibility through dynamic capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores for each solution\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    dominance_scores = np.mean(objectives / (max_obj + 1e-6), axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item densities for both objectives\n    density1 = value1_lst / (weight_lst + 1e-6)\n    density2 = value2_lst / (weight_lst + 1e-6)\n    combined_density = (density1 + density2) / 2\n\n    # Two-phase flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_order = np.argsort(combined_density)[::-1]\n\n    for idx in flip_order:\n        if phase == 0:  # Addition phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Removal phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when reaching 80% capacity\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    while current_weight > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = np.random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8352889163540511,
            3.3007925152778625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores for each solution\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    dominance_scores = np.mean(objectives / (max_obj + 1e-6), axis=1)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item densities for both objectives\n    density1 = value1_lst / (weight_lst + 1e-6)\n    density2 = value2_lst / (weight_lst + 1e-6)\n    combined_density = (density1 + density2) / 2\n\n    # Two-phase flipping strategy\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    flip_order = np.argsort(combined_density)[::-1]\n\n    for idx in flip_order:\n        if phase == 0:  # Addition phase\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Removal phase\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when reaching 80% capacity\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    # Final adjustment to ensure feasibility\n    while current_weight > capacity:\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break\n        remove_idx = np.random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score that combines normalized objective values with their harmonic mean, then generates neighbors by strategically flipping items based on a novel \"value-weight dominance\" heuristic, ensuring feasibility through a dynamic capacity adjustment phase that prioritizes items with high cross-objective balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest harmonic mean of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj1 = np.max(objectives[:, 0])\n    max_obj2 = np.max(objectives[:, 1])\n    norm_obj1 = objectives[:, 0] / (max_obj1 + 1e-6)\n    norm_obj2 = objectives[:, 1] / (max_obj2 + 1e-6)\n    harmonic_scores = 2 * (norm_obj1 * norm_obj2) / (norm_obj1 + norm_obj2 + 1e-6)\n    selected_idx = np.argmax(harmonic_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = (value1_lst / (weight_lst + 1e-6)) * (value1_lst / (np.sum(value1_lst) + 1e-6))\n    v2_dominance = (value2_lst / (weight_lst + 1e-6)) * (value2_lst / (np.sum(value2_lst) + 1e-6))\n    combined_dominance = v1_dominance + v2_dominance\n\n    # Identify flip candidates based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity adjustment flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity * 1.1:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when exceeding 80% capacity\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8215183418052635,
            3.6993464529514313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest harmonic mean of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj1 = np.max(objectives[:, 0])\n    max_obj2 = np.max(objectives[:, 1])\n    norm_obj1 = objectives[:, 0] / (max_obj1 + 1e-6)\n    norm_obj2 = objectives[:, 1] / (max_obj2 + 1e-6)\n    harmonic_scores = 2 * (norm_obj1 * norm_obj2) / (norm_obj1 + norm_obj2 + 1e-6)\n    selected_idx = np.argmax(harmonic_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = (value1_lst / (weight_lst + 1e-6)) * (value1_lst / (np.sum(value1_lst) + 1e-6))\n    v2_dominance = (value2_lst / (weight_lst + 1e-6)) * (value2_lst / (np.sum(value2_lst) + 1e-6))\n    combined_dominance = v1_dominance + v2_dominance\n\n    # Identify flip candidates based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity adjustment flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity * 1.1:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when exceeding 80% capacity\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    }
]