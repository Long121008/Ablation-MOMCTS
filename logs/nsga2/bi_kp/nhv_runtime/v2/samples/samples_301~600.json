[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously while ensuring feasibility through a dynamic capacity-aware adjustment process, and further refines the solution by considering the correlation between the objectives and their impact on the knapsack's capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy ratios\n    v1_synergy = value1_lst / (np.sqrt(value2_lst) + 1e-6)\n    v2_synergy = value2_lst / (np.sqrt(value1_lst) + 1e-6)\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-based prioritization\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: refine solution by considering objective correlation\n    correlation = np.corrcoef(value1_lst, value2_lst)[0, 1]\n    if abs(correlation) > 0.3:\n        # If objectives are correlated, prioritize items that improve both\n        for idx in flip_candidates:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n                    if remaining_capacity <= 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8822241921355487,
            5.168394446372986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective synergy (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy ratios\n    v1_synergy = value1_lst / (np.sqrt(value2_lst) + 1e-6)\n    v2_synergy = value2_lst / (np.sqrt(value1_lst) + 1e-6)\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-based prioritization\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: refine solution by considering objective correlation\n    correlation = np.corrcoef(value1_lst, value2_lst)[0, 1]\n    if abs(correlation) > 0.3:\n        # If objectives are correlated, prioritize items that improve both\n        for idx in flip_candidates:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n                    if remaining_capacity <= 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective dominance score\" that considers both individual objective values and their relative improvement potential, then generates a neighbor by strategically flipping items using a \"synergy-aware\" heuristic that prioritizes items with high cross-objective value ratios and low weight, while maintaining feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores based on potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    dominance_scores = np.prod((objectives - max_obj) / (max_obj + 1e-6), axis=1)\n    selected_idx = np.argmin(dominance_scores)  # Select most potentially improvable solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate synergy-aware scores\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = (v1_ratio + v2_ratio) * (1 - abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 60% utilized\n        if remaining_capacity < 0.4 * capacity:\n            phase = 1\n\n        if remaining_capacity <= 0:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9472550554642283,
            4.316924303770065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate dominance scores based on potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    dominance_scores = np.prod((objectives - max_obj) / (max_obj + 1e-6), axis=1)\n    selected_idx = np.argmin(dominance_scores)  # Select most potentially improvable solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate synergy-aware scores\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    synergy_score = (v1_ratio + v2_ratio) * (1 - abs(np.corrcoef(v1_ratio, v2_ratio)[0, 1]))\n    flip_candidates = np.argsort(synergy_score)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n        else:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n        # Switch phase when capacity is 60% utilized\n        if remaining_capacity < 0.4 * capacity:\n            phase = 1\n\n        if remaining_capacity <= 0:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective balance score\" that considers both objective values and their ratios, then generates a neighbor by strategically flipping items using a hybrid approach that combines dominance-based selection with capacity-aware adjustment, ensuring feasibility and potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective balance score (weighted combination of objectives and their ratios)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance_score = (obj1 + obj2) * (obj1 / (obj2 + 1e-6)) + (obj1 + obj2) * (obj2 / (obj1 + 1e-6))\n    selected_idx = np.argmax(balance_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item selection scores based on both objectives and their ratios\n    v1_ratio = value1_lst / (value2_lst + 1e-6)\n    v2_ratio = value2_lst / (value1_lst + 1e-6)\n    item_scores = (value1_lst + value2_lst) * (v1_ratio + v2_ratio)\n\n    # Identify items to flip based on current solution status\n    flip_candidates = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            flip_candidates.append((i, item_scores[i], weight_lst[i]))\n        else:\n            flip_candidates.append((i, -item_scores[i], -weight_lst[i]))\n\n    # Sort candidates by score (descending)\n    flip_candidates.sort(key=lambda x: x[1], reverse=True)\n\n    # Apply flips while maintaining feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx, _, delta_weight in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + delta_weight <= capacity:\n            new_solution[idx] = 1\n            current_weight += delta_weight\n        elif new_solution[idx] == 1 and current_weight + delta_weight >= 0:\n            new_solution[idx] = 0\n            current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.921859793202183,
            4.862875998020172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective balance score (weighted combination of objectives and their ratios)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    balance_score = (obj1 + obj2) * (obj1 / (obj2 + 1e-6)) + (obj1 + obj2) * (obj2 / (obj1 + 1e-6))\n    selected_idx = np.argmax(balance_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate item selection scores based on both objectives and their ratios\n    v1_ratio = value1_lst / (value2_lst + 1e-6)\n    v2_ratio = value2_lst / (value1_lst + 1e-6)\n    item_scores = (value1_lst + value2_lst) * (v1_ratio + v2_ratio)\n\n    # Identify items to flip based on current solution status\n    flip_candidates = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            flip_candidates.append((i, item_scores[i], weight_lst[i]))\n        else:\n            flip_candidates.append((i, -item_scores[i], -weight_lst[i]))\n\n    # Sort candidates by score (descending)\n    flip_candidates.sort(key=lambda x: x[1], reverse=True)\n\n    # Apply flips while maintaining feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    for idx, _, delta_weight in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + delta_weight <= capacity:\n            new_solution[idx] = 1\n            current_weight += delta_weight\n        elif new_solution[idx] == 1 and current_weight + delta_weight >= 0:\n            new_solution[idx] = 0\n            current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with high objective values and low weight, then generates a neighbor by strategically flipping items based on a novel \"value-weight dominance\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with high single-objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight squared\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights**2 + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to flip based on dominance\n    if np.random.rand() > 0.5:\n        flip_candidates = np.argsort(v1_dominance)[::-1]\n    else:\n        flip_candidates = np.argsort(v2_dominance)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9276721854782743,
            5.694262892007828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight squared\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights**2 + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight dominance for both objectives\n    v1_dominance = value1_lst / (weight_lst + 1e-6)\n    v2_dominance = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items to flip based on dominance\n    if np.random.rand() > 0.5:\n        flip_candidates = np.argsort(v1_dominance)[::-1]\n    else:\n        flip_candidates = np.argsort(v2_dominance)[::-1]\n\n    # Dynamic flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution from the archive by analyzing the Pareto frontier's convexity and generates a neighbor by strategically replacing subsets of items with high cross-objective trade-off potential, while ensuring feasibility through a dynamic capacity-aware clustering and substitution process that preserves the solution's structural integrity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest convexity on Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = objectives[np.lexsort((objectives[:, 1], -objectives[:, 0]))]\n    convexity = np.diff(pareto_front[:, 0]) / (np.diff(pareto_front[:, 1]) + 1e-6)\n    selected_idx = np.argmax(convexity) if len(convexity) > 0 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by cross-objective trade-off\n    trade_off = (value1_lst / (value2_lst + 1e-6)) * (1 - base_solution)\n    clusters = np.argsort(trade_off)\n\n    # Dynamic substitution process\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(0, len(clusters), 2):\n        if i + 1 >= len(clusters):\n            break\n\n        # Identify candidate pairs to swap\n        item1, item2 = clusters[i], clusters[i+1]\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n\n        # Check if swap maintains feasibility\n        if new_solution[item1] == 1 and new_solution[item2] == 0:\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = 0, 1\n                current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.721442978893391,
            2.64802485704422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest convexity on Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = objectives[np.lexsort((objectives[:, 1], -objectives[:, 0]))]\n    convexity = np.diff(pareto_front[:, 0]) / (np.diff(pareto_front[:, 1]) + 1e-6)\n    selected_idx = np.argmax(convexity) if len(convexity) > 0 else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by cross-objective trade-off\n    trade_off = (value1_lst / (value2_lst + 1e-6)) * (1 - base_solution)\n    clusters = np.argsort(trade_off)\n\n    # Dynamic substitution process\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(0, len(clusters), 2):\n        if i + 1 >= len(clusters):\n            break\n\n        # Identify candidate pairs to swap\n        item1, item2 = clusters[i], clusters[i+1]\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n\n        # Check if swap maintains feasibility\n        if new_solution[item1] == 1 and new_solution[item2] == 0:\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = 0, 1\n                current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective synergy score\" that combines both objective values and their ratios, then generates a neighbor by strategically flipping items based on a \"diversity-aware value-weight balance\" heuristic that prioritizes items with balanced improvements across both objectives while ensuring feasibility through a multi-phase adjustment process that dynamically balances capacity utilization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective synergy score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate diversity-aware value-weight balance\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    diversity = np.abs(v1_balance - v2_balance)\n    balance_score = (v1_balance + v2_balance) / (1 + diversity)\n\n    # Multi-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add, 1: remove, 2: swap\n\n    for idx in np.argsort(balance_score)[::-1]:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Swap items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Dynamic phase transition\n        if current_weight > 0.8 * capacity:\n            phase = 1\n        elif current_weight < 0.3 * capacity:\n            phase = 0\n        else:\n            phase = 2\n\n    return new_solution\n\n",
        "score": [
            -0.8543330885333527,
            2.617818683385849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate objective synergy score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 + obj2) / (np.maximum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate diversity-aware value-weight balance\n    v1_balance = value1_lst / (weight_lst + 1e-6)\n    v2_balance = value2_lst / (weight_lst + 1e-6)\n    diversity = np.abs(v1_balance - v2_balance)\n    balance_score = (v1_balance + v2_balance) / (1 + diversity)\n\n    # Multi-phase adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add, 1: remove, 2: swap\n\n    for idx in np.argsort(balance_score)[::-1]:\n        if phase == 0:  # Add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1:  # Remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:  # Swap items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Dynamic phase transition\n        if current_weight > 0.8 * capacity:\n            phase = 1\n        elif current_weight < 0.3 * capacity:\n            phase = 0\n        else:\n            phase = 2\n\n    return new_solution\n\n"
    }
]