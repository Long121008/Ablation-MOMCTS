[
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.976073469480651,
            2.1383263170719147
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their relative importance, then generates a neighbor by strategically flipping items based on a novel \"objective importance weighted ratio\" heuristic, ensuring feasibility through a dynamic adjustment process that prioritizes items with high cross-objective impact.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight and objective diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    diversity = np.array([abs(obj[0] - obj[1]) for _, obj in archive])\n    scores = (objectives / (weights + 1e-6)) * (1 + diversity / (np.sum(objectives) + 1e-6))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective importance weighted ratios\n    total_v1 = np.sum(value1_lst * new_solution)\n    total_v2 = np.sum(value2_lst * new_solution)\n    importance_v1 = total_v1 / (total_v1 + total_v2 + 1e-6)\n    importance_v2 = total_v2 / (total_v1 + total_v2 + 1e-6)\n\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    weighted_ratio = importance_v1 * v1_ratio + importance_v2 * v2_ratio\n\n    # Identify items to flip based on weighted ratio and current solution\n    flip_candidates = np.argsort(weighted_ratio)[::-1]\n\n    # Dynamic adjustment to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9785387278986422,
            3.633656471967697
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score combining normalized objectives with weight variance, then generates a neighbor by flipping items with high marginal utility, using a two-phase approach that prioritizes items with balanced value-weight ratios across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate score combining normalized objectives with weight variance\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    weight_var = np.var(weights)\n    scores = np.sum(norm_obj, axis=1) * (1 + weight_var)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utility for both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-weight ratios for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = (v1_ratio + v2_ratio) / 2\n\n    # Identify flip candidates based on marginal utility\n    flip_candidates = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            flip_candidates.append((i, combined_ratio[i]))\n        elif new_solution[i] == 1:\n            flip_candidates.append((i, -combined_ratio[i]))\n\n    # Sort candidates by marginal utility\n    flip_candidates.sort(key=lambda x: x[1], reverse=True)\n\n    # Two-phase flipping to maintain feasibility\n    phase = 0  # 0: add items, 1: remove items\n    for idx, _ in flip_candidates:\n        if phase == 0 and new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        elif phase == 1 and new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 80% full\n        if current_weight > 0.8 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.979517543885079,
            4.423159062862396
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by combining objective values with a novel \"value-density synergy\" metric, then generates a neighbor by strategically flipping items based on their cross-objective contribution, using a two-phase adjustment process that prioritizes items with high combined utility while maintaining feasibility through a dynamic capacity threshold.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest value-density synergy\n    objectives = np.array([(obj[0] * obj[1]) for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate combined value-density synergy\n    v1_density = value1_lst / (weight_lst + 1e-6)\n    v2_density = value2_lst / (weight_lst + 1e-6)\n    synergy = (v1_density * value2_lst + v2_density * value1_lst) / (np.sqrt(v1_density * v2_density) + 1e-6)\n\n    # Identify items to flip based on synergy\n    flip_candidates = np.argsort(synergy)[::-1]\n\n    # Two-phase flipping with dynamic capacity threshold\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n    dynamic_threshold = 0.8 * capacity if current_weight < 0.5 * capacity else 0.9 * capacity\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when reaching dynamic threshold\n        if current_weight > dynamic_threshold:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.0101505532252322,
            4.571231335401535
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.013300290295829,
            5.049311548471451
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their dominance, then generates a neighbor by strategically flipping items based on a novel \"value dominance ratio\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (value1 / value2 ratio)\n    objectives = np.array([obj for _, obj in archive])\n    dominance = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value dominance ratio for both objectives\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n    combined_dominance = v1_dominance + v2_dominance\n\n    # Identify items to flip based on dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8844777483934578,
            0.7978863418102264
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective synergy\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process that considers both individual and combined objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective synergy\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    synergy = (obj1 * obj2) / (np.sqrt(obj1**2 + obj2**2) + 1e-6)\n    selected_idx = np.argmax(synergy)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective synergy ratios\n    v1_synergy = (value1_lst * value2_lst) / (np.sqrt(value1_lst**2 + value2_lst**2) + 1e-6)\n    v2_synergy = (value2_lst * value1_lst) / (np.sqrt(value2_lst**2 + value1_lst**2) + 1e-6)\n    combined_synergy = v1_synergy + v2_synergy\n    flip_candidates = np.argsort(combined_synergy)[::-1]\n\n    # Dynamic capacity-aware flipping with synergy-based prioritization\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high synergy\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low synergy\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_synergy)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Third pass: flip items with high individual improvement potential\n    if np.random.rand() > 0.5:\n        v1_ratio = value1_lst / (weight_lst + 1e-6)\n        flip_candidates = np.argsort(v1_ratio)[::-1]\n    else:\n        v2_ratio = value2_lst / (weight_lst + 1e-6)\n        flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            if current_weight <= capacity:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8958882570858095,
            1.1609545052051544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"trade-off dominance\" score that combines both objective values and their ratios, then generates a neighbor by strategically flipping items using a hybrid approach that prioritizes items with high potential to improve both objectives while dynamically adjusting for capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate trade-off dominance score for each solution\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    trade_off = (obj1 + obj2) / (np.abs(obj1 - obj2) + 1e-6)\n    selected_idx = np.argmax(trade_off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate hybrid dominance score\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    hybrid_score = (v1_ratio + v2_ratio) * (1 - np.abs(v1_ratio - v2_ratio))\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high hybrid score\n    flip_candidates = np.argsort(hybrid_score)[::-1]\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low hybrid score\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(hybrid_score)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.964306300882511,
            1.8897600769996643
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by analyzing the trade-off between objectives and their value-weight ratios, then generates a neighbor by strategically flipping items based on a novel \"objective dominance\" heuristic that prioritizes items with high potential to improve both objectives simultaneously, while ensuring feasibility through a dynamic capacity-aware adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest objective dominance (max-min ratio)\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    dominance = np.maximum(obj1, obj2) / (np.minimum(obj1, obj2) + 1e-6)\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective dominance ratios\n    v1_dominance = value1_lst / (value2_lst + 1e-6)\n    v2_dominance = value2_lst / (value1_lst + 1e-6)\n\n    # Identify items with high potential to improve both objectives\n    combined_dominance = v1_dominance + v2_dominance\n    flip_candidates = np.argsort(combined_dominance)[::-1]\n\n    # Dynamic capacity-aware flipping\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # First pass: add items with high dominance\n    for idx in flip_candidates:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Second pass: remove items with low dominance\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        remove_candidates = np.argsort(combined_dominance)\n        for idx in remove_candidates:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.777528135166784,
            0.45100951194763184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"value diversity\" metric that combines both objectives with a dynamic weight that adapts to the current solution's structure, then generates a neighbor by strategically flipping items based on their potential to diversify the solution while maintaining feasibility through a multi-phase adjustment process that prioritizes items with high cross-objective trade-off potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate value diversity metric for each solution\n    objectives = np.array([obj for _, obj in archive])\n    v1_norm = objectives[:, 0] / (np.sum(value1_lst) + 1e-6)\n    v2_norm = objectives[:, 1] / (np.sum(value2_lst) + 1e-6)\n    diversity_scores = np.abs(v1_norm - v2_norm)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic weight based on solution structure\n    current_weight = np.sum(weight_lst * new_solution)\n    weight_ratio = current_weight / capacity\n    dynamic_weight = 0.7 if weight_ratio < 0.5 else 1.3\n\n    # Calculate value diversity heuristic for items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    value_diversity = np.abs(v1_ratio - v2_ratio) * dynamic_weight\n\n    # Identify items to flip based on value diversity\n    flip_candidates = np.argsort(value_diversity)[::-1]\n\n    # Multi-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 60% full\n        if current_weight > 0.6 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8758201826722091,
            0.5908966064453125
        ]
    }
]