[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3336259323310398,
            0.6336628198623657
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9719549471395192,
            3.08738049864769
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9719549471395192,
            3.08738049864769
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3336259323310398,
            0.6336628198623657
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate the current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Compute the weighted marginal contribution for each item (prioritize high-value, low-weight items)\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items that can be added without exceeding capacity\n    candidate_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n\n    # If no items can be added, consider removing low-contribution items\n    if len(candidate_items) == 0:\n        candidate_items = np.where(new_solution == 1)[0]\n        combined_contrib = (value1_lst + value2_lst) * new_solution\n\n    # Perform a weighted random walk: higher contribution items have higher probability of being selected\n    probs = combined_contrib[candidate_items]\n    probs = probs / np.sum(probs)  # Normalize to probabilities\n    selected_idx = np.random.choice(candidate_items, p=probs)\n\n    # Toggle the selected item (add or remove based on current state)\n    new_solution[selected_idx] = 1 - new_solution[selected_idx]\n\n    # Ensure feasibility by adjusting the solution if necessary\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9348333587257869,
            1.9338580071926117
        ]
    },
    {
        "algorithm": "{A new heuristic selects a solution from the archive using a weighted sum of normalized objectives, then generates neighbors by flipping items based on their marginal contribution to both objectives, while ensuring feasibility through iterative removal of low-contribution items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for _, obj in archive]\n\n    # Select solution with highest normalized score\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / (weight_lst + 1e-6)\n    marginal_contrib2 = value2_lst / (weight_lst + 1e-6)\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(5, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5304606832547827,
            1.4755763113498688
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3336259323310398,
            0.6336628198623657
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9719549471395192,
            3.08738049864769
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted score of its objectives, then generates a neighbor by flipping items with high marginal contribution while ensuring feasibility through a novel two-phase adjustment process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        score = 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n        scores.append(score)\n\n    # Select the solution with the highest weighted score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = 0.6 * marginal_contrib1 + 0.4 * marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//2:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(4, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Two-phase adjustment: first remove items with lowest marginal contribution in current solution\n        current_contrib = (value1_lst + value2_lst) * new_solution\n        low_contrib_items = np.argsort(current_contrib)\n        for idx in low_contrib_items:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n        # If still over capacity, remove items with lowest weight-to-value ratio\n        if current_weight > capacity:\n            weight_to_value = weight_lst / (value1_lst + value2_lst + 1e-6)  # Avoid division by zero\n            remove_order = np.argsort(weight_to_value)\n            for idx in remove_order:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.3951723694699628,
            0.8210012018680573
        ]
    },
    {
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.8192238200001005,
            1.5372501611709595
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9719549471395192,
            3.08738049864769
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing solutions with the highest objective values, then applies a hybrid local search that combines item swaps and adaptive perturbations to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (highest value in either objective)\n    archive.sort(key=lambda x: max(x[1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap items and apply adaptive perturbations\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with the lowest (value1 + value2) until feasible\n        while total_weight > capacity:\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break\n            # Select the item with the lowest combined value\n            values = value1_lst + value2_lst\n            remove_idx = candidate_indices[np.argmin(values[candidate_indices])]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Apply adaptive perturbations based on objective diversity\n    obj1, obj2 = archive[0][1]\n    if obj1 > obj2:\n        # Perturb to improve value2 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value2 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value2_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n    else:\n        # Perturb to improve value1 more aggressively\n        for _ in range(2):\n            if np.random.rand() < 0.5:\n                # Add an item with high value1 if possible\n                candidate_indices = np.where(new_solution == 0)[0]\n                if len(candidate_indices) > 0:\n                    values = value1_lst[candidate_indices]\n                    add_idx = candidate_indices[np.argmax(values)]\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        total_weight += weight_lst[add_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3414704594993703,
            0.7952825427055359
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3336259323310398,
            0.6336628198623657
        ]
    },
    {
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random perturbation with targeted flipping of items to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Sort solutions by the sum of their objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    # Select the top 20% of solutions for potential improvement\n    candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Hybrid local search: flip items that improve both objectives or one with a trade-off\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to flip (either add or remove)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # Accept if both objectives improve or one improves with a trade-off\n                if (new_value1 >= current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * current_value2) or \\\n                   (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * current_value1):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.8192238200001005,
            1.5372501611709595
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective values, then applies a novel local search strategy that flips a subset of items based on a dynamic trade-off between the two objectives, ensuring feasibility by adjusting the selection to stay within capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dynamic trade-off between objectives\n    alpha = np.random.uniform(0.3, 0.7)  # Random trade-off factor\n\n    # Identify items to flip: prioritize items with high marginal benefit\n    marginal_benefit = (alpha * value1_lst + (1 - alpha) * value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(marginal_benefit)[::-1]\n\n    # Flip items to maximize benefit while staying feasible\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9719549471395192,
            3.08738049864769
        ]
    }
]