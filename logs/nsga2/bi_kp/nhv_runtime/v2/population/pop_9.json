[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contrib1 = value1_lst / weight_lst\n    marginal_contrib2 = value2_lst / weight_lst\n    combined_contrib = marginal_contrib1 + marginal_contrib2\n\n    # Identify items with high combined marginal contribution\n    high_contrib_items = np.argsort(combined_contrib)[-len(combined_contrib)//3:]\n\n    # Randomly select a subset of these high-contribution items to flip\n    flip_indices = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n\n    # Flip the selected items (0 to 1 or 1 to 0)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal contribution until feasible\n        while current_weight > capacity:\n            # Find items with the lowest marginal contribution in the current solution\n            current_contrib = (value1_lst + value2_lst) * new_solution\n            low_contrib_items = np.argsort(current_contrib)[::-1]\n            for idx in low_contrib_items:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3336259323310398,
            0.6336628198623657
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by considering both objective values and their correlation, then generates a neighbor by strategically flipping items based on a novel \"value-weight ratio correlation\" heuristic, ensuring feasibility through a two-phase adjustment process that prioritizes items with high cross-objective synergy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective normalized by weight\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    scores = objectives / (weights + 1e-6)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate value-weight ratio correlation for both objectives\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    correlation = np.corrcoef(v1_ratio, v2_ratio)[0, 1]\n    abs_correlation = abs(correlation)\n\n    # Identify items to flip based on correlation\n    if abs_correlation > 0.5:  # Strong correlation, flip items with high combined ratio\n        combined_ratio = (v1_ratio + v2_ratio) * (1 + abs_correlation)\n        flip_candidates = np.argsort(combined_ratio)[::-1]\n    else:  # Weak correlation, alternate between objectives\n        if np.random.rand() > 0.5:\n            flip_candidates = np.argsort(v1_ratio)[::-1]\n        else:\n            flip_candidates = np.argsort(v2_ratio)[::-1]\n\n    # Two-phase flipping to maintain feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    phase = 0  # 0: add items, 1: remove items\n\n    for idx in flip_candidates:\n        if phase == 0:  # First try to add items\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:  # Then try to remove items\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n        # Switch phase when capacity is 70% full\n        if current_weight > 0.7 * capacity:\n            phase = 1\n\n    return new_solution\n\n",
        "score": [
            -1.0006300282116203,
            6.243985891342163
        ]
    }
]