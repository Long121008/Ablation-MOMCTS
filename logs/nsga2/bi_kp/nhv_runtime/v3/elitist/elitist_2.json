[
    {
        "algorithm": "{My algorithm selects a solution from the archive based on a combination of value-to-weight ratio and objective diversity, then applies a hybrid local search that combines strategic item swaps with a probabilistic neighborhood exploration to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution based on combined objective value and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic neighborhood exploration with probabilistic swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Consider both high-value and low-weight items first\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(-value_ratios)\n\n    # Perform targeted swaps with probability based on value ratio\n    for i in sorted_indices[:min(10, n_items)]:\n        if random.random() < 0.7:  # Higher probability for better items\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Additional probabilistic swap between items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1:\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    new_weight = current_weight + weight_lst[i] - weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.30205371092050237,
            2.0146380960941315
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a solution from the archive based on a novel diversity-aware selection metric, then applies a hybrid local search strategy that combines probabilistic item inclusion/exclusion with a dynamic neighborhood exploration that prioritizes both value improvements and solution diversity, while always ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection metric\n    selection_metrics = []\n    for sol, _ in archive:\n        # Metric combines value potential and solution diversity\n        value_potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        selection_metrics.append(value_potential * (1 + diversity))\n\n    # Select solution with highest metric\n    selected_idx = np.argmax(selection_metrics)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with probabilistic inclusion/exclusion\n    current_weight = np.sum(weight_lst * new_solution)\n    n_items = len(weight_lst)\n\n    # First phase: probabilistic inclusion of excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        for i in excluded_items:\n            # Probability based on value and inverse weight\n            prob = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n            if random.random() < prob and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Second phase: dynamic neighborhood exploration\n    for _ in range(5):\n        # Select items with high value-to-weight ratio\n        item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        top_items = np.argsort(item_scores)[-min(5, n_items):]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing item with probability based on its contribution\n                contribution = (value1_lst[i] + value2_lst[i]) / current_weight\n                if random.random() < contribution:\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n            else:\n                # Try adding item with probability based on its potential\n                potential = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if random.random() < potential and (current_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9267661099967333,
            10.44105777144432
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines biased random selection of solutions with a dynamic item swapping mechanism that prioritizes high-value items while ensuring feasibility, using a probabilistic approach to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with probability proportional to its potential for improvement\n    total_potential = sum((value1 + value2) for _, (value1, value2) in archive)\n    if total_potential == 0:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        probabilities = [(value1 + value2) / total_potential for _, (value1, value2) in archive]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Dynamic item swapping with feasibility check\n    for _ in range(10):  # Limit the number of attempts to prevent infinite loops\n        # Identify items to potentially swap\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        item_to_remove = random.choice(included_items)\n        item_to_add = random.choice(excluded_items)\n\n        # Calculate potential new weight\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n        # Check feasibility\n        if new_weight <= capacity:\n            # Perform the swap with probability based on value improvement\n            value_improvement = (value1_lst[item_to_add] + value2_lst[item_to_add]) - (value1_lst[item_to_remove] + value2_lst[item_to_remove])\n            if value_improvement > 0 or random.random() < 0.3:  # Always allow some exploration\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4898757863664173,
            2.7447108924388885
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a promising solution from the archive, then applies a hybrid local search strategy that combines item swaps with a dynamic neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement for each solution\n    potentials = []\n    for sol, obj in archive:\n        # Potential is based on the ratio of value to weight and diversity in the archive\n        total_weight = np.sum(weight_lst * sol)\n        potential = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        potentials.append(potential)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic neighborhood exploration\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Additionally, perform a random swap of two items if possible\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                # Swap i out and j in\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap j out and i in\n                new_weight = current_weight + weight_lst[i] - weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36395155309496685,
            2.0312142074108124
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a dynamic item clustering mechanism with an adaptive neighborhood exploration that prioritizes high-value items while ensuring feasibility, using a probabilistic approach to balance exploration and exploitation of the solution space through iterative refinement of item groups.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with probability proportional to its potential for improvement\n    total_potential = sum((value1 + value2) for _, (value1, value2) in archive)\n    if total_potential == 0:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        probabilities = [(value1 + value2) / total_potential for _, (value1, value2) in archive]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Dynamic item clustering and adaptive neighborhood exploration\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) == 0 or len(excluded_items) == 0:\n        return new_solution\n\n    # Cluster items based on their value ratios\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_included = included_items[np.argsort(value_ratios[included_items])[::-1]]\n    sorted_excluded = excluded_items[np.argsort(value_ratios[excluded_items])[::-1]]\n\n    # Adaptive neighborhood exploration\n    for _ in range(10):\n        # Select high-value items to potentially swap\n        if len(sorted_included) > 0 and len(sorted_excluded) > 0:\n            item_to_remove = sorted_included[0] if random.random() < 0.7 else random.choice(sorted_included)\n            item_to_add = sorted_excluded[0] if random.random() < 0.7 else random.choice(sorted_excluded)\n\n            new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n            if new_weight <= capacity:\n                # Perform swap with probability based on value improvement and weight ratio\n                value_improvement = (value1_lst[item_to_add] + value2_lst[item_to_add]) - (value1_lst[item_to_remove] + value2_lst[item_to_remove])\n                weight_ratio = weight_lst[item_to_add] / weight_lst[item_to_remove] if weight_lst[item_to_remove] > 0 else 1.0\n\n                swap_prob = 0.5 * (value_improvement / (value1_lst[item_to_remove] + value2_lst[item_to_remove] + 1)) + 0.5 * (1 / weight_ratio)\n\n                if swap_prob > random.random():\n                    new_solution[item_to_remove] = 0\n                    new_solution[item_to_add] = 1\n                    current_weight = new_weight\n\n                    # Update clusters\n                    included_items = np.where(new_solution == 1)[0]\n                    excluded_items = np.where(new_solution == 0)[0]\n                    if len(included_items) > 0:\n                        sorted_included = included_items[np.argsort(value_ratios[included_items])[::-1]]\n                    if len(excluded_items) > 0:\n                        sorted_excluded = excluded_items[np.argsort(value_ratios[excluded_items])[::-1]]\n\n    return new_solution\n\n",
        "score": [
            -0.47635533089598936,
            2.7422755658626556
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a solution from the archive based on a novel diversity-aware selection metric, then applies a hybrid local search strategy that combines probabilistic item inclusion/exclusion with a dynamic neighborhood exploration that prioritizes both value improvements and solution diversity, while always ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection metric\n    selection_metrics = []\n    for sol, _ in archive:\n        # Metric combines value potential and solution diversity\n        value_potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        selection_metrics.append(value_potential * (1 + diversity))\n\n    # Select solution with highest metric\n    selected_idx = np.argmax(selection_metrics)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with probabilistic inclusion/exclusion\n    current_weight = np.sum(weight_lst * new_solution)\n    n_items = len(weight_lst)\n\n    # First phase: probabilistic inclusion of excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        for i in excluded_items:\n            # Probability based on value and inverse weight\n            prob = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n            if random.random() < prob and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Second phase: dynamic neighborhood exploration\n    for _ in range(5):\n        # Select items with high value-to-weight ratio\n        item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        top_items = np.argsort(item_scores)[-min(5, n_items):]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing item with probability based on its contribution\n                contribution = (value1_lst[i] + value2_lst[i]) / current_weight\n                if random.random() < contribution:\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n            else:\n                # Try adding item with probability based on its potential\n                potential = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if random.random() < potential and (current_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9267661099967333,
            10.44105777144432
        ]
    },
    {
        "algorithm": "{My algorithm selects a solution from the archive based on a combination of value-to-weight ratio and objective diversity, then applies a hybrid local search that combines strategic item swaps with a probabilistic neighborhood exploration to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution based on combined objective value and weight efficiency\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (obj[0] * obj[1]) / (total_weight + 1e-6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic neighborhood exploration with probabilistic swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Consider both high-value and low-weight items first\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(-value_ratios)\n\n    # Perform targeted swaps with probability based on value ratio\n    for i in sorted_indices[:min(10, n_items)]:\n        if random.random() < 0.7:  # Higher probability for better items\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Additional probabilistic swap between items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            if new_solution[i] != new_solution[j]:\n                if new_solution[i] == 1:\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    new_weight = current_weight + weight_lst[i] - weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.30205371092050237,
            2.0146380960941315
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines biased random selection of solutions based on both objective values and their potential for improvement with a dynamic item swapping mechanism that prioritizes high-value items while ensuring feasibility, using a probabilistic approach that balances exploration and exploitation, and incorporates a dynamic temperature parameter to control the acceptance of worse solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with probability proportional to its normalized objective values\n    total_value1 = sum(value1 for _, (value1, _) in archive)\n    total_value2 = sum(value2 for _, (_, value2) in archive)\n\n    if total_value1 == 0 or total_value2 == 0:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        normalized_scores = []\n        for _, (value1, value2) in archive:\n            score = (value1 / total_value1) + (value2 / total_value2)\n            normalized_scores.append(score)\n\n        total_score = sum(normalized_scores)\n        probabilities = [score / total_score for score in normalized_scores]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Dynamic temperature-based item swapping\n    temperature = max(1.0, np.mean([value1 + value2 for _, (value1, value2) in archive]) * 0.1)\n\n    for _ in range(15):  # Increased number of attempts\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        item_to_remove = random.choice(included_items)\n        item_to_add = random.choice(excluded_items)\n\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n        if new_weight <= capacity:\n            value_improvement = (value1_lst[item_to_add] + value2_lst[item_to_add]) - (value1_lst[item_to_remove] + value2_lst[item_to_remove])\n            if value_improvement > 0 or random.random() < np.exp(value_improvement / temperature):\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.6654470462638403,
            4.319233953952789
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines biased random selection of solutions with a dynamic item swapping mechanism that prioritizes high-value items while ensuring feasibility, using a probabilistic approach to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with probability proportional to its potential for improvement\n    total_potential = sum((value1 + value2) for _, (value1, value2) in archive)\n    if total_potential == 0:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        probabilities = [(value1 + value2) / total_potential for _, (value1, value2) in archive]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Dynamic item swapping with feasibility check\n    for _ in range(10):  # Limit the number of attempts to prevent infinite loops\n        # Identify items to potentially swap\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        item_to_remove = random.choice(included_items)\n        item_to_add = random.choice(excluded_items)\n\n        # Calculate potential new weight\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n        # Check feasibility\n        if new_weight <= capacity:\n            # Perform the swap with probability based on value improvement\n            value_improvement = (value1_lst[item_to_add] + value2_lst[item_to_add]) - (value1_lst[item_to_remove] + value2_lst[item_to_remove])\n            if value_improvement > 0 or random.random() < 0.3:  # Always allow some exploration\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4898757863664173,
            2.7447108924388885
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a promising solution from the archive, then applies a hybrid local search strategy that combines item swaps with a dynamic neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement for each solution\n    potentials = []\n    for sol, obj in archive:\n        # Potential is based on the ratio of value to weight and diversity in the archive\n        total_weight = np.sum(weight_lst * sol)\n        potential = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        potentials.append(potential)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic neighborhood exploration\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Additionally, perform a random swap of two items if possible\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                # Swap i out and j in\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap j out and i in\n                new_weight = current_weight + weight_lst[i] - weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36395155309496685,
            2.0312142074108124
        ]
    }
]