[
    {
        "algorithm": "{A novel hybrid local search strategy combines biased random selection of solutions with a dynamic item swapping mechanism that prioritizes high-value items while ensuring feasibility, using a probabilistic approach to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with probability proportional to its potential for improvement\n    total_potential = sum((value1 + value2) for _, (value1, value2) in archive)\n    if total_potential == 0:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        probabilities = [(value1 + value2) / total_potential for _, (value1, value2) in archive]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Dynamic item swapping with feasibility check\n    for _ in range(10):  # Limit the number of attempts to prevent infinite loops\n        # Identify items to potentially swap\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        item_to_remove = random.choice(included_items)\n        item_to_add = random.choice(excluded_items)\n\n        # Calculate potential new weight\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n        # Check feasibility\n        if new_weight <= capacity:\n            # Perform the swap with probability based on value improvement\n            value_improvement = (value1_lst[item_to_add] + value2_lst[item_to_add]) - (value1_lst[item_to_remove] + value2_lst[item_to_remove])\n            if value_improvement > 0 or random.random() < 0.3:  # Always allow some exploration\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4898757863664173,
            2.7447108924388885
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a promising solution from the archive, then applies a hybrid local search strategy that combines item swaps with a dynamic neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement for each solution\n    potentials = []\n    for sol, obj in archive:\n        # Potential is based on the ratio of value to weight and diversity in the archive\n        total_weight = np.sum(weight_lst * sol)\n        potential = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        potentials.append(potential)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic neighborhood exploration\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Additionally, perform a random swap of two items if possible\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                # Swap i out and j in\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap j out and i in\n                new_weight = current_weight + weight_lst[i] - weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36395155309496685,
            2.0312142074108124
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines biased random selection of solutions with a dynamic item swapping mechanism that prioritizes high-value items while ensuring feasibility, using a probabilistic approach to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with probability proportional to its potential for improvement\n    total_potential = sum((value1 + value2) for _, (value1, value2) in archive)\n    if total_potential == 0:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        probabilities = [(value1 + value2) / total_potential for _, (value1, value2) in archive]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Dynamic item swapping with feasibility check\n    for _ in range(10):  # Limit the number of attempts to prevent infinite loops\n        # Identify items to potentially swap\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) == 0 or len(excluded_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        item_to_remove = random.choice(included_items)\n        item_to_add = random.choice(excluded_items)\n\n        # Calculate potential new weight\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n        # Check feasibility\n        if new_weight <= capacity:\n            # Perform the swap with probability based on value improvement\n            value_improvement = (value1_lst[item_to_add] + value2_lst[item_to_add]) - (value1_lst[item_to_remove] + value2_lst[item_to_remove])\n            if value_improvement > 0 or random.random() < 0.3:  # Always allow some exploration\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4898757863664173,
            2.7447108924388885
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a promising solution from the archive, then applies a hybrid local search strategy that combines item swaps with a dynamic neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement for each solution\n    potentials = []\n    for sol, obj in archive:\n        # Potential is based on the ratio of value to weight and diversity in the archive\n        total_weight = np.sum(weight_lst * sol)\n        potential = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        potentials.append(potential)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic neighborhood exploration\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Additionally, perform a random swap of two items if possible\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                # Swap i out and j in\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap j out and i in\n                new_weight = current_weight + weight_lst[i] - weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36395155309496685,
            2.0312142074108124
        ]
    }
]