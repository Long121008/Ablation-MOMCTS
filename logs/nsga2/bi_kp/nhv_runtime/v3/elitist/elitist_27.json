[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8324152407214259,
            0.5414572060108185
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8324152407214259,
            0.5414572060108185
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8324152407214259,
            0.5414572060108185
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8324152407214259,
            0.5414572060108185
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9520838429968368,
            1.9922052323818207
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8324152407214259,
            0.5414572060108185
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8934693670689027,
            1.6486671268939972
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution density, then applies a multi-stage local search that alternates between value-aware additions, capacity-constrained removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces and the archive's Pareto front characteristics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective dominance and solution density\n    dominance_scores = []\n    for sol, obj in archive:\n        # Calculate dominance score based on non-dominated solutions in archive\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] >= obj[0] and other_obj[1] > obj[1]) or (other_obj[0] > obj[0] and other_obj[1] >= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            density = np.sum(sol) / len(sol)\n            dominance_scores.append((obj[0] + obj[1]) * (1 - density))\n\n    if dominance_scores:\n        selected_idx = np.argmax(dominance_scores)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective dominance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_dominance = np.maximum(value1_lst, value2_lst) / (np.minimum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * objective_dominance\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8633223152533229,
            1.3703964352607727
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        candidate_items = excluded_items[np.argsort(-value_ratios[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            removal_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(removal_ratios[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps\n    if abs(total_value1 - total_value2) > 0.2 * (total_value1 + total_value2):\n        if total_value1 > total_value2:\n            high_value1_items = np.where((new_solution == 1) & (value1_lst > value2_lst))[0]\n            if len(high_value1_items) > 0:\n                for i in high_value1_items:\n                    for j in np.where(new_solution == 0)[0]:\n                        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                            if (value2_lst[j] - value1_lst[i]) > 0:\n                                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                                break\n        else:\n            high_value2_items = np.where((new_solution == 1) & (value2_lst > value1_lst))[0]\n            if len(high_value2_items) > 0:\n                for i in high_value2_items:\n                    for j in np.where(new_solution == 0)[0]:\n                        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                            if (value1_lst[j] - value2_lst[i]) > 0:\n                                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.9878416333917808,
            2.8447465002536774
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9922388742212646,
            3.3693877160549164
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        candidate_items = excluded_items[np.argsort(-value_ratios[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            removal_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(removal_ratios[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps\n    if abs(total_value1 - total_value2) > 0.2 * (total_value1 + total_value2):\n        if total_value1 > total_value2:\n            high_value1_items = np.where((new_solution == 1) & (value1_lst > value2_lst))[0]\n            if len(high_value1_items) > 0:\n                for i in high_value1_items:\n                    for j in np.where(new_solution == 0)[0]:\n                        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                            if (value2_lst[j] - value1_lst[i]) > 0:\n                                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                                break\n        else:\n            high_value2_items = np.where((new_solution == 1) & (value2_lst > value1_lst))[0]\n            if len(high_value2_items) > 0:\n                for i in high_value2_items:\n                    for j in np.where(new_solution == 0)[0]:\n                        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                            if (value1_lst[j] - value2_lst[i]) > 0:\n                                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.9878416333917808,
            2.8447465002536774
        ]
    }
]