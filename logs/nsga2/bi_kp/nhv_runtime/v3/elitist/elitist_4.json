[
    {
        "algorithm": "{My algorithm intelligently selects a solution from the archive based on a novel diversity-aware selection metric, then applies a hybrid local search strategy that combines probabilistic item inclusion/exclusion with a dynamic neighborhood exploration that prioritizes both value improvements and solution diversity, while always ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection metric\n    selection_metrics = []\n    for sol, _ in archive:\n        # Metric combines value potential and solution diversity\n        value_potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        selection_metrics.append(value_potential * (1 + diversity))\n\n    # Select solution with highest metric\n    selected_idx = np.argmax(selection_metrics)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with probabilistic inclusion/exclusion\n    current_weight = np.sum(weight_lst * new_solution)\n    n_items = len(weight_lst)\n\n    # First phase: probabilistic inclusion of excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        for i in excluded_items:\n            # Probability based on value and inverse weight\n            prob = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n            if random.random() < prob and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Second phase: dynamic neighborhood exploration\n    for _ in range(5):\n        # Select items with high value-to-weight ratio\n        item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        top_items = np.argsort(item_scores)[-min(5, n_items):]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing item with probability based on its contribution\n                contribution = (value1_lst[i] + value2_lst[i]) / current_weight\n                if random.random() < contribution:\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n            else:\n                # Try adding item with probability based on its potential\n                potential = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if random.random() < potential and (current_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9267661099967333,
            10.44105777144432
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a hybrid local search that combines value-aware item swaps with a probabilistic exploration of high-potential item combinations while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution based on weighted objective combination\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (0.4 * obj[0] + 0.6 * obj[1]) / (total_weight + 1e-6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with value-aware swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate value efficiency for each objective\n    eff1 = value1_lst / (weight_lst + 1e-6)\n    eff2 = value2_lst / (weight_lst + 1e-6)\n    combined_eff = 0.5 * eff1 + 0.5 * eff2\n    sorted_indices = np.argsort(-combined_eff)\n\n    # Perform strategic swaps between high-efficiency items\n    for i in sorted_indices[:min(10, n_items)]:\n        if random.random() < 0.7:\n            if new_solution[i] == 0:\n                # Try adding item if it fits\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n            else:\n                # Try removing item to make space for better items\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n\n    # Probabilistic exploration of high-potential item combinations\n    if n_items >= 3:\n        candidates = random.sample(range(n_items), min(5, n_items))\n        for i in candidates:\n            if random.random() < 0.3:\n                if new_solution[i] == 0:\n                    # Try adding item with probability based on its efficiency\n                    prob = min(0.9, combined_eff[i] / (max(combined_eff) + 1e-6))\n                    if random.random() < prob:\n                        new_weight = current_weight + weight_lst[i]\n                        if new_weight <= capacity:\n                            new_solution[i] = 1\n                            current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.5451975623412475,
            1.1356434226036072
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a solution from the archive based on a novel diversity-aware selection metric, then applies a hybrid local search strategy that combines probabilistic item inclusion/exclusion with a dynamic neighborhood exploration that prioritizes both value improvements and solution diversity, while always ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection metric\n    selection_metrics = []\n    for sol, _ in archive:\n        # Metric combines value potential and solution diversity\n        value_potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        selection_metrics.append(value_potential * (1 + diversity))\n\n    # Select solution with highest metric\n    selected_idx = np.argmax(selection_metrics)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with probabilistic inclusion/exclusion\n    current_weight = np.sum(weight_lst * new_solution)\n    n_items = len(weight_lst)\n\n    # First phase: probabilistic inclusion of excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        for i in excluded_items:\n            # Probability based on value and inverse weight\n            prob = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n            if random.random() < prob and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Second phase: dynamic neighborhood exploration\n    for _ in range(5):\n        # Select items with high value-to-weight ratio\n        item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        top_items = np.argsort(item_scores)[-min(5, n_items):]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing item with probability based on its contribution\n                contribution = (value1_lst[i] + value2_lst[i]) / current_weight\n                if random.random() < contribution:\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n            else:\n                # Try adding item with probability based on its potential\n                potential = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if random.random() < potential and (current_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9267661099967333,
            10.44105777144432
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and weight efficiency, then applies a hybrid local search that combines value-aware item swaps with a probabilistic exploration of high-potential item combinations while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution based on weighted objective combination\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (0.4 * obj[0] + 0.6 * obj[1]) / (total_weight + 1e-6)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with value-aware swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate value efficiency for each objective\n    eff1 = value1_lst / (weight_lst + 1e-6)\n    eff2 = value2_lst / (weight_lst + 1e-6)\n    combined_eff = 0.5 * eff1 + 0.5 * eff2\n    sorted_indices = np.argsort(-combined_eff)\n\n    # Perform strategic swaps between high-efficiency items\n    for i in sorted_indices[:min(10, n_items)]:\n        if random.random() < 0.7:\n            if new_solution[i] == 0:\n                # Try adding item if it fits\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n            else:\n                # Try removing item to make space for better items\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n\n    # Probabilistic exploration of high-potential item combinations\n    if n_items >= 3:\n        candidates = random.sample(range(n_items), min(5, n_items))\n        for i in candidates:\n            if random.random() < 0.3:\n                if new_solution[i] == 0:\n                    # Try adding item with probability based on its efficiency\n                    prob = min(0.9, combined_eff[i] / (max(combined_eff) + 1e-6))\n                    if random.random() < prob:\n                        new_weight = current_weight + weight_lst[i]\n                        if new_weight <= capacity:\n                            new_solution[i] = 1\n                            current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.5451975623412475,
            1.1356434226036072
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a solution from the archive based on a novel diversity-aware selection metric, then applies a hybrid local search strategy that combines probabilistic item inclusion/exclusion with a dynamic neighborhood exploration that prioritizes both value improvements and solution diversity, while always ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection metric\n    selection_metrics = []\n    for sol, _ in archive:\n        # Metric combines value potential and solution diversity\n        value_potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        selection_metrics.append(value_potential * (1 + diversity))\n\n    # Select solution with highest metric\n    selected_idx = np.argmax(selection_metrics)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with probabilistic inclusion/exclusion\n    current_weight = np.sum(weight_lst * new_solution)\n    n_items = len(weight_lst)\n\n    # First phase: probabilistic inclusion of excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        for i in excluded_items:\n            # Probability based on value and inverse weight\n            prob = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n            if random.random() < prob and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Second phase: dynamic neighborhood exploration\n    for _ in range(5):\n        # Select items with high value-to-weight ratio\n        item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        top_items = np.argsort(item_scores)[-min(5, n_items):]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing item with probability based on its contribution\n                contribution = (value1_lst[i] + value2_lst[i]) / current_weight\n                if random.random() < contribution:\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n            else:\n                # Try adding item with probability based on its potential\n                potential = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if random.random() < potential and (current_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9267661099967333,
            10.44105777144432
        ]
    },
    {
        "algorithm": "{My new algorithm selects a solution from the archive based on a combination of objective dominance and solution density, then applies a hybrid local search that combines strategic item insertions with a probabilistic neighborhood exploration to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution based on objective dominance and density\n    dominance_counts = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] >= obj[0] and other_obj[1] >= obj[1] and (other_obj[0] > obj[0] or other_obj[1] > obj[1]):\n                dominated += 1\n        dominance_counts.append(dominated)\n\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic neighborhood exploration with probabilistic insertions\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Consider both high-value and low-weight items first\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(-value_ratios)\n\n    # Perform targeted insertions with probability based on value ratio\n    for i in sorted_indices[:min(15, n_items)]:\n        if random.random() < 0.6:  # Higher probability for better items\n            if new_solution[i] == 0:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Additional probabilistic removal of low-value items\n    for i in range(n_items):\n        if new_solution[i] == 1 and random.random() < 0.3:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8517583988017057,
            1.496477872133255
        ]
    },
    {
        "algorithm": "{My algorithm selects a solution from the archive based on a combination of objective diversity and solution density, then applies a novel local search that combines adaptive item grouping with a probabilistic neighborhood exploration using a dynamic value-weight balance metric to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution based on objective diversity and solution density\n    diversity_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        density = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        diversity = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-6)\n        score = density * diversity\n        diversity_scores.append(score)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive item grouping based on value-weight balance\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Create groups of items with similar value-weight ratios\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_indices = np.argsort(value_ratios)\n    groups = []\n    group_size = max(1, n_items // 5)\n    for i in range(0, n_items, group_size):\n        groups.append(sorted_indices[i:i+group_size])\n\n    # Dynamic neighborhood exploration with probabilistic group swaps\n    for group in groups:\n        if random.random() < 0.6:  # Higher probability for groups\n            # Try to add or remove entire group\n            group_weight = np.sum(weight_lst[group])\n            if np.all(new_solution[group] == 1):\n                new_weight = current_weight - group_weight\n                if new_weight <= capacity:\n                    new_solution[group] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + group_weight\n                if new_weight <= capacity:\n                    new_solution[group] = 1\n                    current_weight = new_weight\n\n    # Additional probabilistic intra-group swaps\n    if n_items >= 2:\n        group = random.choice(groups)\n        i, j = random.sample(range(len(group)), 2)\n        i, j = group[i], group[j]\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_weight = current_weight + weight_lst[i] - weight_lst[j]\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8785454361089735,
            2.0242074728012085
        ]
    },
    {
        "algorithm": "{My algorithm intelligently selects a solution from the archive based on a novel diversity-aware selection metric, then applies a hybrid local search strategy that combines probabilistic item inclusion/exclusion with a dynamic neighborhood exploration that prioritizes both value improvements and solution diversity, while always ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate diversity-aware selection metric\n    selection_metrics = []\n    for sol, _ in archive:\n        # Metric combines value potential and solution diversity\n        value_potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        diversity = np.sum(np.abs(sol - archive[0][0]))\n        selection_metrics.append(value_potential * (1 + diversity))\n\n    # Select solution with highest metric\n    selected_idx = np.argmax(selection_metrics)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with probabilistic inclusion/exclusion\n    current_weight = np.sum(weight_lst * new_solution)\n    n_items = len(weight_lst)\n\n    # First phase: probabilistic inclusion of excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        for i in excluded_items:\n            # Probability based on value and inverse weight\n            prob = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n            if random.random() < prob and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Second phase: dynamic neighborhood exploration\n    for _ in range(5):\n        # Select items with high value-to-weight ratio\n        item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        top_items = np.argsort(item_scores)[-min(5, n_items):]\n\n        for i in top_items:\n            if new_solution[i] == 1:\n                # Try removing item with probability based on its contribution\n                contribution = (value1_lst[i] + value2_lst[i]) / current_weight\n                if random.random() < contribution:\n                    new_weight = current_weight - weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 0\n                        current_weight = new_weight\n            else:\n                # Try adding item with probability based on its potential\n                potential = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                if random.random() < potential and (current_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9267661099967333,
            10.44105777144432
        ]
    }
]