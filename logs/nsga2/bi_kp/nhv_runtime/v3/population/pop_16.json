[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and solution density, then applies a novel multi-phase local search that combines probabilistic item replacement with value-weighted neighborhood exploration, ensuring feasibility through dynamic capacity adjustment and always prioritizing Pareto-optimal improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution based on hybrid of dominance and density\n    dominance_scores = []\n    for sol, obj in archive:\n        dominated_count = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] >= obj[0] and other_obj[1] >= obj[1] and (other_obj[0] > obj[0] or other_obj[1] > obj[1])):\n                dominated_count += 1\n        density = np.sum(np.abs(sol - archive[0][0]))\n        dominance_scores.append((len(archive) - dominated_count) * (1 + density))\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Multi-phase local search\n    # Phase 1: Probabilistic item replacement\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1 and random.random() < 0.3:\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n\n    # Phase 2: Value-weighted neighborhood exploration\n    value_weights = value1_lst + value2_lst\n    sorted_indices = np.argsort(-value_weights)\n\n    for i in sorted_indices[:min(10, len(weight_lst))]:\n        if new_solution[i] == 0:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Probability based on value and remaining capacity\n                prob = (value_weights[i] / (weight_lst[i] + 1e-6)) * ((capacity - current_weight) / capacity)\n                if random.random() < prob:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Phase 3: Dynamic capacity adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Remove items with lowest value-to-weight ratio until feasible\n            item_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            sorted_removals = np.argsort(item_ratios[included_items])\n            for i in sorted_removals:\n                if excess <= 0:\n                    break\n                if weight_lst[included_items[i]] <= excess:\n                    new_solution[included_items[i]] = 0\n                    excess -= weight_lst[included_items[i]]\n\n    return new_solution\n\n",
        "score": [
            -0.4217740555113979,
            0.7323683500289917
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective contribution and solution sparsity, then applies a multi-stage local search that alternates between value-aware item swaps and capacity-constrained diversification, while dynamically balancing the exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective contribution and sparsity\n    selection_scores = []\n    for sol, obj in archive:\n        # Calculate objective contributions\n        contrib1 = obj[0] / np.sum(value1_lst * sol) if np.sum(sol) > 0 else 0\n        contrib2 = obj[1] / np.sum(value2_lst * sol) if np.sum(sol) > 0 else 0\n        # Calculate sparsity (proportion of excluded items)\n        sparsity = np.sum(sol == 0) / len(sol)\n        # Combined score\n        selection_scores.append((contrib1 + contrib2) * sparsity)\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Multi-stage local search\n    n_items = len(weight_lst)\n\n    # Stage 1: Value-aware swaps\n    for _ in range(3):\n        # Calculate combined value-to-weight ratios\n        ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        # Find top and bottom items\n        top_items = np.argsort(ratios)[-min(3, n_items):]\n        bottom_items = np.argsort(ratios)[:min(3, n_items)]\n\n        for i in top_items:\n            for j in bottom_items:\n                if new_solution[i] == 1 and new_solution[j] == 0:\n                    delta_weight = weight_lst[j] - weight_lst[i]\n                    if current_weight + delta_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight += delta_weight\n                        break\n\n    # Stage 2: Capacity-constrained diversification\n    if current_weight < capacity * 0.7:\n        # Add low-weight items with high potential\n        candidate_items = np.where(new_solution == 0)[0]\n        candidate_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        candidate_ratios[candidate_items] *= (capacity - current_weight) / capacity\n        top_candidates = np.argsort(-candidate_ratios)[:min(5, len(candidate_items))]\n\n        for i in top_candidates:\n            if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Stage 3: Objective-balanced adjustments\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    if abs(total_value1 - total_value2) > 0.1 * (total_value1 + total_value2):\n        # Balance objectives by swapping items\n        if total_value1 > total_value2:\n            # Replace high-value1 items with better value2 alternatives\n            high_value1_items = np.where((new_solution == 1) & (value1_lst > value2_lst))[0]\n            if len(high_value1_items) > 0:\n                best_candidate = None\n                max_improvement = 0\n                for i in high_value1_items:\n                    for j in np.where(new_solution == 0)[0]:\n                        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                            improvement = (value2_lst[j] - value1_lst[i]) / (weight_lst[j] - weight_lst[i] + 1e-6)\n                            if improvement > max_improvement:\n                                max_improvement = improvement\n                                best_candidate = (i, j)\n                if best_candidate:\n                    i, j = best_candidate\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Replace high-value2 items with better value1 alternatives\n            high_value2_items = np.where((new_solution == 1) & (value2_lst > value1_lst))[0]\n            if len(high_value2_items) > 0:\n                best_candidate = None\n                max_improvement = 0\n                for i in high_value2_items:\n                    for j in np.where(new_solution == 0)[0]:\n                        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                            improvement = (value1_lst[j] - value2_lst[i]) / (weight_lst[j] - weight_lst[i] + 1e-6)\n                            if improvement > max_improvement:\n                                max_improvement = improvement\n                                best_candidate = (i, j)\n                if best_candidate:\n                    i, j = best_candidate\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9824145934822279,
            10.431624859571457
        ]
    }
]