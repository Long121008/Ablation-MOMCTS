[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and solution sparsity, then applies a three-stage local search that combines value-driven insertions, capacity-aware deletions, and objective-balancing exchanges, while dynamically adjusting the exploration scope based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective dominance and sparsity\n    dominance_scores = []\n    for sol, obj in archive:\n        dominance = (obj[0] / (np.sum(value1_lst) + 1e-6)) + (obj[1] / (np.sum(value2_lst) + 1e-6))\n        sparsity = np.sum(np.abs(sol - np.mean(archive[0][0]))) / len(sol)\n        dominance_scores.append(dominance * sparsity)\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-driven insertions with adaptive selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value ratio with objective correlation\n        value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_correlation = (value1_lst * value2_lst) / ((value1_lst + 1e-6) * (value2_lst + 1e-6))\n        combined_scores = value_ratio * objective_correlation\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(4, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-aware deletions with value preservation\n    if current_weight > capacity * 0.85:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize deletions based on value density and objective correlation\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            objective_correlation = (value1_lst * value2_lst) / ((value1_lst + 1e-6) * (value2_lst + 1e-6))\n            deletion_scores = value_density * (1 - objective_correlation)\n            candidate_removals = included_items[np.argsort(-deletion_scores[included_items])[:min(2, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing exchanges with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.2:\n        # Calculate exchange potential based on objective balance improvement\n        exchange_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j]) + (total_value2 - value2_lst[i] + value2_lst[j])\n                    exchange_potential.append((i, j, new_balance))\n\n        if exchange_potential:\n            # Select the exchange that most improves balance\n            best_exchange = max(exchange_potential, key=lambda x: x[2])\n            new_solution[best_exchange[0]], new_solution[best_exchange[1]] = new_solution[best_exchange[1]], new_solution[best_exchange[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8611618866243385,
            5.232600212097168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective dominance and sparsity\n    dominance_scores = []\n    for sol, obj in archive:\n        dominance = (obj[0] / (np.sum(value1_lst) + 1e-6)) + (obj[1] / (np.sum(value2_lst) + 1e-6))\n        sparsity = np.sum(np.abs(sol - np.mean(archive[0][0]))) / len(sol)\n        dominance_scores.append(dominance * sparsity)\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-driven insertions with adaptive selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value ratio with objective correlation\n        value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_correlation = (value1_lst * value2_lst) / ((value1_lst + 1e-6) * (value2_lst + 1e-6))\n        combined_scores = value_ratio * objective_correlation\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(4, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-aware deletions with value preservation\n    if current_weight > capacity * 0.85:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize deletions based on value density and objective correlation\n            value_density = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            objective_correlation = (value1_lst * value2_lst) / ((value1_lst + 1e-6) * (value2_lst + 1e-6))\n            deletion_scores = value_density * (1 - objective_correlation)\n            candidate_removals = included_items[np.argsort(-deletion_scores[included_items])[:min(2, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing exchanges with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.2:\n        # Calculate exchange potential based on objective balance improvement\n        exchange_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j]) + (total_value2 - value2_lst[i] + value2_lst[j])\n                    exchange_potential.append((i, j, new_balance))\n\n        if exchange_potential:\n            # Select the exchange that most improves balance\n            best_exchange = max(exchange_potential, key=lambda x: x[2])\n            new_solution[best_exchange[0]], new_solution[best_exchange[1]] = new_solution[best_exchange[1]], new_solution[best_exchange[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8678694061714769,
            1.6999408304691315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution sparsity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces using a novel dominance-aware selection mechanism and sparsity-based diversification strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective dominance and sparsity\n    dominance_scores = []\n    for sol, obj in archive:\n        # Calculate dominance score based on how many other solutions this solution dominates\n        dominates = 0\n        for _, other_obj in archive:\n            if (obj[0] >= other_obj[0] and obj[1] > other_obj[1]) or (obj[0] > other_obj[0] and obj[1] >= other_obj[1]):\n                dominates += 1\n        sparsity = np.sum(np.abs(sol - np.mean([s for s, _ in archive], axis=0)))\n        dominance_scores.append(dominates * sparsity)\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic dominance consideration\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with dominance potential\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        dominance_potential = (value1_lst / (value1_lst + value2_lst + 1e-6)) * (value2_lst / (value1_lst + value2_lst + 1e-6))\n        combined_scores = value_ratios * dominance_potential\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with dominance preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve dominance more effectively\n            dominance_preservation = (value1_lst / (value1_lst + value2_lst + 1e-6)) * (value2_lst / (value1_lst + value2_lst + 1e-6))\n            candidate_removals = included_items[np.argsort(dominance_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic dominance adjustment\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on dominance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_v1 = total_value1 - value1_lst[i] + value1_lst[j]\n                    new_v2 = total_value2 - value2_lst[i] + value2_lst[j]\n                    new_dominance = (new_v1 / (new_v1 + new_v2 + 1e-6)) * (new_v2 / (new_v1 + new_v2 + 1e-6))\n                    swap_potential.append((i, j, new_dominance))\n\n        if swap_potential:\n            # Select the swap that most improves dominance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9207006450729498,
            8.995639085769653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective dominance and sparsity\n    dominance_scores = []\n    for sol, obj in archive:\n        # Calculate dominance score based on how many other solutions this solution dominates\n        dominates = 0\n        for _, other_obj in archive:\n            if (obj[0] >= other_obj[0] and obj[1] > other_obj[1]) or (obj[0] > other_obj[0] and obj[1] >= other_obj[1]):\n                dominates += 1\n        sparsity = np.sum(np.abs(sol - np.mean([s for s, _ in archive], axis=0)))\n        dominance_scores.append(dominates * sparsity)\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic dominance consideration\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with dominance potential\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        dominance_potential = (value1_lst / (value1_lst + value2_lst + 1e-6)) * (value2_lst / (value1_lst + value2_lst + 1e-6))\n        combined_scores = value_ratios * dominance_potential\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with dominance preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve dominance more effectively\n            dominance_preservation = (value1_lst / (value1_lst + value2_lst + 1e-6)) * (value2_lst / (value1_lst + value2_lst + 1e-6))\n            candidate_removals = included_items[np.argsort(dominance_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic dominance adjustment\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on dominance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_v1 = total_value1 - value1_lst[i] + value1_lst[j]\n                    new_v2 = total_value2 - value2_lst[i] + value2_lst[j]\n                    new_dominance = (new_v1 / (new_v1 + new_v2 + 1e-6)) * (new_v2 / (new_v1 + new_v2 + 1e-6))\n                    swap_potential.append((i, j, new_dominance))\n\n        if swap_potential:\n            # Select the swap that most improves dominance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution density, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective dominance and density\n    dominance_scores = []\n    for sol, obj in archive:\n        dominance = obj[0] * obj[1] / (obj[0] + obj[1] + 1e-6)\n        density = np.sum(sol) / len(sol)\n        dominance_scores.append(dominance * (1 - density))\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective dominance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_dominance = (value1_lst * value2_lst) / (value1_lst + value2_lst + 1e-6)\n        combined_scores = value_ratios * objective_dominance\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j]) * (total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.9225486986359113,
            1.4798527956008911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective dominance and density\n    dominance_scores = []\n    for sol, obj in archive:\n        dominance = obj[0] * obj[1] / (obj[0] + obj[1] + 1e-6)\n        density = np.sum(sol) / len(sol)\n        dominance_scores.append(dominance * (1 - density))\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective dominance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_dominance = (value1_lst * value2_lst) / (value1_lst + value2_lst + 1e-6)\n        combined_scores = value_ratios * objective_dominance\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j]) * (total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8801120416110044,
            2.390406996011734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = abs((total_value1 - value1_lst[i] + value1_lst[j]) - (total_value2 - value2_lst[i] + value2_lst[j]))\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = min(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8739604132335497,
            2.3422538936138153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = abs((total_value1 - value1_lst[i] + value1_lst[j]) - (total_value2 - value2_lst[i] + value2_lst[j]))\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = min(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 307,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8997828030409131,
            1.9928731322288513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel combination of objective balance and solution diversity, then applies a multi-phase local search that alternates between value-aware item additions, capacity-constrained item removals, and objective-balancing swaps, while dynamically adjusting the exploration intensity based on the current solution's performance in both objective spaces.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on objective balance and diversity\n    balance_scores = []\n    for sol, obj in archive:\n        balance = min(obj[0], obj[1]) / (max(obj[0], obj[1]) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        balance_scores.append(balance * (1 - diversity))\n\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-aware additions with dynamic selection\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value-to-weight ratio with objective balance consideration\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        objective_balance = np.abs(value1_lst - value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-6)\n        combined_scores = value_ratios * (1 - objective_balance)\n        candidate_items = excluded_items[np.argsort(-combined_scores[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-constrained removals with value preservation\n    if current_weight > capacity * 0.9:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize removals that preserve value more effectively\n            value_preservation = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(value_preservation[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps with dynamic intensity\n    imbalance_ratio = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance_ratio > 0.15:\n        # Calculate swap potential based on objective balance improvement\n        swap_potential = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_balance = (total_value1 - value1_lst[i] + value1_lst[j] + total_value2 - value2_lst[i] + value2_lst[j])\n                    swap_potential.append((i, j, new_balance))\n\n        if swap_potential:\n            # Select the swap that most improves balance\n            best_swap = max(swap_potential, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 308,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of solution quality and diversity, then applies a three-stage local search that combines value-focused item additions, capacity-aware item removals, and objective-balancing swaps, while dynamically adjusting the search intensity based on the current solution's performance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on quality and diversity\n    quality_scores = []\n    for sol, obj in archive:\n        quality = np.sum(obj) / (np.sum(weight_lst * sol) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        quality_scores.append(quality * (1 - diversity))\n\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-focused additions\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value density\n        value_density = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        candidate_items = excluded_items[np.argsort(-value_density[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-aware removals\n    if current_weight > capacity * 0.8:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize items with lowest marginal value\n            marginal_value = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(marginal_value[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps\n    imbalance = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance > 0.2:\n        # Find best swap to improve balance\n        swap_candidates = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_v1 = total_value1 - value1_lst[i] + value1_lst[j]\n                    new_v2 = total_value2 - value2_lst[i] + value2_lst[j]\n                    new_imbalance = abs(new_v1 - new_v2) / (new_v1 + new_v2 + 1e-6)\n                    swap_candidates.append((i, j, new_imbalance))\n\n        if swap_candidates:\n            best_swap = min(swap_candidates, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8679590624062556,
            4.33030766248703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Selection based on quality and diversity\n    quality_scores = []\n    for sol, obj in archive:\n        quality = np.sum(obj) / (np.sum(weight_lst * sol) + 1e-6)\n        diversity = np.sum(sol) / len(sol)\n        quality_scores.append(quality * (1 - diversity))\n\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n\n    # Phase 1: Value-focused additions\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate combined value density\n        value_density = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        candidate_items = excluded_items[np.argsort(-value_density[excluded_items])[:min(5, len(excluded_items))]]\n\n        for i in candidate_items:\n            if (current_weight + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                total_value1 += value1_lst[i]\n                total_value2 += value2_lst[i]\n\n    # Phase 2: Capacity-aware removals\n    if current_weight > capacity * 0.8:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            # Prioritize items with lowest marginal value\n            marginal_value = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidate_removals = included_items[np.argsort(marginal_value[included_items])[:min(3, len(included_items))]]\n\n            for i in candidate_removals:\n                if (current_weight - weight_lst[i]) >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    total_value1 -= value1_lst[i]\n                    total_value2 -= value2_lst[i]\n\n    # Phase 3: Objective-balancing swaps\n    imbalance = abs(total_value1 - total_value2) / (total_value1 + total_value2 + 1e-6)\n    if imbalance > 0.2:\n        # Find best swap to improve balance\n        swap_candidates = []\n        for i in np.where(new_solution == 1)[0]:\n            for j in np.where(new_solution == 0)[0]:\n                if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n                    new_v1 = total_value1 - value1_lst[i] + value1_lst[j]\n                    new_v2 = total_value2 - value2_lst[i] + value2_lst[j]\n                    new_imbalance = abs(new_v1 - new_v2) / (new_v1 + new_v2 + 1e-6)\n                    swap_candidates.append((i, j, new_imbalance))\n\n        if swap_candidates:\n            best_swap = min(swap_candidates, key=lambda x: x[2])\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    return new_solution\n\n"
    }
]