[
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Probabilistic local search: flip items with high marginal contributions\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in + marginal2_in\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out + marginal2_out\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9293070035629538,
            7.891713231801987
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with higher value-to-weight ratios in both objectives, then applies a hybrid local search that combines item swaps and flips, while ensuring feasibility, to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: iterative improvement with swaps and flips\n    for _ in range(5):\n        # Compute value-to-weight ratios for all items\n        ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n\n        # Identify items to consider\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Try to swap the worst included item with the best excluded item\n        if len(included) > 0 and len(excluded) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            best_out = excluded[np.argmax(ratios[excluded])]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in], temp_solution[best_out] = temp_solution[best_out], temp_solution[worst_in]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # If swap fails, try flipping the worst included item\n        if len(included) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.40080950817278876,
            3.4534405767917633
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Probabilistic local search: flip items with high marginal contributions\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in + marginal2_in\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out + marginal2_out\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9293070035629538,
            7.891713231801987
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with higher value-to-weight ratios in both objectives, then applies a hybrid local search that combines item swaps and flips, while ensuring feasibility, to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: iterative improvement with swaps and flips\n    for _ in range(5):\n        # Compute value-to-weight ratios for all items\n        ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n\n        # Identify items to consider\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Try to swap the worst included item with the best excluded item\n        if len(included) > 0 and len(excluded) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            best_out = excluded[np.argmax(ratios[excluded])]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in], temp_solution[best_out] = temp_solution[best_out], temp_solution[worst_in]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # If swap fails, try flipping the worst included item\n        if len(included) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.40080950817278876,
            3.4534405767917633
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their proximity to the capacity, then applies a value-weighted swap strategy combined with a probabilistic flip mechanism to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([np.sum(weight_lst[sol[0] == 1]) for sol in archive])\n    utilization = weights / capacity\n    selected_idx = np.argmax(utilization * (1 - utilization))  # Prefer solutions near but not at full capacity\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Compute current state\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: value-weighted swaps with probabilistic flips\n    for _ in range(5):\n        # Value-weighted swap\n        if len(included) > 0 and len(excluded) > 0:\n            # Compute combined value weights\n            combined_weights = value1_lst + value2_lst\n            # Select item to remove (highest value)\n            remove_candidate = included[np.argmax(combined_weights[included])]\n            # Select item to add (highest value-to-weight ratio)\n            add_candidates = excluded[weight_lst[excluded] <= (capacity - current_weight + weight_lst[remove_candidate])]\n            if len(add_candidates) > 0:\n                value_to_weight = combined_weights[add_candidates] / (weight_lst[add_candidates] + 1e-10)\n                add_candidate = add_candidates[np.argmax(value_to_weight)]\n\n                # Perform swap\n                temp_solution = new_solution.copy()\n                temp_solution[remove_candidate] = 0\n                temp_solution[add_candidate] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    continue\n\n        # Probabilistic flip if swap fails\n        if len(included) > 0 and np.random.rand() < 0.3:  # 30% chance to flip\n            flip_candidate = np.random.choice(included)\n            temp_solution = new_solution.copy()\n            temp_solution[flip_candidate] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.89674858821766,
            4.751369684934616
        ]
    }
]