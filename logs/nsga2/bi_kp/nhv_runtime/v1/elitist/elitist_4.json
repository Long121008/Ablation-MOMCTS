[
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Sequential local search with objective-based flips\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other cluster\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n            other_cluster = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_cluster] + value2_lst[other_cluster]\n            best_out = other_cluster[np.argmax(other_values)]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7743559507422906,
            1.2217941284179688
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Sequential local search with objective-based flips\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other cluster\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n            other_cluster = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_cluster] + value2_lst[other_cluster]\n            best_out = other_cluster[np.argmax(other_values)]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7743559507422906,
            1.2217941284179688
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{The new algorithm uses a hybrid approach combining greedy selection of high-value items with a probabilistic local search that prioritizes items with balanced marginal contributions to both objectives, while also incorporating a diversity-preserving mechanism to avoid local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [sol[1][0] + sol[1][1] for sol in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: prioritize items with balanced contributions\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate balanced marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = (marginal1_in + marginal2_in) / 2  # Average to balance objectives\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate balanced marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = (marginal1_out + marginal2_out) / 2  # Average to balance objectives\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Add diversity by flipping a random item if no improvement\n    if np.array_equal(new_solution, base_solution):\n        all_items = np.arange(len(base_solution))\n        np.random.shuffle(all_items)\n        for item in all_items:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1 - temp_solution[item]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8463838006754143,
            2.6570562422275543
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with higher normalized value-to-weight ratios in both objectives, then applies a hybrid local search that combines item swaps, flips, and a novel segment-based perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    norm_value1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    norm_value2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_ratios = (norm_value1 + norm_value2) / (weight_lst + 1e-10)\n\n    # Select solution with highest combined ratio\n    selected_idx = np.argmax([np.sum(combined_ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with segment-based perturbation\n    for _ in range(5):\n        # Compute combined ratios for all items\n        ratios = combined_ratios\n\n        # Identify items to consider\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Try segment-based perturbation: flip a random segment of items\n        if len(included) > 1:\n            segment_start = np.random.randint(0, len(included) - 1)\n            segment_end = np.random.randint(segment_start + 1, len(included))\n            temp_solution = new_solution.copy()\n            temp_solution[included[segment_start:segment_end]] = 1 - temp_solution[included[segment_start:segment_end]]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Try swap the worst included item with the best excluded item\n        if len(included) > 0 and len(excluded) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            best_out = excluded[np.argmax(ratios[excluded])]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in], temp_solution[best_out] = temp_solution[best_out], temp_solution[worst_in]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # If both fail, try flipping the worst included item\n        if len(included) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9228420695165463,
            5.503810077905655
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Sequential local search with objective-based flips\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other cluster\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n            other_cluster = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_cluster] + value2_lst[other_cluster]\n            best_out = other_cluster[np.argmax(other_values)]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7743559507422906,
            1.2217941284179688
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their proximity to the capacity, then applies a value-weighted swap strategy combined with a probabilistic flip mechanism to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([np.sum(weight_lst[sol[0] == 1]) for sol in archive])\n    utilization = weights / capacity\n    selected_idx = np.argmax(utilization * (1 - utilization))  # Prefer solutions near but not at full capacity\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Compute current state\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: value-weighted swaps with probabilistic flips\n    for _ in range(5):\n        # Value-weighted swap\n        if len(included) > 0 and len(excluded) > 0:\n            # Compute combined value weights\n            combined_weights = value1_lst + value2_lst\n            # Select item to remove (highest value)\n            remove_candidate = included[np.argmax(combined_weights[included])]\n            # Select item to add (highest value-to-weight ratio)\n            add_candidates = excluded[weight_lst[excluded] <= (capacity - current_weight + weight_lst[remove_candidate])]\n            if len(add_candidates) > 0:\n                value_to_weight = combined_weights[add_candidates] / (weight_lst[add_candidates] + 1e-10)\n                add_candidate = add_candidates[np.argmax(value_to_weight)]\n\n                # Perform swap\n                temp_solution = new_solution.copy()\n                temp_solution[remove_candidate] = 0\n                temp_solution[add_candidate] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    continue\n\n        # Probabilistic flip if swap fails\n        if len(included) > 0 and np.random.rand() < 0.3:  # 30% chance to flip\n            flip_candidate = np.random.choice(included)\n            temp_solution = new_solution.copy()\n            temp_solution[flip_candidate] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.89674858821766,
            4.751369684934616
        ]
    }
]