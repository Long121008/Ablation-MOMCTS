[
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Sequential local search with objective-based flips\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other cluster\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n            other_cluster = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_cluster] + value2_lst[other_cluster]\n            best_out = other_cluster[np.argmax(other_values)]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7743559507422906,
            1.2217941284179688
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    knee_idx = np.argmin(np.abs(objectives[:, 0] - objectives[:, 1]))\n    base_solution = archive[knee_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Get current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: swap items with high value ratios and flip low-value items\n    for _ in range(5):  # Limit iterations\n        # Compute normalized value ratios\n        ratios1 = value1_lst / (weight_lst + 1e-10)\n        ratios2 = value2_lst / (weight_lst + 1e-10)\n        combined_ratios = (ratios1 + ratios2) / 2\n\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Prioritize items with high combined value ratios\n        if len(included) > 0 and len(excluded) > 0:\n            best_in = included[np.argmax(combined_ratios[included])]\n            best_out = excluded[np.argmax(combined_ratios[excluded])]\n\n            # Attempt swap\n            temp_solution = new_solution.copy()\n            temp_solution[best_in], temp_solution[best_out] = temp_solution[best_out], temp_solution[best_in]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        # If swap fails, try flipping a low-value item\n        if len(included) > 0:\n            worst_in = included[np.argmin(combined_ratios[included])]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8029351188242111,
            3.476093351840973
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with higher normalized value-to-weight ratios in both objectives, then applies a hybrid local search that combines item swaps, flips, and a novel segment-based perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    norm_value1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    norm_value2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_ratios = (norm_value1 + norm_value2) / (weight_lst + 1e-10)\n\n    # Select solution with highest combined ratio\n    selected_idx = np.argmax([np.sum(combined_ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with segment-based perturbation\n    for _ in range(5):\n        # Compute combined ratios for all items\n        ratios = combined_ratios\n\n        # Identify items to consider\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Try segment-based perturbation: flip a random segment of items\n        if len(included) > 1:\n            segment_start = np.random.randint(0, len(included) - 1)\n            segment_end = np.random.randint(segment_start + 1, len(included))\n            temp_solution = new_solution.copy()\n            temp_solution[included[segment_start:segment_end]] = 1 - temp_solution[included[segment_start:segment_end]]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Try swap the worst included item with the best excluded item\n        if len(included) > 0 and len(excluded) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            best_out = excluded[np.argmax(ratios[excluded])]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in], temp_solution[best_out] = temp_solution[best_out], temp_solution[worst_in]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # If both fail, try flipping the worst included item\n        if len(included) > 0:\n            worst_in = included[np.argmin(ratios[included])]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9228420695165463,
            5.503810077905655
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Sequential local search with objective-based flips\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other cluster\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n            other_cluster = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_cluster] + value2_lst[other_cluster]\n            best_out = other_cluster[np.argmax(other_values)]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7743559507422906,
            1.2217941284179688
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with balanced contributions to both objectives, then applies a novel \"value-aware perturbation\" local search that iteratively adjusts item selections based on their marginal contributions to each objective, while ensuring feasibility through a dynamic trade-off mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Value-aware perturbation local search\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate normalized marginal contributions\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            combined_in = (marginal1_in + marginal2_in) / 2\n\n            # Probabilistically select item to remove based on trade-off\n            probs_in = combined_in / np.sum(combined_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n\n            # Calculate trade-off factor\n            trade_off = (value1_lst[item_to_remove] / (current_value1 + 1e-10)) / (value2_lst[item_to_remove] / (current_value2 + 1e-10))\n\n            # Adjust removal probability based on trade-off\n            if trade_off > 1.5 or trade_off < 0.67:\n                removal_prob = 0.7\n            else:\n                removal_prob = 0.3\n\n            if np.random.rand() < removal_prob:\n                temp_solution = new_solution.copy()\n                temp_solution[item_to_remove] = 0\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    continue\n\n        if len(excluded) > 0:\n            # Calculate normalized marginal contributions\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            combined_out = (marginal1_out + marginal2_out) / 2\n\n            # Probabilistically select item to add based on trade-off\n            probs_out = combined_out / np.sum(combined_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n\n            # Calculate trade-off factor\n            trade_off = (value1_lst[item_to_add] / (current_value1 + 1e-10)) / (value2_lst[item_to_add] / (current_value2 + 1e-10))\n\n            # Adjust addition probability based on trade-off\n            if trade_off > 1.5 or trade_off < 0.67:\n                addition_prob = 0.7\n            else:\n                addition_prob = 0.3\n\n            if np.random.rand() < addition_prob:\n                temp_solution = new_solution.copy()\n                temp_solution[item_to_add] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8312142442345544,
            4.327194064855576
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their proximity to the capacity, then applies a value-weighted swap strategy combined with a probabilistic flip mechanism to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([np.sum(weight_lst[sol[0] == 1]) for sol in archive])\n    utilization = weights / capacity\n    selected_idx = np.argmax(utilization * (1 - utilization))  # Prefer solutions near but not at full capacity\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Compute current state\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: value-weighted swaps with probabilistic flips\n    for _ in range(5):\n        # Value-weighted swap\n        if len(included) > 0 and len(excluded) > 0:\n            # Compute combined value weights\n            combined_weights = value1_lst + value2_lst\n            # Select item to remove (highest value)\n            remove_candidate = included[np.argmax(combined_weights[included])]\n            # Select item to add (highest value-to-weight ratio)\n            add_candidates = excluded[weight_lst[excluded] <= (capacity - current_weight + weight_lst[remove_candidate])]\n            if len(add_candidates) > 0:\n                value_to_weight = combined_weights[add_candidates] / (weight_lst[add_candidates] + 1e-10)\n                add_candidate = add_candidates[np.argmax(value_to_weight)]\n\n                # Perform swap\n                temp_solution = new_solution.copy()\n                temp_solution[remove_candidate] = 0\n                temp_solution[add_candidate] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    continue\n\n        # Probabilistic flip if swap fails\n        if len(included) > 0 and np.random.rand() < 0.3:  # 30% chance to flip\n            flip_candidate = np.random.choice(included)\n            temp_solution = new_solution.copy()\n            temp_solution[flip_candidate] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.89674858821766,
            4.751369684934616
        ]
    }
]