[
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering based on objective ratios and sequential swaps between clusters, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective ratio\n    ratios = (value1_lst / (value2_lst + 1e-10)) / (weight_lst + 1e-10)\n    clusters = np.digitize(ratios, bins=[-np.inf, 0.5, 1.5, np.inf])\n\n    # Hybrid local search: sequential swaps between clusters with Pareto front consideration\n    for cluster in [1, 2, 0]:  # Priority: high ratio, medium ratio, low ratio\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select worst item in cluster based on marginal utility\n            cluster_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            worst_in = included[np.argmin(cluster_utils)]\n\n            # Select best item from other clusters based on curvature of Pareto front\n            other_clusters = np.where(clusters != cluster)[0]\n            other_utils = (value1_lst[other_clusters] + value2_lst[other_clusters]) / (weight_lst[other_clusters] + 1e-10)\n            best_out = other_clusters[np.argmax(other_utils)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9593092457806813,
            0.4256734848022461
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9908584396796011,
            0.704540491104126
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering based on objective ratios and sequential swaps between clusters, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective ratio\n    ratios = (value1_lst / (value2_lst + 1e-10)) / (weight_lst + 1e-10)\n    clusters = np.digitize(ratios, bins=[-np.inf, 0.5, 1.5, np.inf])\n\n    # Hybrid local search: sequential swaps between clusters with Pareto front consideration\n    for cluster in [1, 2, 0]:  # Priority: high ratio, medium ratio, low ratio\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select worst item in cluster based on marginal utility\n            cluster_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            worst_in = included[np.argmin(cluster_utils)]\n\n            # Select best item from other clusters based on curvature of Pareto front\n            other_clusters = np.where(clusters != cluster)[0]\n            other_utils = (value1_lst[other_clusters] + value2_lst[other_clusters]) / (weight_lst[other_clusters] + 1e-10)\n            best_out = other_clusters[np.argmax(other_utils)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9593092457806813,
            0.4256734848022461
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9908584396796011,
            0.704540491104126
        ]
    }
]