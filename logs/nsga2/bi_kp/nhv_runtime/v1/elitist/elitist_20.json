[
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios and prioritize items with balanced trade-offs\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9871812373324322,
            0.4312814772129059
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and weight balancing\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try adding the next item with highest ratio\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[-1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.917017128010354,
            0.40557393431663513
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest Euclidean distance from the ideal point in the objective space, then applies a novel local search that combines adaptive item replacement with objective-aware neighborhood exploration, ensuring feasibility while maximizing both objectives through a dynamic trade-off analysis.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest Euclidean distance from ideal point\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n    distances = [np.sqrt((max_v1 - v1)**2 + (max_v2 - v2)**2) for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective trade-off scores\n    tradeoff_scores = (value1_lst / (value2_lst + 1e-10)) * (1 - base_solution) + (base_solution * (value2_lst / (value1_lst + 1e-10)))\n    sorted_indices = np.argsort(tradeoff_scores)[::-1]\n\n    # Adaptive neighborhood exploration\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try replacing with best available item\n            available_items = np.where((base_solution == 0) & (weight_lst <= capacity - temp_weight + weight_lst[current_item]))[0]\n            if len(available_items) > 0:\n                best_replacement = available_items[np.argmax(tradeoff_scores[available_items])]\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[best_replacement] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8701354900967698,
            0.4000186622142792
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering based on objective ratios and sequential swaps between clusters, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective ratio\n    ratios = (value1_lst / (value2_lst + 1e-10)) / (weight_lst + 1e-10)\n    clusters = np.digitize(ratios, bins=[-np.inf, 0.5, 1.5, np.inf])\n\n    # Hybrid local search: sequential swaps between clusters with Pareto front consideration\n    for cluster in [1, 2, 0]:  # Priority: high ratio, medium ratio, low ratio\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select worst item in cluster based on marginal utility\n            cluster_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            worst_in = included[np.argmin(cluster_utils)]\n\n            # Select best item from other clusters based on curvature of Pareto front\n            other_clusters = np.where(clusters != cluster)[0]\n            other_utils = (value1_lst[other_clusters] + value2_lst[other_clusters]) / (weight_lst[other_clusters] + 1e-10)\n            best_out = other_clusters[np.argmax(other_utils)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9593092457806813,
            0.4256734848022461
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9908584396796011,
            0.704540491104126
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\n",
        "score": [
            -1.0044757422625066,
            3.9850511848926544
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8168215674248072,
            0.3217490315437317
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering based on objective ratios and sequential swaps between clusters, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective ratio\n    ratios = (value1_lst / (value2_lst + 1e-10)) / (weight_lst + 1e-10)\n    clusters = np.digitize(ratios, bins=[-np.inf, 0.5, 1.5, np.inf])\n\n    # Hybrid local search: sequential swaps between clusters with Pareto front consideration\n    for cluster in [1, 2, 0]:  # Priority: high ratio, medium ratio, low ratio\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select worst item in cluster based on marginal utility\n            cluster_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            worst_in = included[np.argmin(cluster_utils)]\n\n            # Select best item from other clusters based on curvature of Pareto front\n            other_clusters = np.where(clusters != cluster)[0]\n            other_utils = (value1_lst[other_clusters] + value2_lst[other_clusters]) / (weight_lst[other_clusters] + 1e-10)\n            best_out = other_clusters[np.argmax(other_utils)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9593092457806813,
            0.4256734848022461
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9908584396796011,
            0.704540491104126
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering based on objective ratios and sequential swaps between clusters, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective ratio\n    ratios = (value1_lst / (value2_lst + 1e-10)) / (weight_lst + 1e-10)\n    clusters = np.digitize(ratios, bins=[-np.inf, 0.5, 1.5, np.inf])\n\n    # Hybrid local search: sequential swaps between clusters with Pareto front consideration\n    for cluster in [1, 2, 0]:  # Priority: high ratio, medium ratio, low ratio\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select worst item in cluster based on marginal utility\n            cluster_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            worst_in = included[np.argmin(cluster_utils)]\n\n            # Select best item from other clusters based on curvature of Pareto front\n            other_clusters = np.where(clusters != cluster)[0]\n            other_utils = (value1_lst[other_clusters] + value2_lst[other_clusters]) / (weight_lst[other_clusters] + 1e-10)\n            best_out = other_clusters[np.argmax(other_utils)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9593092457806813,
            0.4256734848022461
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Hybrid local search: sequential swaps with objective ratio-based prioritization\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with next item\n            if i < len(sorted_indices) - 1:\n                next_item = sorted_indices[i+1]\n                if base_solution[next_item] == 0:\n                    temp_solution = new_solution.copy()\n                    temp_solution[current_item] = 0\n                    temp_solution[next_item] = 1\n                    temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                    if temp_weight <= capacity:\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9908584396796011,
            0.704540491104126
        ]
    }
]