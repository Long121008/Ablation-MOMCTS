[
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Hybrid local search: sequential flips with objective-based prioritization and cluster-based swaps\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other clusters\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n\n            # Select best item from other clusters\n            other_clusters = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_clusters] + value2_lst[other_clusters]\n            best_out = other_clusters[np.argmax(other_values)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8187267089288501,
            0.4586949646472931
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Hybrid local search: sequential flips with objective-based prioritization and cluster-based swaps\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other clusters\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n\n            # Select best item from other clusters\n            other_clusters = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_clusters] + value2_lst[other_clusters]\n            best_out = other_clusters[np.argmax(other_values)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8187267089288501,
            0.4586949646472931
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    for cluster in [1, 2, 0]:\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n\n            other_clusters = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_clusters] + value2_lst[other_clusters]\n            best_out = other_clusters[np.argmax(other_values)]\n\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9456637711243426,
            1.8684925138950348
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{This algorithm combines a diversity-aware selection of solutions with a novel local search that uses objective-specific item prioritization and dynamic trade-off adjustments, ensuring feasibility while exploring high-value regions of the solution space through a combination of marginal contribution analysis and probabilistic flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    selected_idx = np.argmax(np.std(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-specific prioritization\n    for obj in [1, 2]:\n        if obj == 1:\n            values = value1_lst\n            other_values = value2_lst\n        else:\n            values = value2_lst\n            other_values = value1_lst\n\n        # Calculate trade-off scores\n        tradeoff_scores = values / (other_values + 1e-10)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Remove worst items based on trade-off\n        if len(included) > 0:\n            in_scores = tradeoff_scores[included]\n            worst_in = included[np.argmin(in_scores)]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        # Add best items based on trade-off\n        if len(excluded) > 0 and current_weight < capacity:\n            out_scores = tradeoff_scores[excluded]\n            out_weights = weight_lst[excluded]\n            feasible = (current_weight + out_weights) <= capacity\n            feasible_excluded = excluded[feasible]\n\n            if len(feasible_excluded) > 0:\n                best_out = feasible_excluded[np.argmax(out_scores[feasible])]\n                new_solution[best_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9141047051675751,
            0.5808240473270416
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Hybrid local search: sequential flips with objective-based prioritization and cluster-based swaps\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other clusters\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n\n            # Select best item from other clusters\n            other_clusters = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_clusters] + value2_lst[other_clusters]\n            best_out = other_clusters[np.argmax(other_values)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8187267089288501,
            0.4586949646472931
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    }
]