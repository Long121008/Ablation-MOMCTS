[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([capacity - np.sum(weight_lst[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Get current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: swap items with high value ratios or flip low-value items\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Compute value-to-weight ratios\n        ratios1 = value1_lst / (weight_lst + 1e-10)\n        ratios2 = value2_lst / (weight_lst + 1e-10)\n\n        # Identify items to swap or flip\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Prioritize items with high value ratios\n        if len(included) > 0 and len(excluded) > 0:\n            best_in = included[np.argmax(ratios1[included] + ratios2[included])]\n            best_out = excluded[np.argmax(ratios1[excluded] + ratios2[excluded])]\n\n            # Attempt swap\n            temp_solution = new_solution.copy()\n            temp_solution[best_in], temp_solution[best_out] = temp_solution[best_out], temp_solution[best_in]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        # If swap fails, try flipping a low-value item\n        if len(included) > 0:\n            worst_in = included[np.argmin(ratios1[included] + ratios2[included])]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8071563304219469,
            7.057791292667389
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by evaluating the potential for local improvement based on the trade-off between the two objectives, then applies a hybrid local search strategy combining random item swaps and objective-specific flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine random swaps and objective-specific flips\n    for _ in range(5):  # Perform multiple attempts to find a feasible neighbor\n        # Randomly select two items to swap\n        items = list(range(len(new_solution)))\n        random.shuffle(items)\n        i, j = items[0], items[1]\n\n        # Calculate new weight if we swap items i and j\n        delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] != new_solution[j] else 0\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = new_weight\n            break\n\n    # Additional step: flip items based on objective trade-off\n    if random.random() < 0.3:  # 30% chance to perform objective-specific flip\n        # Calculate the ratio of the two objectives\n        ratio = base_val1 / base_val2 if base_val2 != 0 else float('inf')\n\n        if ratio > 1:  # Favoring value1 more\n            # Try to flip items that have higher value1/value2 ratio\n            candidates = [i for i in range(len(new_solution)) if value2_lst[i] > 0 and (value1_lst[i] / value2_lst[i]) > ratio]\n        else:  # Favoring value2 more\n            # Try to flip items that have higher value2/value1 ratio\n            candidates = [i for i in range(len(new_solution)) if value1_lst[i] > 0 and (value2_lst[i] / value1_lst[i]) > (1/ratio)]\n\n        if candidates:\n            # Select a random candidate and flip it if feasible\n            i = random.choice(candidates)\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4212148935483496,
            7.5309770703315735
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([capacity - np.sum(weight_lst[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Get current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: swap items with high value ratios or flip low-value items\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Compute value-to-weight ratios\n        ratios1 = value1_lst / (weight_lst + 1e-10)\n        ratios2 = value2_lst / (weight_lst + 1e-10)\n\n        # Identify items to swap or flip\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        # Prioritize items with high value ratios\n        if len(included) > 0 and len(excluded) > 0:\n            best_in = included[np.argmax(ratios1[included] + ratios2[included])]\n            best_out = excluded[np.argmax(ratios1[excluded] + ratios2[excluded])]\n\n            # Attempt swap\n            temp_solution = new_solution.copy()\n            temp_solution[best_in], temp_solution[best_out] = temp_solution[best_out], temp_solution[best_in]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        # If swap fails, try flipping a low-value item\n        if len(included) > 0:\n            worst_in = included[np.argmin(ratios1[included] + ratios2[included])]\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8071563304219469,
            7.057791292667389
        ]
    }
]