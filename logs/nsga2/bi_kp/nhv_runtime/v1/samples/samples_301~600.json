[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8058186319575423,
            1.8911771178245544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.875918221002181,
            0.4095347225666046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines adaptive item grouping based on objective correlations and targeted sequential swaps between groups, ensuring feasibility while maximizing both objectives through dynamic trade-off exploration by considering the Pareto front's curvature and marginal utility of items, while also incorporating a novel diversification mechanism to escape local optima.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive grouping based on objective correlations\n    correlations = np.corrcoef(value1_lst, value2_lst)[0,1]\n    if correlations > 0.7:\n        # Strong correlation: group by combined utility\n        utils = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        groups = np.digitize(utils, bins=[-np.inf, np.percentile(utils, 33), np.percentile(utils, 66), np.inf])\n    else:\n        # Weak correlation: group by individual objectives\n        groups = np.digitize(value1_lst, bins=[-np.inf, np.median(value1_lst), np.inf]) + \\\n                 2 * np.digitize(value2_lst, bins=[-np.inf, np.median(value2_lst), np.inf])\n\n    # Targeted local search with diversification\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for group in np.random.permutation(np.unique(groups)):\n        group_items = np.where(groups == group)[0]\n        included = group_items[new_solution[group_items] == 1]\n        excluded = group_items[new_solution[group_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate group utilities\n            in_utils = (value1_lst[included] + value2_lst[included]) / (weight_lst[included] + 1e-10)\n            out_utils = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n            # Select worst included and best excluded items\n            worst_in = included[np.argmin(in_utils)]\n            best_out = excluded[np.argmax(out_utils)]\n\n            # Try swap\n            if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[worst_in] = 0\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight = current_weight - weight_lst[worst_in] + weight_lst[best_out]\n                break\n\n            # If swap fails, try adding best_out if possible\n            if current_weight + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[best_out]\n                break\n\n        # Diversification: randomly add an item from the group if possible\n        if len(excluded) > 0 and np.random.rand() < 0.3:\n            candidate = excluded[np.random.randint(len(excluded))]\n            if current_weight + weight_lst[candidate] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[candidate] = 1\n                new_solution = temp_solution\n                current_weight += weight_lst[candidate]\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most extreme trade-offs (either maximizing one objective while sacrificing the other), then applies a novel local search that combines dynamic objective weighting and sequential swaps based on marginal utility ratios, ensuring feasibility while maximizing both objectives through adaptive trade-off exploration and incorporating a diversification mechanism to escape local optima by occasionally introducing random item swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most extreme trade-off (either max value1 or max value2)\n    objectives = np.array([sol[1] for sol in archive])\n    extreme_idx = np.argmax(np.max(objectives, axis=1))\n    base_solution = archive[extreme_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic objective weights based on current solution's trade-off\n    current_v1, current_v2 = archive[extreme_idx][1]\n    weight1 = current_v2 / (current_v1 + current_v2 + 1e-10)\n    weight2 = current_v1 / (current_v1 + current_v2 + 1e-10)\n\n    # Calculate marginal utility ratios\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate weighted marginal utilities\n        in_utils = (weight1 * value1_lst[included] + weight2 * value2_lst[included]) / (weight_lst[included] + 1e-10)\n        out_utils = (weight1 * value1_lst[excluded] + weight2 * value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n        # Select worst included and best excluded items\n        worst_in = included[np.argmin(in_utils)]\n        best_out = excluded[np.argmax(out_utils)]\n\n        # Try swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            new_solution = temp_solution\n\n        # Diversification: occasionally perform random swap if no improvement found\n        if np.random.rand() < 0.2:\n            random_in = np.random.choice(included)\n            random_out = np.random.choice(excluded)\n            if current_weight - weight_lst[random_in] + weight_lst[random_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[random_in] = 0\n                temp_solution[random_out] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3539002825877099,
            0.5003053545951843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with most extreme trade-off (either max value1 or max value2)\n    objectives = np.array([sol[1] for sol in archive])\n    extreme_idx = np.argmax(np.max(objectives, axis=1))\n    base_solution = archive[extreme_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic objective weights based on current solution's trade-off\n    current_v1, current_v2 = archive[extreme_idx][1]\n    weight1 = current_v2 / (current_v1 + current_v2 + 1e-10)\n    weight2 = current_v1 / (current_v1 + current_v2 + 1e-10)\n\n    # Calculate marginal utility ratios\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate weighted marginal utilities\n        in_utils = (weight1 * value1_lst[included] + weight2 * value2_lst[included]) / (weight_lst[included] + 1e-10)\n        out_utils = (weight1 * value1_lst[excluded] + weight2 * value2_lst[excluded]) / (weight_lst[excluded] + 1e-10)\n\n        # Select worst included and best excluded items\n        worst_in = included[np.argmin(in_utils)]\n        best_out = excluded[np.argmax(out_utils)]\n\n        # Try swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight - weight_lst[worst_in] + weight_lst[best_out] <= capacity:\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            new_solution = temp_solution\n\n        # Diversification: occasionally perform random swap if no improvement found\n        if np.random.rand() < 0.2:\n            random_in = np.random.choice(included)\n            random_out = np.random.choice(excluded)\n            if current_weight - weight_lst[random_in] + weight_lst[random_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[random_in] = 0\n                temp_solution[random_out] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7722706834404173,
            3.1550544798374176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search that combines item diversification and sequential swaps based on objective ratios, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9048474930949293,
            2.606484979391098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select solution with highest combined objective values\n    combined_values = [v1 + v2 for (v1, v2) in (sol[1] for sol in archive)]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate objective ratios for diversification\n    ratio = (value1_lst + 1e-10) / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(ratio)\n\n    # Novel local search: sequential swaps with objective ratio-based prioritization and random perturbation\n    for i in range(len(sorted_indices)):\n        current_item = sorted_indices[i]\n        if base_solution[current_item] == 1:\n            # Try removing current item\n            temp_solution = new_solution.copy()\n            temp_solution[current_item] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If removal fails, try swapping with a random item\n            random_item = np.random.choice(sorted_indices)\n            if base_solution[random_item] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[current_item] = 0\n                temp_solution[random_item] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    }
]