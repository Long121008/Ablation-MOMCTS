[
    {
        "algorithm": "{The new algorithm combines a greedy selection of high-value items with a probabilistic local search that explores trade-offs between objectives by flipping items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    selected_idx = np.argmax([np.sum(ratios[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: flip items with high marginal contributions in both objectives\n    for _ in range(5):\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0:\n            # Calculate marginal contributions for included items\n            marginal1_in = value1_lst[included] / (weight_lst[included] + 1e-10)\n            marginal2_in = value2_lst[included] / (weight_lst[included] + 1e-10)\n            marginal_in = marginal1_in * marginal2_in  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to remove\n            probs_in = marginal_in / np.sum(marginal_in)\n            item_to_remove = np.random.choice(included, p=probs_in)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_remove] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                continue\n\n        if len(excluded) > 0:\n            # Calculate marginal contributions for excluded items\n            marginal1_out = value1_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal2_out = value2_lst[excluded] / (weight_lst[excluded] + 1e-10)\n            marginal_out = marginal1_out * marginal2_out  # Product to emphasize trade-offs\n\n            # Probabilistically select an item to add\n            probs_out = marginal_out / np.sum(marginal_out)\n            item_to_add = np.random.choice(excluded, p=probs_out)\n            temp_solution = new_solution.copy()\n            temp_solution[item_to_add] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.9611255785252724,
            7.535822182893753
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced trade-offs between objectives, then applies a novel local search that combines item clustering and sequential flips based on objective dominance, ensuring feasibility while maximizing both objectives through a dynamic trade-off exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    values = np.array([sol[1] for sol in archive])\n    normalized_values = (values - values.min(axis=0)) / (values.max(axis=0) - values.min(axis=0) + 1e-10)\n    distances = np.sqrt(np.sum((normalized_values - 0.5)**2, axis=1))\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster items by objective dominance\n    dominance = (value1_lst - value2_lst) / (np.abs(value1_lst) + np.abs(value2_lst) + 1e-10)\n    clusters = np.digitize(dominance, bins=[-1, 0, 1])\n\n    # Hybrid local search: sequential flips with objective-based prioritization and cluster-based swaps\n    for cluster in [1, 2, 0]:  # Priority: dominant, non-dominant, balanced\n        cluster_items = np.where(clusters == cluster)[0]\n        included = cluster_items[base_solution[cluster_items] == 1]\n        excluded = cluster_items[base_solution[cluster_items] == 0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Flip worst item in cluster and best item from other clusters\n            cluster_values = value1_lst[included] + value2_lst[included]\n            worst_in = included[np.argmin(cluster_values)]\n\n            # Select best item from other clusters\n            other_clusters = np.where(clusters != cluster)[0]\n            other_values = value1_lst[other_clusters] + value2_lst[other_clusters]\n            best_out = other_clusters[np.argmax(other_values)]\n\n            # Try swapping worst_in with best_out\n            temp_solution = new_solution.copy()\n            temp_solution[worst_in] = 0\n            temp_solution[best_out] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n            # If swap fails, try adding best_out if possible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[best_out] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[best_out] = 1\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8187267089288501,
            0.4586949646472931
        ]
    }
]