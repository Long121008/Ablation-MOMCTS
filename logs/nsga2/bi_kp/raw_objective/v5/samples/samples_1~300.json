[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining random item swaps and value-based perturbations to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based perturbations\n    n_items = len(weight_lst)\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Random item swap\n        if random.random() < 0.7:  # 70% chance for swap\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Value-based perturbation\n            # Find items to flip based on highest marginal value\n            current_weight = np.sum(new_solution * weight_lst)\n            for i in range(n_items):\n                if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to remove high-value item\n                        new_solution[i] = 0\n                elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to add high-value item\n                        new_solution[i] = 1\n\n        # Check feasibility\n        if np.sum(new_solution * weight_lst) <= capacity:\n            return new_solution\n\n        new_solution = base_solution.copy()  # Reset if infeasible\n        attempts += 1\n\n    return base_solution  # Fallback to base solution if no valid neighbor found\n\n",
        "score": [
            -18.491002254898,
            -18.26436528182859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based perturbations\n    n_items = len(weight_lst)\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Random item swap\n        if random.random() < 0.7:  # 70% chance for swap\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Value-based perturbation\n            # Find items to flip based on highest marginal value\n            current_weight = np.sum(new_solution * weight_lst)\n            for i in range(n_items):\n                if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to remove high-value item\n                        new_solution[i] = 0\n                elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to add high-value item\n                        new_solution[i] = 1\n\n        # Check feasibility\n        if np.sum(new_solution * weight_lst) <= capacity:\n            return new_solution\n\n        new_solution = base_solution.copy()  # Reset if infeasible\n        attempts += 1\n\n    return base_solution  # Fallback to base solution if no valid neighbor found\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining random item swaps and value-based perturbations to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based perturbations\n    n_items = len(weight_lst)\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Random item swap\n        if random.random() < 0.7:  # 70% chance for swap\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Value-based perturbation\n            # Find items to flip based on highest marginal value\n            current_weight = np.sum(new_solution * weight_lst)\n            for i in range(n_items):\n                if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to remove high-value item\n                        new_solution[i] = 0\n                elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to add high-value item\n                        new_solution[i] = 1\n\n        # Check feasibility\n        if np.sum(new_solution * weight_lst) <= capacity:\n            return new_solution\n\n        new_solution = base_solution.copy()  # Reset if infeasible\n        attempts += 1\n\n    return base_solution  # Fallback to base solution if no valid neighbor found\n\n",
        "score": [
            -18.491002254898,
            -18.26436528182859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based perturbations\n    n_items = len(weight_lst)\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Random item swap\n        if random.random() < 0.7:  # 70% chance for swap\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Value-based perturbation\n            # Find items to flip based on highest marginal value\n            current_weight = np.sum(new_solution * weight_lst)\n            for i in range(n_items):\n                if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to remove high-value item\n                        new_solution[i] = 0\n                elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to add high-value item\n                        new_solution[i] = 1\n\n        # Check feasibility\n        if np.sum(new_solution * weight_lst) <= capacity:\n            return new_solution\n\n        new_solution = base_solution.copy()  # Reset if infeasible\n        attempts += 1\n\n    return base_solution  # Fallback to base solution if no valid neighbor found\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining random item swaps and value-based perturbations to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based perturbations\n    n_items = len(weight_lst)\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Random item swap\n        if random.random() < 0.7:  # 70% chance for swap\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Value-based perturbation\n            # Find items to flip based on highest marginal value\n            current_weight = np.sum(new_solution * weight_lst)\n            for i in range(n_items):\n                if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to remove high-value item\n                        new_solution[i] = 0\n                elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to add high-value item\n                        new_solution[i] = 1\n\n        # Check feasibility\n        if np.sum(new_solution * weight_lst) <= capacity:\n            return new_solution\n\n        new_solution = base_solution.copy()  # Reset if infeasible\n        attempts += 1\n\n    return base_solution  # Fallback to base solution if no valid neighbor found\n\n",
        "score": [
            -18.491002254898,
            -18.26436528182859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the most promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and value-based perturbations\n    n_items = len(weight_lst)\n    max_attempts = 100\n    attempts = 0\n\n    while attempts < max_attempts:\n        # Random item swap\n        if random.random() < 0.7:  # 70% chance for swap\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Value-based perturbation\n            # Find items to flip based on highest marginal value\n            current_weight = np.sum(new_solution * weight_lst)\n            for i in range(n_items):\n                if new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to remove high-value item\n                        new_solution[i] = 0\n                elif new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n                    if random.random() < 0.3:  # 30% chance to add high-value item\n                        new_solution[i] = 1\n\n        # Check feasibility\n        if np.sum(new_solution * weight_lst) <= capacity:\n            return new_solution\n\n        new_solution = base_solution.copy()  # Reset if infeasible\n        attempts += 1\n\n    return base_solution  # Fallback to base solution if no valid neighbor found\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Flip a subset of items based on trade-off between value1 and value2\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Probabilistically remove items with low marginal trade-off\n            if np.random.rand() < 0.3 and (value1_lst[i] / weight_lst[i]) < np.median(value1_lst / weight_lst):\n                new_solution[i] = 0\n        else:\n            # Probabilistically add items with high marginal trade-off\n            if np.random.rand() < 0.5 and (value1_lst[i] / weight_lst[i]) > np.median(value1_lst / weight_lst):\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing the heaviest item if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) > 0:\n            heaviest_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -18.55163409321681,
            -15.932380667449568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Flip a subset of items based on trade-off between value1 and value2\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Probabilistically remove items with low marginal trade-off\n            if np.random.rand() < 0.3 and (value1_lst[i] / weight_lst[i]) < np.median(value1_lst / weight_lst):\n                new_solution[i] = 0\n        else:\n            # Probabilistically add items with high marginal trade-off\n            if np.random.rand() < 0.5 and (value1_lst[i] / weight_lst[i]) > np.median(value1_lst / weight_lst):\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing the heaviest item if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) > 0:\n            heaviest_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Flip a subset of items based on trade-off between value1 and value2\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Probabilistically remove items with low marginal trade-off\n            if np.random.rand() < 0.3 and (value1_lst[i] / weight_lst[i]) < np.median(value1_lst / weight_lst):\n                new_solution[i] = 0\n        else:\n            # Probabilistically add items with high marginal trade-off\n            if np.random.rand() < 0.5 and (value1_lst[i] / weight_lst[i]) > np.median(value1_lst / weight_lst):\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing the heaviest item if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) > 0:\n            heaviest_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -18.55163409321681,
            -15.932380667449568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Flip a subset of items based on trade-off between value1 and value2\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Probabilistically remove items with low marginal trade-off\n            if np.random.rand() < 0.3 and (value1_lst[i] / weight_lst[i]) < np.median(value1_lst / weight_lst):\n                new_solution[i] = 0\n        else:\n            # Probabilistically add items with high marginal trade-off\n            if np.random.rand() < 0.5 and (value1_lst[i] / weight_lst[i]) > np.median(value1_lst / weight_lst):\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility by removing the heaviest item if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) > 0:\n            heaviest_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search operator that combines item swapping with adaptive perturbation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using a hybrid selection criterion\n    def selection_criterion(solution_obj):\n        # Combine crowding distance and objective diversity\n        crowding = np.std([obj[0] for _, obj in archive]) + np.std([obj[1] for _, obj in archive])\n        diversity = abs(solution_obj[0] - np.mean([obj[0] for _, obj in archive])) + \\\n                    abs(solution_obj[1] - np.mean([obj[1] for _, obj in archive]))\n        return crowding + diversity\n\n    selected_idx = np.argmax([selection_criterion(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Adaptive perturbation: flip a random subset of items\n    perturbation_size = max(1, int(np.sqrt(n_items)) // 2)\n    candidates = np.where(base_solution == 0)[0]\n    if len(candidates) > 0:\n        to_flip = np.random.choice(candidates, size=min(perturbation_size, len(candidates)), replace=False)\n        new_solution[to_flip] = 1\n\n    # Check feasibility and repair if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        items_in_knapsack = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_knapsack)\n        for item in items_in_knapsack:\n            if excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Additional local improvement: swap items if beneficial\n    for _ in range(2):  # Limit the number of swaps\n        in_knapsack = np.where(new_solution == 1)[0]\n        out_knapsack = np.where(new_solution == 0)[0]\n\n        if len(in_knapsack) == 0 or len(out_knapsack) == 0:\n            break\n\n        # Evaluate potential swaps\n        best_swap = None\n        best_improvement = 0\n\n        # Randomly sample a subset of swaps to evaluate\n        sample_size = min(5, len(in_knapsack) * len(out_knapsack))\n        for _ in range(sample_size):\n            i = np.random.choice(in_knapsack)\n            j = np.random.choice(out_knapsack)\n\n            # Check if adding j and removing i keeps solution feasible\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]\n            if new_weight > capacity:\n                continue\n\n            # Evaluate improvement in both objectives\n            improvement = (value1_lst[j] - value1_lst[i]) + (value2_lst[j] - value2_lst[i])\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -15.45499145591163,
            -15.140646539232744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using a hybrid selection criterion\n    def selection_criterion(solution_obj):\n        # Combine crowding distance and objective diversity\n        crowding = np.std([obj[0] for _, obj in archive]) + np.std([obj[1] for _, obj in archive])\n        diversity = abs(solution_obj[0] - np.mean([obj[0] for _, obj in archive])) + \\\n                    abs(solution_obj[1] - np.mean([obj[1] for _, obj in archive]))\n        return crowding + diversity\n\n    selected_idx = np.argmax([selection_criterion(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Adaptive perturbation: flip a random subset of items\n    perturbation_size = max(1, int(np.sqrt(n_items)) // 2)\n    candidates = np.where(base_solution == 0)[0]\n    if len(candidates) > 0:\n        to_flip = np.random.choice(candidates, size=min(perturbation_size, len(candidates)), replace=False)\n        new_solution[to_flip] = 1\n\n    # Check feasibility and repair if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        items_in_knapsack = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_knapsack)\n        for item in items_in_knapsack:\n            if excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Additional local improvement: swap items if beneficial\n    for _ in range(2):  # Limit the number of swaps\n        in_knapsack = np.where(new_solution == 1)[0]\n        out_knapsack = np.where(new_solution == 0)[0]\n\n        if len(in_knapsack) == 0 or len(out_knapsack) == 0:\n            break\n\n        # Evaluate potential swaps\n        best_swap = None\n        best_improvement = 0\n\n        # Randomly sample a subset of swaps to evaluate\n        sample_size = min(5, len(in_knapsack) * len(out_knapsack))\n        for _ in range(sample_size):\n            i = np.random.choice(in_knapsack)\n            j = np.random.choice(out_knapsack)\n\n            # Check if adding j and removing i keeps solution feasible\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]\n            if new_weight > capacity:\n                continue\n\n            # Evaluate improvement in both objectives\n            improvement = (value1_lst[j] - value1_lst[i]) + (value2_lst[j] - value2_lst[i])\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    }
]