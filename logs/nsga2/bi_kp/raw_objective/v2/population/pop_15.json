[
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, using a convex combination of objectives with dynamic weights adjusted based on the solution's position in the Pareto front, and additionally incorporates a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (dynamic weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on solution's position in the Pareto front\n    weights = np.array([0.5, 0.5])  # Equal initial weights\n    if len(archive) > 1:\n        # Adjust weights based on the solution's rank in the Pareto front\n        ranks = np.argsort(np.argsort(-objectives, axis=0), axis=0)\n        rank1 = ranks[:, 0]\n        rank2 = ranks[:, 1]\n        avg_rank = (rank1 + rank2) / 2\n        selected_rank = avg_rank[np.argmax(avg_rank)]  # Highest rank (worst solution)\n        weights = np.array([0.7, 0.3]) if selected_rank < len(archive) / 2 else np.array([0.3, 0.7])\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    # Probabilistic acceptance to balance exploration and exploitation\n    if np.random.random() > 0.7:\n        new_solution = random_solution\n\n    return new_solution\n\n",
        "score": [
            -16.71206016177949,
            -19.523424878559794
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.97654177576104,
            -16.588317833250546
        ]
    }
]