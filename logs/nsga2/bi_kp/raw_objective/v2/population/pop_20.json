[
    {
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives and weight efficiency)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([sol for sol, _ in archive])\n    total_weights = np.sum(weight_lst * weights, axis=1)\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    normalized_weights = (total_weights - np.min(total_weights)) / (np.max(total_weights) - np.min(total_weights) + 1e-10)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] - 0.1 * normalized_weights\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance and adaptive flip size\n    new_solution = base_solution.copy()\n    flip_size = max(1, min(5, len(base_solution) // 3))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve or one improves significantly\n            prob_accept = 0.5 + 0.3 * (improvement1 > 0 and improvement2 > 0) + 0.2 * (improvement1 > 0 or improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -20.08151520130686,
            -17.043417944139616
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process, while also incorporating a dynamic neighborhood exploration strategy that adapts the size and type of flips based on the solution's position in the Pareto front and the diversity of the archive, and further refines the search by considering the correlation between items and their impact on both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on normalized objectives and weight\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on solution's position in the Pareto front\n    weights = np.array([0.6, 0.4])\n    if len(archive) > 1:\n        ranks = np.argsort(np.argsort(-objectives, axis=0), axis=0)\n        rank1 = ranks[:, 0]\n        rank2 = ranks[:, 1]\n        avg_rank = (rank1 + rank2) / 2\n        selected_rank = avg_rank[np.argmax(avg_rank)]\n        weights = np.array([0.9, 0.1]) if selected_rank < len(archive) / 2 else np.array([0.1, 0.9])\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance and correlation-aware flips\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(8, len(base_solution) // 4))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    # Calculate item correlations based on objectives\n    item_corr = np.corrcoef([value1_lst, value2_lst])[0, 1]\n    corr_threshold = 0.3\n\n    for idx in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Higher acceptance probability if both objectives improve or if items are correlated\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0 and improvement2 > 0) + 0.2 * (abs(item_corr) > corr_threshold)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    # Adaptive exploration based on archive diversity and correlation\n    if np.random.random() > (0.7 - 0.1 * abs(item_corr)):\n        new_solution = random_solution\n\n    return new_solution\n\n",
        "score": [
            -16.598609759422445,
            -19.63447168108354
        ]
    }
]