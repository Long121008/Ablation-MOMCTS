[
    {
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives and weight efficiency)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([sol for sol, _ in archive])\n    total_weights = np.sum(weight_lst * weights, axis=1)\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    normalized_weights = (total_weights - np.min(total_weights)) / (np.max(total_weights) - np.min(total_weights) + 1e-10)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] - 0.1 * normalized_weights\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance and adaptive flip size\n    new_solution = base_solution.copy()\n    flip_size = max(1, min(5, len(base_solution) // 3))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve or one improves significantly\n            prob_accept = 0.5 + 0.3 * (improvement1 > 0 and improvement2 > 0) + 0.2 * (improvement1 > 0 or improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -20.08151520130686,
            -17.043417944139616
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process, and also considers the correlation between objectives to guide the flip decisions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on normalized objectives and weight efficiency\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([sol for sol, _ in archive])\n    total_weights = np.sum(weight_lst * weights, axis=1)\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    normalized_weights = (total_weights - np.min(total_weights)) / (np.max(total_weights) - np.min(total_weights) + 1e-10)\n\n    # Calculate correlation between objectives\n    obj_corr = np.corrcoef(objectives[:, 0], objectives[:, 1])[0, 1]\n    obj_weight = 0.5 + 0.4 * obj_corr  # Higher correlation means more balanced weighting\n\n    scores = obj_weight * normalized_obj[:, 0] + (1 - obj_weight) * normalized_obj[:, 1] - 0.2 * normalized_weights\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance and adaptive flip size\n    new_solution = base_solution.copy()\n    flip_size = max(1, min(5, len(base_solution) // 3))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve or one improves significantly\n            # Also consider objective correlation in acceptance probability\n            prob_accept = 0.5 + 0.3 * (improvement1 > 0 and improvement2 > 0) + 0.2 * (improvement1 > 0 or improvement2 > 0)\n            prob_accept = prob_accept * (1 + 0.1 * obj_corr)  # Higher correlation increases acceptance probability\n\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -16.92543144407321,
            -19.795002288710275
        ]
    }
]