[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.008597350008337,
            -18.465413914024243
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently swaps subsets of items between the selected solution and a randomly generated solution to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: swap subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    swap_size = random.randint(1, min(5, len(base_solution) // 2))\n    swap_indices = np.random.choice(len(base_solution), size=swap_size, replace=False)\n\n    for idx in swap_indices:\n        if new_solution[idx] != random_solution[idx]:\n            # Try swapping the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = random_solution[idx]\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -18.62990378708125,
            -18.285629575533203
        ]
    }
]