[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently swaps subsets of items between the selected solution and a randomly generated solution to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: swap subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    swap_size = random.randint(1, min(5, len(base_solution) // 2))\n    swap_indices = np.random.choice(len(base_solution), size=swap_size, replace=False)\n\n    for idx in swap_indices:\n        if new_solution[idx] != random_solution[idx]:\n            # Try swapping the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = random_solution[idx]\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -18.62990378708125,
            -18.285629575533203
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its combined objective scores, then applies a novel neighborhood exploration strategy that combines item swapping and marginal contribution analysis to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (np.sum(weight_lst[sol == 1]) + 1e-8) for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_value1 = (value1_lst - np.sum(value1_lst[base_solution == 1]) / current_weight * weight_lst) if current_weight > 0 else value1_lst\n    marginal_value2 = (value2_lst - np.sum(value2_lst[base_solution == 1]) / current_weight * weight_lst) if current_weight > 0 else value2_lst\n\n    # Combine marginal contributions with diversity factor\n    diversity_factor = np.random.uniform(0.5, 1.5, len(weight_lst))\n    combined_marginal = (marginal_value1 + marginal_value2) * diversity_factor\n\n    # Select top items to consider for swapping\n    candidate_indices = np.argsort(combined_marginal)[-15:]  # Consider top 15 items\n\n    # Perform multiple swaps between included and excluded items\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select swap candidates from both sets\n        swap_in = np.random.choice(included, size=min(3, len(included)), replace=False)\n        swap_out = np.random.choice(excluded, size=min(3, len(excluded)), replace=False)\n\n        # Perform the swaps\n        new_solution[swap_in] = 0\n        new_solution[swap_out] = 1\n\n    # Ensure feasibility by removing excess weight if necessary\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_indices = np.where(new_solution == 1)[0]\n        if len(excess_indices) > 0:\n            remove_idx = np.random.choice(excess_indices)\n            new_solution[remove_idx] = 0\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -17.59937972469123,
            -17.318715801531418
        ]
    }
]