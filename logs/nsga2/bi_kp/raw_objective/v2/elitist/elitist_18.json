[
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0 and improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -20.02573095485726,
            -16.710410721885825
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process, while also incorporating a dynamic neighborhood exploration strategy that adapts the size and type of flips based on the solution's position in the Pareto front and the diversity of the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on solution's position in the Pareto front\n    weights = np.array([0.5, 0.5])\n    if len(archive) > 1:\n        ranks = np.argsort(np.argsort(-objectives, axis=0), axis=0)\n        rank1 = ranks[:, 0]\n        rank2 = ranks[:, 1]\n        avg_rank = (rank1 + rank2) / 2\n        selected_rank = avg_rank[np.argmax(avg_rank)]\n        weights = np.array([0.8, 0.2]) if selected_rank < len(archive) / 3 else np.array([0.2, 0.8])\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Dynamic neighborhood exploration\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(10, len(base_solution) // 3))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Dynamic acceptance probability\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0) * (improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    # Adaptive exploration based on archive diversity\n    if np.random.random() > 0.6:\n        new_solution = random_solution\n\n    return new_solution\n\n",
        "score": [
            -16.724077453679953,
            -19.61173212478817
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0 and improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -20.02573095485726,
            -16.710410721885825
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process, and further incorporates a dynamic neighborhood structure that adapts its size and shape based on the solution's position in the Pareto front to explore different regions of the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on solution's position in the Pareto front\n    weights = np.array([0.5, 0.5])\n    if len(archive) > 1:\n        # Adjust weights based on the solution's rank in the Pareto front\n        ranks = np.argsort(np.argsort(-objectives, axis=0), axis=0)\n        rank1 = ranks[:, 0]\n        rank2 = ranks[:, 1]\n        avg_rank = (rank1 + rank2) / 2\n        selected_rank = avg_rank[np.argmax(avg_rank)]\n        weights = np.array([0.6, 0.4]) if selected_rank < len(archive) / 2 else np.array([0.4, 0.6])\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Dynamic neighborhood structure\n    new_solution = base_solution.copy()\n    neighborhood_size = max(1, int(len(base_solution) * 0.1 * (1 + np.random.random())))\n    flip_indices = np.random.choice(len(base_solution), size=neighborhood_size, replace=False)\n\n    for idx in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0 and improvement2 > 0)\n            if np.random.random() < prob_accept:\n                new_solution = temp_solution\n\n    # Additional probabilistic swapping of items\n    if np.random.random() > 0.6:\n        swap_indices = np.random.choice(len(base_solution), size=2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[swap_indices[0]], temp_solution[swap_indices[1]] = temp_solution[swap_indices[1]], temp_solution[swap_indices[0]]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -17.623516190058986,
            -19.47780235302511
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.6, 0.4])  # Custom weights for objectives (value1 slightly more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance and dynamic flip size\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(7, len(base_solution) // 3))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives and diversity\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve or if the solution is diverse\n            prob_accept = 0.4 + 0.6 * (improvement1 > 0 and improvement2 > 0) + 0.2 * (np.sum(temp_solution != base_solution) > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.752498912879858,
            -17.287762913239415
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process, while also incorporating a dynamic neighborhood exploration strategy that adapts the size and type of flips based on the solution's position in the Pareto front and the diversity of the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on solution's position in the Pareto front\n    weights = np.array([0.5, 0.5])\n    if len(archive) > 1:\n        ranks = np.argsort(np.argsort(-objectives, axis=0), axis=0)\n        rank1 = ranks[:, 0]\n        rank2 = ranks[:, 1]\n        avg_rank = (rank1 + rank2) / 2\n        selected_rank = avg_rank[np.argmax(avg_rank)]\n        weights = np.array([0.8, 0.2]) if selected_rank < len(archive) / 3 else np.array([0.2, 0.8])\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Dynamic neighborhood exploration\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(10, len(base_solution) // 3))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Dynamic acceptance probability\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0) * (improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    # Adaptive exploration based on archive diversity\n    if np.random.random() > 0.6:\n        new_solution = random_solution\n\n    return new_solution\n\n",
        "score": [
            -16.724077453679953,
            -19.61173212478817
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0 and improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -20.02573095485726,
            -16.710410721885825
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive using a score function that emphasizes solutions with high value1 and moderate value2, then applies a local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, using a scoring function that dynamically adjusts weights based on the archive's diversity and the selected solution's position in the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of objectives with dynamic weights)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights: prioritize value1 more but adjust based on archive diversity\n    archive_diversity = np.std(normalized_obj, axis=0)\n    weights = np.array([0.6, 0.4]) * (1 + archive_diversity)\n    weights = weights / np.sum(weights)  # Normalize weights\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.763340119347696,
            -17.233250848882307
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, using a convex combination of objectives with dynamic weights adjusted based on the solution's position in the Pareto front, and additionally incorporates a probabilistic acceptance criterion to balance exploration and exploitation, and also uses a greedy selection of items based on the marginal improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (dynamic weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on solution's position in the Pareto front\n    weights = np.array([0.5, 0.5])\n    if len(archive) > 1:\n        # Adjust weights based on the solution's rank in the Pareto front\n        ranks = np.argsort(np.argsort(-objectives, axis=0), axis=0)\n        rank1 = ranks[:, 0]\n        rank2 = ranks[:, 1]\n        avg_rank = (rank1 + rank2) / 2\n        selected_rank = avg_rank[np.argmax(avg_rank)]\n        weights = np.array([0.6, 0.4]) if selected_rank < len(archive) / 3 else np.array([0.4, 0.6])\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    # Greedy selection of items based on marginal improvement\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate marginal improvement for each item\n        marginal_value1 = value1_lst * (1 - new_solution)\n        marginal_value2 = value2_lst * (1 - new_solution)\n        marginal_weight = weight_lst * (1 - new_solution)\n\n        # Weighted marginal improvement\n        weighted_marginal = (marginal_value1 * weights[0] + marginal_value2 * weights[1]) / (marginal_weight + 1e-10)\n        candidates = np.where(marginal_weight <= remaining_capacity)[0]\n        if len(candidates) > 0:\n            best_candidate = candidates[np.argmax(weighted_marginal[candidates])]\n            new_solution[best_candidate] = 1\n\n    # Probabilistic acceptance to balance exploration and exploitation\n    if np.random.random() > 0.6:\n        new_solution = random_solution\n\n    return new_solution\n\n",
        "score": [
            -18.171808380129715,
            -19.33597729200892
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weights for objectives\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve\n            prob_accept = 0.6 + 0.4 * (improvement1 > 0 and improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.041375826456154,
            -18.442331047722643
        ]
    },
    {
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and additionally employs a probabilistic acceptance criterion to balance exploration and exploitation during the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with probabilistic acceptance\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            # Accept the flip with probability based on improvement in both objectives\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            improvement1 = new_value1 - current_value1\n            improvement2 = new_value2 - current_value2\n\n            # Probability of acceptance is higher if both objectives improve\n            prob_accept = 0.5 + 0.5 * (improvement1 > 0 and improvement2 > 0)\n            if random.random() < prob_accept:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -20.02573095485726,
            -16.710410721885825
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, using a convex combination of objectives with dynamic weights adjusted based on the solution's position in the Pareto front, and additionally incorporates a probabilistic selection mechanism that favors items with high marginal value-to-weight ratios.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Calculate marginal value-to-weight ratios for probabilistic selection\n    marginal_ratio1 = value1_lst / weight_lst\n    marginal_ratio2 = value2_lst / weight_lst\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n\n    # Select a promising solution (dynamic weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on solution's position in the Pareto front\n    weights = np.array([0.5, 0.5])  # Equal initial weights\n    if len(archive) > 1:\n        ranks = np.argsort(np.argsort(-objectives, axis=0), axis=0)\n        rank1 = ranks[:, 0]\n        rank2 = ranks[:, 1]\n        avg_rank = (rank1 + rank2) / 2\n        selected_rank = avg_rank[np.argmax(avg_rank)]  # Highest rank (worst solution)\n        weights = np.array([0.7, 0.3]) if selected_rank < len(archive) / 2 else np.array([0.3, 0.7])\n\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison with probabilistic item selection\n    random_solution = np.zeros_like(base_solution)\n    current_weight = 0.0\n\n    for i in np.random.permutation(len(base_solution)):\n        if current_weight + weight_lst[i] <= capacity:\n            prob = combined_ratio[i] / combined_ratio.sum()\n            if np.random.rand() < prob:\n                random_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -17.3008212413693,
            -19.5226644450536
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a hybrid local search operator that combines features from the selected solution with a random solution by flipping subsets of items while ensuring feasibility, but uses a dynamic scoring function that weights each objective based on their relative importance determined by the archive's diversity and current solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weights based on archive diversity and current solution quality\n    diversity = np.std(normalized_obj, axis=0)\n    quality_weights = np.array([0.6, 0.4])  # Base weights (value1 more important)\n    dynamic_weights = quality_weights * (1 + diversity * 0.5)  # Adjust weights based on diversity\n    dynamic_weights /= dynamic_weights.sum()  # Normalize\n\n    weighted_scores = normalized_obj * dynamic_weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.892894231499092,
            -16.911098314313808
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weights for objectives\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    # Additional perturbation: swap a random pair of items\n    if len(base_solution) >= 2:\n        swap_indices = np.random.choice(len(base_solution), size=2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[swap_indices[0]], temp_solution[swap_indices[1]] = temp_solution[swap_indices[1]], temp_solution[swap_indices[0]]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -18.811554875779574,
            -18.615435125918033
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a Pareto-optimal reference solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weights for objectives\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a Pareto-optimal reference solution\n    pareto_solution = np.zeros_like(base_solution)\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            pareto_solution[i] = 1\n            current_weight = np.sum(weight_lst * pareto_solution)\n            if current_weight > capacity:\n                pareto_solution[i] = 0\n\n    # Hybrid local search: flip subsets of items between base and Pareto solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(3, len(base_solution) // 3))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -18.86681695420729,
            -18.545464687570366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.869643466034745,
            -16.99273081602175
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a hybrid local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and incorporates a dynamic weight adjustment mechanism based on the current archive's spread.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives with dynamic weights)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Dynamic weight adjustment based on archive diversity\n    obj_spread = max_obj - min_obj\n    weights = obj_spread / (obj_spread.sum() + 1e-10)  # Normalized spread as weights\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.21086394379614,
            -18.241991624139125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity, and incorporates a dynamic temperature-based acceptance criterion to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search with dynamic temperature-based acceptance\n    new_solution = base_solution.copy()\n    temperature = 0.5  # Initial temperature\n    cooling_rate = 0.95  # Temperature cooling rate\n\n    for _ in range(10):  # Number of iterations\n        # Select a subset of items to flip\n        flip_size = random.randint(1, min(5, len(base_solution) // 2))\n        flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n        temp_solution = new_solution.copy()\n        for idx in flip_indices:\n            temp_solution[idx] = 1 - temp_solution[idx]\n\n        temp_weight = np.sum(weight_lst * temp_solution)\n        if temp_weight <= capacity:\n            # Calculate objective improvements\n            current_value1 = np.sum(value1_lst * new_solution)\n            current_value2 = np.sum(value2_lst * new_solution)\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            # Dynamic acceptance criterion\n            delta1 = new_value1 - current_value1\n            delta2 = new_value2 - current_value2\n            if (delta1 > 0 and delta2 > 0) or random.random() < temperature:\n                new_solution = temp_solution\n\n        temperature *= cooling_rate  # Cool the temperature\n\n    return new_solution\n\n",
        "score": [
            -19.702856976674553,
            -17.397665149072232
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective differently based on their normalized range.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of objectives based on normalized range)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    ranges = max_obj - min_obj + 1e-10\n    weights = 1 / ranges  # Higher weight for objectives with smaller range\n    normalized_scores = (objectives - min_obj) / ranges\n    scores = normalized_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -18.77944983253723,
            -18.67797637569722
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high normalized objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective based on their relative importance determined by the archive's diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.7, 0.3])  # Custom weights for objectives (value1 more important)\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.896690018254716,
            -16.758755550132467
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective differently based on their normalized range.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = 1 / (max_obj - min_obj + 1e-10)  # Higher weight for objectives with larger range\n    weighted_scores = normalized_obj * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -18.224533376129855,
            -18.697799801117654
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.008597350008337,
            -18.465413914024243
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility, but uses a different scoring function that weights each objective differently based on their dominance relationships.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (weighted sum of objectives based on dominance)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = objectives.max(axis=0)\n    weights = max_obj / (max_obj.sum() + 1e-10)  # Weight based on maximum objective values\n    weighted_scores = objectives * weights\n    scores = weighted_scores.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.151499419511136,
            -18.347732104756812
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.008597350008337,
            -18.465413914024243
        ]
    },
    {
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    # Additional improvement: consider swapping between base and random solutions\n    for idx in flip_indices:\n        if base_solution[idx] != random_solution[idx]:\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = random_solution[idx]\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -18.9687521932102,
            -18.494254779654117
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel local search operator that intelligently combines features from the selected solution with a randomly generated solution by flipping subsets of items while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution for comparison\n    random_solution = np.random.randint(0, 2, size=len(base_solution))\n    random_weight = np.sum(weight_lst * random_solution)\n    while random_weight > capacity:\n        random_solution = np.random.randint(0, 2, size=len(base_solution))\n        random_weight = np.sum(weight_lst * random_solution)\n\n    # Hybrid local search: flip subsets of items between base and random solution\n    new_solution = base_solution.copy()\n    flip_size = random.randint(1, min(5, len(base_solution) // 2))\n    flip_indices = np.random.choice(len(base_solution), size=flip_size, replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the item\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -19.008597350008337,
            -18.465413914024243
        ]
    }
]