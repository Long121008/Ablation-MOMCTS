[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a novel hybrid local search that combines item swaps, probabilistic flips, and a value-weighted randomization step to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate potential improvement score (weighted sum of both objectives)\n        scores = [obj[0] * 0.7 + obj[1] * 0.3 for (sol, obj) in archive]\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform item swaps with value-weighted probability\n    for _ in range(min(5, n_items // 3)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select items with probability proportional to their combined value\n            total_value = np.sum(value1_lst[included]) + np.sum(value2_lst[included])\n            if total_value > 0:\n                probs = (value1_lst[included] + value2_lst[included]) / total_value\n                i = np.random.choice(included, p=probs)\n            else:\n                i = random.choice(included)\n\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform probabilistic flips with value-weighted consideration\n    for i in range(n_items):\n        if random.random() < 0.4:  # 40% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item with probability inversely proportional to value\n                removal_prob = 0.1 / (1 + (value1_lst[i] + value2_lst[i]) * 0.01)\n                if random.random() < removal_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item with probability proportional to value and capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    combined_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    capacity_factor = (capacity - current_weight) / capacity\n                    add_prob = min(1.0, combined_ratio * 0.05 * capacity_factor)\n                    if random.random() < add_prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 3: Randomize a small subset of items to escape local optima\n    if random.random() < 0.2:  # 20% chance to perform randomization\n        k = min(3, n_items // 4)\n        indices = random.sample(range(n_items), k)\n        for i in indices:\n            if random.random() < 0.5 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -19.3515028066947,
            -16.66653643625274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a novel hybrid local search that combines item swaps, probabilistic flips, and a value-weighted randomization step to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate potential improvement score (weighted sum of both objectives)\n        scores = [obj[0] * 0.7 + obj[1] * 0.3 for (sol, obj) in archive]\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform item swaps with value-weighted probability\n    for _ in range(min(5, n_items // 3)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select items with probability proportional to their combined value\n            total_value = np.sum(value1_lst[included]) + np.sum(value2_lst[included])\n            if total_value > 0:\n                probs = (value1_lst[included] + value2_lst[included]) / total_value\n                i = np.random.choice(included, p=probs)\n            else:\n                i = random.choice(included)\n\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform probabilistic flips with value-weighted consideration\n    for i in range(n_items):\n        if random.random() < 0.4:  # 40% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item with probability inversely proportional to value\n                removal_prob = 0.1 / (1 + (value1_lst[i] + value2_lst[i]) * 0.01)\n                if random.random() < removal_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item with probability proportional to value and capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    combined_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    capacity_factor = (capacity - current_weight) / capacity\n                    add_prob = min(1.0, combined_ratio * 0.05 * capacity_factor)\n                    if random.random() < add_prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 3: Randomize a small subset of items to escape local optima\n    if random.random() < 0.2:  # 20% chance to perform randomization\n        k = min(3, n_items // 4)\n        indices = random.sample(range(n_items), k)\n        for i in indices:\n            if random.random() < 0.5 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -19.3515028066947,
            -16.66653643625274
        ]
    }
]