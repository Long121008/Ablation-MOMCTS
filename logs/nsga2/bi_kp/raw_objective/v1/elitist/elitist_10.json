[
    {
        "algorithm": "{This algorithm selects a solution from the archive prioritizing those with high value2-to-value1 ratios, then applies a hybrid local search that intelligently flips up to 3 items while ensuring feasibility, or adds a random item if no valid flips exist.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 2) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(2, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(2, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -20.0493911038185,
            -16.054775600761996
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive prioritizing those with high value2-to-value1 ratios, then applies a hybrid local search that intelligently flips up to 3 items while ensuring feasibility, or adds a random item if no valid flips exist.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 2) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(2, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(2, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -20.0493911038185,
            -16.054775600761996
        ]
    },
    {
        "algorithm": "{A new algorithm that selects the solution with the highest combined score of (0.7 * value2 / (value1 + 1e-10) + 0.3 * value1) and applies a hybrid local search with up to 4 random flips, ensuring feasibility, and tries adding random items if no flips are valid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    weighted_values = [0.7 * (v2 / (v1 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v2 / (v1 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(4, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.98038064510674,
            -16.555277694122072
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined metric of value1 and value2 (0.5*value1 + 0.5*value2), then applies a novel local search that intelligently flips items with high value-to-weight ratios while maintaining feasibility, or performs a targeted exchange of items if no valid flips exist.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined value1 and value2 (0.5*value1 + 0.5*value2)\n    combined_values = [0.5 * v1 + 0.5 * v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.5 * v1 + 0.5 * v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and value-to-weight ratios\n    current_weight = np.sum(weight_lst * base_solution)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-10)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-10)\n\n    # Apply novel local search strategy:\n    # 1. Flip items with high value-to-weight ratios that can be added without exceeding capacity\n    # 2. If no additions, try exchanging items to improve both objectives\n    n_items = len(weight_lst)\n    improved = False\n\n    # Try adding items with high value-to-weight ratios\n    for i in range(n_items):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            if (value_to_weight1[i] > 0.7 * np.mean(value_to_weight1)) or (value_to_weight2[i] > 0.7 * np.mean(value_to_weight2)):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                improved = True\n\n    # If no additions, try exchanging items\n    if not improved and n_items > 1:\n        # Select two items to exchange\n        for _ in range(min(3, n_items)):\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                weight_change = weight_lst[j] - weight_lst[i]\n                if current_weight + weight_change <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    improved = True\n                    break\n\n    # If no improvements, make a random valid flip\n    if not improved:\n        for _ in range(min(2, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                break\n\n    return new_solution\n\n",
        "score": [
            -18.985568947389492,
            -18.396825058921888
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that selects a solution from the archive based on a dynamic combination of objective values, then applies a randomized multi-item flip with feasibility checks and a secondary diversification step if no immediate improvement is found.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest dynamic objective combination (0.7*value2 + 0.3*value1)\n    dynamic_scores = [0.7 * v2 + 0.3 * v1 for _, (v1, v2) in archive]\n    max_score = max(dynamic_scores)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v2 + 0.3 * v1 == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Apply randomized multi-item flip with feasibility checks\n    if n_items > 0:\n        num_flips = random.randint(2, min(4, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n        else:\n            # If flip is infeasible, try to make it feasible by removing items\n            excess = (current_weight + total_change) - capacity\n            if excess > 0:\n                # Remove items with highest weight until feasible\n                temp_solution = new_solution.copy()\n                sorted_indices = np.argsort(weight_lst[temp_solution == 1])[::-1]\n                for i in sorted_indices:\n                    if weight_lst[i] <= excess:\n                        temp_solution[i] = 0\n                        excess -= weight_lst[i]\n                        if excess <= 0:\n                            break\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n\n    # If no valid flips, try adding a subset of items\n    if np.array_equal(new_solution, base_solution):\n        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        if remaining_capacity > 0:\n            # Select up to 3 items with highest value2/weight ratio\n            ratio = value2_lst / (weight_lst + 1e-10)\n            candidate_items = np.argsort(ratio)[::-1]\n            for i in candidate_items:\n                if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n                    if remaining_capacity <= 0 or len([x for x in new_solution if x == 1]) >= 3:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -17.653109336674245,
            -19.319807238807066
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{A novel bi-objective knapsack solver that selects solutions based on a weighted trade-off of normalized objective values, then applies a hybrid local search with adaptive flipping of 2-4 items while ensuring feasibility through dynamic weight adjustment and fallback to single-item additions when necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and compute score\n    max_v1 = max(v1 for _, (v1, _) in archive) if archive else 1.0\n    max_v2 = max(v2 for _, (_, v2) in archive) if archive else 1.0\n    scores = [(0.7 * (v1 / max_v1) + 0.3 * (v2 / max_v2)) for _, (v1, v2) in archive]\n\n    # Select top 3 candidates\n    sorted_indices = sorted(range(len(scores)), key=lambda i: -scores[i])\n    candidates = [archive[i][0] for i in sorted_indices[:min(3, len(archive))]]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search\n    num_flips = random.randint(2, min(4, n_items))\n    flip_indices = random.sample(range(n_items), num_flips)\n    total_change = 0\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            total_change -= weight_lst[i]\n        else:\n            total_change += weight_lst[i]\n\n    if current_weight + total_change <= capacity:\n        for i in flip_indices:\n            new_solution[i] = 1 - new_solution[i]\n    else:\n        # Try to adjust by removing one item\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    break\n\n    # Fallback to single item addition if no improvement\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.747279408180987,
            -17.417097129203754
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive prioritizing those with high value2-to-value1 ratios, then applies a hybrid local search that intelligently flips up to 3 items while ensuring feasibility, or adds a random item if no valid flips exist.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 2) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(2, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(2, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -20.0493911038185,
            -16.054775600761996
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest weighted sum of values (0.7*value1 + 0.3*value2)\n    weighted_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.46868148635989,
            -17.628236078253344
        ]
    },
    {
        "algorithm": "{A new heuristic algorithm selects a solution from the archive based on a balanced score combining normalized value ratios and sparsity, then applies a hybrid local search that intelligently flips items while maintaining feasibility, potentially adding or removing items to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined score (balanced between value ratios and sparsity)\n    scores = []\n    for sol, (v1, v2) in archive:\n        sparsity = np.sum(sol) / len(sol)\n        score = 0.5 * (v2 / (v1 + 1e-10)) + 0.3 * v2 + 0.2 * (1 - sparsity)\n        scores.append(score)\n\n    max_score = max(scores)\n    candidates = [sol for (sol, _), score in zip(archive, scores) if score == max_score]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip up to 3 items if feasible, otherwise try adding/removing items\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # Try adding items if no flips were made\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    # Try removing items if still no change\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.300445424855706,
            -19.625893028806335
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest weighted sum of values (0.7*value1 + 0.3*value2)\n    weighted_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.46868148635989,
            -17.628236078253344
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value2 to value1 (0.6*value2/value1 + 0.4*value2)\n    weighted_values = [0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.6 * (v2 / (v1 + 1e-10)) + 0.4 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 3) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -16.191680935962964,
            -19.80930218904274
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest weighted sum of values (0.7*value1 + 0.3*value2)\n    weighted_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.46868148635989,
            -17.628236078253344
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score (weighted by the inverse of the current total weight), then applies a hybrid local search combining value-weighted swaps, probabilistic flips with capacity-aware selection, and a diversified randomization step to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized objective score (weighted by inverse of current weight)\n        scores = []\n        for (sol, obj) in archive:\n            current_weight = np.sum(weight_lst[sol == 1])\n            normalized_score = (obj[0] * 0.6 + obj[1] * 0.4) / (1 + current_weight * 0.001)\n            scores.append(normalized_score)\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform value-weighted swaps with capacity consideration\n    for _ in range(min(4, n_items // 2)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select items with probability proportional to their normalized value\n            total_norm_value = np.sum((value1_lst[included] + value2_lst[included]) / (1 + weight_lst[included] * 0.01))\n            if total_norm_value > 0:\n                probs = ((value1_lst[included] + value2_lst[included]) / (1 + weight_lst[included] * 0.01)) / total_norm_value\n                i = np.random.choice(included, p=probs)\n            else:\n                i = random.choice(included)\n\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform probabilistic flips with capacity-aware selection\n    for i in range(n_items):\n        if random.random() < 0.5:  # 50% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item with probability based on value-to-weight ratio\n                value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                removal_prob = 0.2 / (1 + value_ratio * 0.1)\n                if random.random() < removal_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item with probability based on normalized value\n                if current_weight + weight_lst[i] <= capacity:\n                    norm_value = (value1_lst[i] + value2_lst[i]) / (1 + weight_lst[i] * 0.01)\n                    add_prob = min(1.0, norm_value * 0.03)\n                    if random.random() < add_prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 3: Diversified randomization with adaptive intensity\n    if random.random() < 0.3:  # 30% chance to perform randomization\n        k = min(4, n_items // 3)\n        indices = random.sample(range(n_items), k)\n        for i in indices:\n            if random.random() < 0.6 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1 and random.random() < 0.4:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -19.289990973922087,
            -17.64198750765911
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest weighted sum of values (0.7*value1 + 0.3*value2)\n    weighted_values = [0.7 * v1 + 0.3 * v2 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * v1 + 0.3 * v2 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a subset of items (up to 5) to flip\n    # 2. Ensure the flip maintains feasibility\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    if n_items > 0:\n        num_flips = random.randint(1, min(5, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    # If no valid flips, try adding a single random item if possible\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(min(3, n_items)):\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -19.46868148635989,
            -17.628236078253344
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that balances both objectives more equally, then applies a hybrid local search that combines value-weighted swaps, adaptive flips, and a diversity-preserving randomization step to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized objective score (equal weighting)\n        max_obj1 = max(obj[0] for (sol, obj) in archive)\n        max_obj2 = max(obj[1] for (sol, obj) in archive)\n        scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for (sol, obj) in archive]\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Perform value-weighted swaps with adaptive selection\n    for _ in range(min(5, n_items // 2)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select items with probability proportional to their normalized combined value\n            total_value = np.sum((value1_lst[included] + value2_lst[included]) / weight_lst[included])\n            if total_value > 0:\n                probs = ((value1_lst[included] + value2_lst[included]) / weight_lst[included]) / total_value\n                i = np.random.choice(included, p=probs)\n            else:\n                i = random.choice(included)\n\n            j = random.choice(excluded)\n\n            # Check feasibility of swap\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = 0, 1\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n    # Step 2: Perform adaptive flips with value-to-weight ratio consideration\n    for i in range(n_items):\n        if random.random() < 0.5:  # 50% chance to consider flipping\n            if new_solution[i] == 1:\n                # Consider removing item with probability based on value-to-weight ratio\n                removal_prob = 0.2 / (1 + (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                if random.random() < removal_prob:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Consider adding item with probability based on value-to-weight ratio and capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    capacity_factor = (capacity - current_weight) / capacity\n                    add_prob = min(1.0, value_ratio * 0.1 * capacity_factor)\n                    if random.random() < add_prob:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 3: Diversity-preserving randomization\n    if random.random() < 0.3:  # 30% chance to perform randomization\n        k = min(4, n_items // 3)\n        indices = random.sample(range(n_items), k)\n        for i in indices:\n            if random.random() < 0.6:  # Higher probability to flip\n                if new_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                elif current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.94948604412736,
            -18.5027602829134
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Filter non-dominated solutions and select the one with the highest combined value\n    combined_values = [v1 + v2 for _, (v1, v2) in archive]\n    max_combined = max(combined_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if v1 + v2 == max_combined]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Strategy 1: Randomly swap two items (if possible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Randomly flip an item (if feasible)\n    else:\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Strategy 3: Randomly flip multiple items (if feasible)\n    if n_items > 2:\n        num_flips = random.randint(1, min(3, n_items))\n        flip_indices = random.sample(range(n_items), num_flips)\n        total_change = 0\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                total_change -= weight_lst[i]\n            else:\n                total_change += weight_lst[i]\n        if current_weight + total_change <= capacity:\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -18.890207833464906,
            -18.590566207280347
        ]
    }
]