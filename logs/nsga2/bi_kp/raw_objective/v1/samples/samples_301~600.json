[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines the selection of promising solutions based on a weighted objective ratio with a novel local search strategy that probabilistically explores item combinations by considering both value improvements and weight feasibility, while also incorporating a dynamic neighborhood exploration mechanism to balance exploitation and exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest ratio of value1 to value2 (0.7*value1/value2 + 0.3*value1)\n    weighted_values = [0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 for _, (v1, v2) in archive]\n    max_weighted = max(weighted_values)\n    candidates = [sol for (sol, (v1, v2)) in archive if 0.7 * (v1 / (v2 + 1e-10)) + 0.3 * v1 == max_weighted]\n\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Probabilistic neighborhood exploration\n    for _ in range(min(5, n_items)):\n        i = random.randint(0, n_items - 1)\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            if random.random() < 0.7:  # Higher probability to remove if it improves both objectives\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Dynamic neighborhood adjustment\n    if random.random() < 0.3:  # With 30% probability, perform a larger neighborhood move\n        num_changes = random.randint(2, min(5, n_items))\n        change_indices = random.sample(range(n_items), num_changes)\n        for i in change_indices:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The new algorithm uses a multi-criteria selection based on the hypervolume contribution of solutions, followed by a hybrid local search that combines random item swaps with a probabilistic acceptance criterion to ensure feasible solutions while exploring both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest hypervolume contribution (simplified)\n    max_hv = -1\n    for sol, (v1, v2) in archive:\n        hv = v1 * v2  # Simplified hypervolume approximation\n        if hv > max_hv:\n            max_hv = hv\n            base_solution = sol.copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: random swaps with probabilistic acceptance\n    for _ in range(min(5, n_items)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping items\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                # Accept if better in at least one objective\n                v1_new = np.sum(value1_lst * temp_solution)\n                v2_new = np.sum(value2_lst * temp_solution)\n                v1_old = np.sum(value1_lst * new_solution)\n                v2_old = np.sum(value2_lst * new_solution)\n\n                if (v1_new > v1_old) or (v2_new > v2_old):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    # Additional probabilistic item replacement\n    if random.random() < 0.5:\n        for i in range(n_items):\n            if new_solution[i] == 1 and random.random() < 0.2:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity and random.random() < 0.1:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -18.53275723415448,
            -18.230270719550944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest hypervolume contribution (simplified)\n    max_hv = -1\n    for sol, (v1, v2) in archive:\n        hv = v1 * v2  # Simplified hypervolume approximation\n        if hv > max_hv:\n            max_hv = hv\n            base_solution = sol.copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: random swaps with probabilistic acceptance\n    for _ in range(min(5, n_items)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping items\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                # Accept if better in at least one objective\n                v1_new = np.sum(value1_lst * temp_solution)\n                v2_new = np.sum(value2_lst * temp_solution)\n                v1_old = np.sum(value1_lst * new_solution)\n                v2_old = np.sum(value2_lst * new_solution)\n\n                if (v1_new > v1_old) or (v2_new > v2_old):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    # Additional probabilistic item replacement\n    if random.random() < 0.5:\n        for i in range(n_items):\n            if new_solution[i] == 1 and random.random() < 0.2:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity and random.random() < 0.1:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    }
]