[
    {
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on objective diversity and applies a hybrid local search operator that combines item swapping, flipping, and guided neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective diversity and current quality\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip items to explore neighborhood\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 2: Guided swap based on objective improvement\n    if np.random.rand() < 0.5:  # 50% chance to perform swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = np.random.choice(in_items)\n            swap_out = np.random.choice(out_items)\n\n            if (total_weight - weight_lst[swap_in] + weight_lst[swap_out]) <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    # Step 3: Add a random item if capacity allows\n    if np.random.rand() < 0.3 and total_weight < capacity:\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            add_item = np.random.choice(candidate_items)\n            if total_weight + weight_lst[add_item] <= capacity:\n                new_solution[add_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.7593591059647,
            -17.644363273968175
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement by prioritizing those with the highest objective values, then applies a hybrid local search operator that combines item swaps and probabilistic item flips to explore neighboring solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (can be modified)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item flips and swaps\n    for _ in range(10):  # Number of attempts\n        # Randomly select a candidate solution with high potential\n        candidate_idx = random.randint(0, min(4, len(archive)-1))\n        candidate = archive[candidate_idx][0]\n\n        # Apply probabilistic flips (higher probability for items not in base solution)\n        for i in range(len(candidate)):\n            if candidate[i] != base_solution[i]:\n                if random.random() < 0.3:  # Probability to flip\n                    new_solution[i] = 1 - new_solution[i]\n                    # Ensure feasibility\n                    if np.dot(new_solution, weight_lst) > capacity:\n                        new_solution[i] = 1 - new_solution[i]\n\n        # Apply random swaps between items in and out of the solution\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n            new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n            # Ensure feasibility\n            if np.dot(new_solution, weight_lst) > capacity:\n                new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n\n    return new_solution\n\n",
        "score": [
            -17.878465271110247,
            -17.74572313941402
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on objective diversity and applies a hybrid local search operator that combines item swapping, flipping, and guided neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective diversity and current quality\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip items to explore neighborhood\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 2: Guided swap based on objective improvement\n    if np.random.rand() < 0.5:  # 50% chance to perform swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = np.random.choice(in_items)\n            swap_out = np.random.choice(out_items)\n\n            if (total_weight - weight_lst[swap_in] + weight_lst[swap_out]) <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    # Step 3: Add a random item if capacity allows\n    if np.random.rand() < 0.3 and total_weight < capacity:\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            add_item = np.random.choice(candidate_items)\n            if total_weight + weight_lst[add_item] <= capacity:\n                new_solution[add_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.7593591059647,
            -17.644363273968175
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement by prioritizing those with the highest objective values, then applies a hybrid local search operator that combines item swaps and probabilistic item flips to explore neighboring solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (can be modified)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item flips and swaps\n    for _ in range(10):  # Number of attempts\n        # Randomly select a candidate solution with high potential\n        candidate_idx = random.randint(0, min(4, len(archive)-1))\n        candidate = archive[candidate_idx][0]\n\n        # Apply probabilistic flips (higher probability for items not in base solution)\n        for i in range(len(candidate)):\n            if candidate[i] != base_solution[i]:\n                if random.random() < 0.3:  # Probability to flip\n                    new_solution[i] = 1 - new_solution[i]\n                    # Ensure feasibility\n                    if np.dot(new_solution, weight_lst) > capacity:\n                        new_solution[i] = 1 - new_solution[i]\n\n        # Apply random swaps between items in and out of the solution\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n            new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n            # Ensure feasibility\n            if np.dot(new_solution, weight_lst) > capacity:\n                new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n\n    return new_solution\n\n",
        "score": [
            -17.878465271110247,
            -17.74572313941402
        ]
    }
]