[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.298002635448672,
            -15.787750362401573
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.226696319542373,
            -19.87297611463135
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.226696319542373,
            -19.87297611463135
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score (considering both objectives equally), then applies a hybrid local search that first diversifies by randomly flipping 5 items, followed by a focused improvement of objective 1 by adding items with highest marginal gains, then improves objective 2 by swapping items with high value-to-weight ratios, and concludes with a targeted diversification step that flips 2 items to maintain solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with Pareto-frontier dominance score\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Diversification by random flipping\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Second phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Third phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Targeted diversification step: flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.489281937295118,
            -19.590140216298373
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.4 and objective 2 0.6), then applies a hybrid local search that first improves both objectives by adding items with a novel combined value-to-weight ratio that considers the geometric mean of the two objectives, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score (0.4 for value1, 0.6 for value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.4 + (x[1][1] / max_value2) * 0.6))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate novel combined value-to-weight ratio using geometric mean\n    combined_ratio = np.sqrt(value1_lst * value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.205548120819515,
            -16.101045833515133
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score (0.7 for value1, 0.3 for value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.14517750546854,
            -19.635139327143094
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.298002635448672,
            -15.787750362401573
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score (60% objective 1, 40% objective 2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.838496788353872,
            -19.745011211142394
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.226696319542373,
            -19.87297611463135
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score (0.7 for value1, 0.3 for value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.934775768643938,
            -19.724731355621085
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score (0.6 for value1, 0.4 for value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.101372881441687,
            -19.69956410224067
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score (60% value1, 40% value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.022968850958563,
            -19.701836943647514
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves objective 1 by adding items with highest value-to-weight ratios, followed by a focused improvement of objective 2 by swapping items with high marginal gains, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.1184809333375,
            -19.667041776110054
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.4 and objective 2 0.6), then applies a hybrid local search that first improves objective 1 by removing items with the lowest value-to-weight ratios, followed by a focused improvement of objective 2 by adding items with high marginal gains, and concludes with a diversification step that randomly flips 4 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.4 + (x[1][1] / max_value2) * 0.6))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Remove low-value-to-weight ratio items for objective 1\n    included_items = np.where(new_solution == 1)[0]\n    if len(included_items) > 0:\n        sorted_items = sorted(included_items, key=lambda x: vw_ratio1[x])\n        for item in sorted_items[:2]:  # Remove bottom 2 items\n            new_solution[item] = 0\n            total_weight -= weight_lst[item]\n\n    # Second phase: Add high-value-to-weight ratio items for objective 2\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:2]:  # Add top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Diversification step: randomly flip 4 items\n    flip_indices = np.random.choice(len(new_solution), size=min(4, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.54283087043109,
            -18.741708341996723
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score (70% value1, 30% value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.130865352758434,
            -19.659083602577166
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.02471133080207,
            -19.36544408592488
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and a dynamic selection strategy, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains with different weights\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor * 0.5) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor * 1.5) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items with different probability\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.035949819710254,
            -19.187708487112566
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, but with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives with different priority\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.087998213611133,
            -19.063957853646194
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.70434902085598,
            -17.63180085346074
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    for _ in range(5):\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.926354444056216,
            -19.410089877267268
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, but with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.669239204991,
            -19.435852898343605
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, but with a novel score function that prioritizes both objectives equally and uses a selection strategy that alternates between adding and removing items in a way that balances both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined normalized objective value (equal weights)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) + (x[1][1] / max_value2)))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains (equal weights)\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Adaptive item selection based on combined gains\n    for _ in range(5):\n        # Alternate between adding and removing items\n        action = _ % 2\n\n        if action == 0:\n            # Add items with highest combined gain\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -combined_gain[x])\n                for item in sorted_items[:2]:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Remove items with lowest combined gain\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: combined_gain[x])\n                for item in sorted_items[:2]:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.035411705944544,
            -18.663782469602577
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, but with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.669239204991,
            -19.435852898343605
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, but with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.669239204991,
            -19.435852898343605
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.827594595905722,
            -17.464546133178033
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.78787101698494,
            -17.57663649963861
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of crowding distance and objective dominance, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification, with a modified score function that prioritizes objective 2 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.4 + (x[1][1] / max_value2) * 0.6))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.485471842716446,
            -18.872401311827943
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification with a different parameter setting, focusing on objective 2 with higher weight and more aggressive flipping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    for _ in range(5):\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:5]:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:5]:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.027272122444863,
            -19.285311350143797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification with a different parameter setting, focusing on objective 2 with higher weight and more aggressive flipping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    for _ in range(5):\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:5]:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:5]:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.027272122444863,
            -19.285311350143797
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the balance of its objective values and applies a novel hybrid local search that combines adaptive item grouping, guided removal of redundant items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by combined value-to-weight ratio\n        combined_values = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(combined_values)\n        # Remove items with lowest combined ratios first\n        for i in range(min(3, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential combined value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(4, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.5:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.966531819973817,
            -18.690805229954005
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the balance of its objective values and applies a novel hybrid local search that combines adaptive item grouping, guided removal of redundant items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by combined value-to-weight ratio\n        combined_values = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(combined_values)\n        # Remove items with lowest combined ratios first\n        for i in range(min(3, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential combined value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(4, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.5:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.951645933152243,
            -18.703353823843134
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains with different weights\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor * 0.8) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor * 0.6) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.6045673300181,
            -17.86944089348206
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the balance of its objective values and applies a novel hybrid local search that combines adaptive item grouping, guided removal of redundant items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by combined value-to-weight ratio\n        combined_values = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(combined_values)\n        # Remove items with lowest combined ratios first\n        for i in range(min(3, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential combined value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(4, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.5:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.966531819973817,
            -18.690805229954005
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.60662572414324,
            -17.63806094292203
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the balance of its objective values and applies a novel hybrid local search that combines adaptive item grouping, guided removal of redundant items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by combined value-to-weight ratio\n        combined_values = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(combined_values)\n        # Remove items with lowest combined ratios first\n        for i in range(min(3, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential combined value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(4, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.5:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.966531819973817,
            -18.690805229954005
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the balance of its objective values and applies a novel hybrid local search that combines adaptive item grouping, guided removal of redundant items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by combined value-to-weight ratio\n        combined_values = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(combined_values)\n        # Remove items with lowest combined ratios first\n        for i in range(min(3, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential combined value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(4, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.5:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.966531819973817,
            -18.690805229954005
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, but with a novel approach that prioritizes items based on their contribution to both objectives in a balanced manner and incorporates a dynamic exploration-exploitation trade-off mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest balanced objective value\n    objectives = np.array([obj for _, obj in archive])\n    norm_values = objectives / (np.max(objectives, axis=0) + 1e-6)\n    balanced_scores = np.mean(norm_values, axis=1)\n    selected_idx = np.argmax(balanced_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Dynamic exploration-exploitation trade-off\n    exploration_rate = 0.7 if np.random.rand() < 0.5 else 0.3\n\n    # Calculate balanced marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain = (value1_lst + value2_lst) * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection\n    for _ in range(5):\n        if np.random.rand() < exploration_rate:\n            # Exploration: consider items not in current solution\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain[x])\n                for item in sorted_items[:2]:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Exploitation: consider items in current solution\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: marginal_gain[x])\n                for item in sorted_items[:2]:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Dynamic flip mechanism\n    flip_prob = 0.3 if exploration_rate > 0.5 else 0.7\n    if np.random.rand() < flip_prob:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.227724959673125,
            -18.549037508799493
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.24507196953598,
            -18.010467067965717
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the balance of its objective values and applies a novel hybrid local search that combines adaptive item grouping, guided removal of redundant items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by combined value-to-weight ratio\n        combined_values = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(combined_values)\n        # Remove items with lowest combined ratios first\n        for i in range(min(3, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential combined value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(4, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.5:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.966531819973817,
            -18.690805229954005
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the dominance relationship and applies a novel hybrid local search that combines adaptive item grouping, guided removal of low-contribution items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on dominance relationship\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by value-to-weight ratio\n        ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(ratios)\n        # Remove items with lowest ratios first\n        for i in range(min(3, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(4, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.5:\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.010812121763745,
            -18.67169538285631
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains for both objectives\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item replacement based on combined gains\n    for _ in range(3):\n        # Focus on both objectives alternately\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1: add high-gain items\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2: remove low-gain items\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: marginal_gain2[x])\n                for item in sorted_items[:2]:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.57621781733628,
            -17.981632693882027
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item clustering based on value correlations, guided removal of items with low combined marginal gains, and capacity-aware insertion of items with high potential to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined objective value\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item clustering based on value correlations\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 1:\n        # Calculate pairwise correlations between items\n        value_matrix = np.column_stack((value1_lst[in_items], value2_lst[in_items]))\n        corr_matrix = np.corrcoef(value_matrix.T)\n        # Find items with highest correlation to remove\n        corr_sum = np.sum(corr_matrix, axis=1)\n        sorted_indices = np.argsort(corr_sum)\n        # Remove items with highest correlation\n        for i in range(min(2, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided removal of items with low combined marginal gains\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Calculate combined marginal gains\n        marginal_gain = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(marginal_gain)\n        # Remove items with lowest gains\n        for i in range(min(2, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 3: Capacity-aware insertion of high-potential items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential value-to-weight ratio\n        potential_ratio = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        sorted_indices = np.argsort(potential_ratio)[::-1]\n        # Try to add top items\n        for i in range(min(3, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 4: Random flip for diversification\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.065831572459864,
            -18.611825709767082
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.291832872131288,
            -17.987164290623234
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.291832872131288,
            -17.987164290623234
        ]
    }
]