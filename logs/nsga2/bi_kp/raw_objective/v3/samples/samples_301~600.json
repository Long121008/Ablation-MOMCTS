[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 4 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    flip_indices = np.random.choice(len(new_solution), size=min(4, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.094088885026927,
            -16.426273711129262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    flip_indices = np.random.choice(len(new_solution), size=min(4, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-aware selection criterion, then applies a hybrid local search that first performs a Pareto front exploration by adding items with non-dominated value combinations, followed by a targeted improvement phase that prioritizes items with high value1-to-value2 ratios, and concludes with a neighborhood diversification step that swaps clusters of items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dominance-aware criterion\n    archive.sort(key=lambda x: -(x[1][0] * 0.5 + x[1][1] * 0.5))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # First phase: Pareto front exploration by adding non-dominated items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate value ratios for non-dominated items\n        value_ratio = value1_lst[candidate_items] / (value2_lst[candidate_items] + 1e-6)\n        sorted_items = candidate_items[np.argsort(-value_ratio)][:3]\n\n        for item in sorted_items:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Targeted improvement with value1-to-value2 ratio\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            # Calculate improvement potential\n            improvement_potential = []\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        v1_gain = value1_lst[in_item] - value1_lst[out_item]\n                        v2_gain = value2_lst[in_item] - value2_lst[out_item]\n                        if v1_gain > 0 or v2_gain > 0:\n                            improvement_potential.append((v1_gain + v2_gain, out_item, in_item))\n\n            if improvement_potential:\n                improvement_potential.sort(reverse=True, key=lambda x: x[0])\n                _, out_item, in_item = improvement_potential[0]\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: swap clusters of items\n    cluster_size = min(3, len(new_solution) // 2)\n    if cluster_size > 0:\n        cluster_indices = np.random.choice(len(new_solution), size=cluster_size, replace=False)\n        for idx in cluster_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.94177030260697,
            -18.608219021253294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dominance-aware criterion\n    archive.sort(key=lambda x: -(x[1][0] * 0.5 + x[1][1] * 0.5))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # First phase: Pareto front exploration by adding non-dominated items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate value ratios for non-dominated items\n        value_ratio = value1_lst[candidate_items] / (value2_lst[candidate_items] + 1e-6)\n        sorted_items = candidate_items[np.argsort(-value_ratio)][:3]\n\n        for item in sorted_items:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Targeted improvement with value1-to-value2 ratio\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            # Calculate improvement potential\n            improvement_potential = []\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        v1_gain = value1_lst[in_item] - value1_lst[out_item]\n                        v2_gain = value2_lst[in_item] - value2_lst[out_item]\n                        if v1_gain > 0 or v2_gain > 0:\n                            improvement_potential.append((v1_gain + v2_gain, out_item, in_item))\n\n            if improvement_potential:\n                improvement_potential.sort(reverse=True, key=lambda x: x[0])\n                _, out_item, in_item = improvement_potential[0]\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: swap clusters of items\n    cluster_size = min(3, len(new_solution) // 2)\n    if cluster_size > 0:\n        cluster_indices = np.random.choice(len(new_solution), size=cluster_size, replace=False)\n        for idx in cluster_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with high value1-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value1-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items with high value1 ratio\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -value1_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.421233522236236,
            -19.70346190383606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value1-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items with high value1 ratio\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -value1_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score (70% value1, 30% value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding top 3 items with highest combined ratio\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.247573397251564,
            -16.052192583774726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score (70% value1, 30% value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, _ = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding top 3 items with highest combined ratio\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score (0.7 for value1, 0.3 for value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.274283425149576,
            -15.962522367981073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score (0.7 for value1, 0.3 for value2)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{The new algorithm selects a solution from the archive based on a lexicographic ordering of objectives (prioritizing objective 1), then applies a hybrid local search that first improves both objectives by adding items with high combined value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with lexicographic ordering (prioritize objective 1)\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.255774004979155,
            -18.282841821887203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with lexicographic ordering (prioritize objective 1)\n    archive.sort(key=lambda x: (-x[1][0], -x[1][1]))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined objective score (weighting objective 1 0.6 and objective 2 0.4), then applies a hybrid local search that first improves both objectives by adding items with balanced value-to-weight ratios, followed by a targeted improvement of objective 2 by swapping items with high value2 gains, and concludes with a diversification step that randomly flips 2 items to explore new regions of the search space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.6 + (x[1][1] / max_value2) * 0.4))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate combined value-to-weight ratios\n    combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])\n        for item in sorted_items[:2]:  # Consider top 2 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(2):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value2_lst[in_item] - value2_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 2 items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 307,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score, then applies a hybrid local search that first improves both objectives by adding items with high value-to-weight ratios, followed by a targeted improvement of objective 1 by swapping items with high value1 gains, and concludes with a diversification step that randomly flips 3 items to explore new regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on Pareto-frontier dominance\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate individual value-to-weight ratios\n    ratio1 = value1_lst / (weight_lst + 1e-6)\n    ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -(ratio1[x] + ratio2[x]))\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.25375474102922,
            -16.280468849006695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on Pareto-frontier dominance\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate individual value-to-weight ratios\n    ratio1 = value1_lst / (weight_lst + 1e-6)\n    ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve both objectives by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -(ratio1[x] + ratio2[x]))\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = value1_lst[in_item] - value1_lst[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    }
]