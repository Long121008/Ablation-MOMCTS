[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:3]:  # Consider top 3 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.73038688332939,
            -17.387394279256327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the balance of its objective values and applies a novel hybrid local search that combines adaptive item grouping, guided removal of redundant items, and capacity-aware item insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution based on balanced objective values\n    objectives = np.array([obj for _, obj in archive])\n    objective_ratios = objectives[:, 0] / (objectives[:, 1] + 1e-8)\n    selected_idx = np.argmin(np.abs(objective_ratios - np.median(objective_ratios)))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Adaptive item grouping and removal\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Group items by value-to-weight ratio\n        ratios = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        sorted_indices = np.argsort(ratios)\n        # Remove items with lowest ratios first\n        for i in range(min(2, len(in_items))):\n            idx = in_items[sorted_indices[i]]\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Step 2: Guided insertion of high-value items\n    out_items = np.where(new_solution == 0)[0]\n    if len(out_items) > 0 and total_weight < capacity:\n        # Calculate potential value-to-weight gain\n        potential_gain = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        # Sort by potential gain in descending order\n        sorted_indices = np.argsort(potential_gain)[::-1]\n        # Try to add top items\n        for i in range(min(3, len(out_items))):\n            idx = out_items[sorted_indices[i]]\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Random flip for diversification\n    if np.random.rand() < 0.4:\n        flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.00314807979447,
            -18.66169358658673
        ]
    }
]