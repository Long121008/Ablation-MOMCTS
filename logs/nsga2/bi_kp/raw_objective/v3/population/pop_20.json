[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score (weighting objective 1 0.7 and objective 2 0.3), then applies a hybrid local search that first improves objective 1 by adding items with highest marginal gains, followed by a focused improvement of objective 2 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 3 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 1 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio1[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 2 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio2[in_item] - vw_ratio2[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 3 items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -16.79084801119103,
            -19.814325869370023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (weighting objective 1 0.5 and objective 2 0.5), then applies a hybrid local search that first improves objective 2 by adding items with highest marginal gains, followed by a focused improvement of objective 1 by swapping items with high value-to-weight ratios, and concludes with a diversification step that randomly flips 5 items to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with dynamic weighted objective score\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.5 + (x[1][1] / max_value2) * 0.5))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios\n    vw_ratio1 = value1_lst / (weight_lst + 1e-6)\n    vw_ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # First phase: Improve objective 2 by adding items\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        sorted_items = sorted(candidate_items, key=lambda x: -vw_ratio2[x])\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Second phase: Improve objective 1 by swapping items\n    for _ in range(3):\n        out_items = np.where(new_solution == 1)[0]\n        in_items = np.where(new_solution == 0)[0]\n\n        if len(out_items) > 0 and len(in_items) > 0:\n            best_swap = None\n            best_gain = -float('inf')\n\n            for out_item in out_items:\n                for in_item in in_items:\n                    if total_weight - weight_lst[out_item] + weight_lst[in_item] <= capacity:\n                        gain = vw_ratio1[in_item] - vw_ratio1[out_item]\n                        if gain > best_gain:\n                            best_gain = gain\n                            best_swap = (out_item, in_item)\n\n            if best_swap and best_gain > 0:\n                out_item, in_item = best_swap\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                total_weight = total_weight - weight_lst[out_item] + weight_lst[in_item]\n\n    # Diversification step: randomly flip 5 items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.02605613683941,
            -16.457353386220518
        ]
    }
]