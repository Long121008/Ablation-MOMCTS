[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification with a different parameter setting, focusing on objective 2 with higher weight and more aggressive flipping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.3 + (x[1][1] / max_value2) * 0.7))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    for _ in range(5):\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:5]:\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:5]:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.027272122444863,
            -19.285311350143797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search operator that combines adaptive item selection based on weighted marginal gains and guided diversification to generate high-quality neighbors while maintaining feasibility, with a modified score function that prioritizes objective 1 with a higher weight and uses a different selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest weighted objective value (weighted by normalized values)\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: -((x[1][0] / max_value1) * 0.7 + (x[1][1] / max_value2) * 0.3))\n    base_solution, (base_value1, base_value2) = archive[0]\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate weighted marginal gains\n    weight_factor = (capacity - total_weight) / capacity\n    marginal_gain1 = value1_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst * (1 + weight_factor) / (weight_lst + 1e-6)\n\n    # Adaptive item selection based on weighted gains\n    for _ in range(5):\n        # Alternate between objectives\n        focus_obj = _ % 2\n\n        if focus_obj == 0:\n            # Focus on objective 1\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain1[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        total_weight += weight_lst[item]\n                        break\n        else:\n            # Focus on objective 2\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                sorted_items = sorted(candidate_items, key=lambda x: -marginal_gain2[x])\n                for item in sorted_items[:2]:  # Consider top 2 items\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Guided diversification: randomly flip a small number of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -19.90349586202879,
            -17.286865944517913
        ]
    }
]