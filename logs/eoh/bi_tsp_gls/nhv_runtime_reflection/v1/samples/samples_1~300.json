[
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a tour from the archive, performs local search using penalized edge costs to guide exploration, and adaptively penalizes frequently used edges to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.7382794115862021,
            0.49825502634048463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a tour from the archive, performs local search using penalized edge costs to guide exploration, and adaptively penalizes frequently used edges to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.7382794115862021,
            0.49825502634048463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a tour from the archive, performs local search using penalized edge costs to guide exploration, and adaptively penalizes frequently used edges to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.7382794115862021,
            0.49825502634048463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8532791274164678,
            0.5048539876937866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8532791274164678,
            0.5048539876937866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The GLS heuristic iteratively improves a bi-objective TSP tour by selecting a base solution from an archive, performing penalized local search with relocation moves, and adaptively updating edge penalties to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8423486788629198,
            0.5037129163742066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The algorithm uses a Guided Local Search (GLS) heuristic that selects a tour from the archive, applies penalized relocate moves to escape local optima, and adapts penalties based on edge utilities to guide the search toward non-dominated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8428608641904779,
            0.49331132173538206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The algorithm uses a Guided Local Search (GLS) heuristic that selects a tour from the archive, applies penalized relocate moves to escape local optima, and adapts penalties based on edge utilities to guide the search toward non-dominated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8428608641904779,
            0.49331132173538206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.7602248146694021,
            0.5049318909645081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm iteratively selects a tour from the archive, applies penalized local search with relocation moves, adapts penalties based on edge utilities to guide exploration, and returns an improved valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.7174892190337471,
            0.5018975257873535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.7448573041303718,
            0.5020244479179382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The GLS heuristic for bi-TSP selects a tour from the archive, applies penalized local search using relocation moves while implicitly adapting penalties to escape local optima, and returns an improved valid tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8365332229599766,
            0.5222306609153747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8245256633265063,
            0.494344425201416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The algorithm selects a random tour from the archive, applies a penalized relocate move to escape local optima, and updates penalties on edges with highest utility to guide future searches toward less explored regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.794631233425587,
            0.49798630475997924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{Guided Local Search (GLS) for bi-objective TSP selects a tour from the archive, applies penalized local search using relocation moves, and adaptively penalizes frequently used edges to guide search toward less explored regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8270135401615393,
            0.49198137521743773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{Guided Local Search (GLS) for bi-objective TSP selects a tour from the archive, applies penalized local search using relocation moves, and adaptively penalizes frequently used edges to guide search toward less explored regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.8270135401615393,
            0.49198137521743773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    update_penalties(best)\n\n    return best\n\n"
    },
    {
        "prompt": "\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP).\n\nDesign a Guided Local Search (GLS) heuristic named `select_neighbor`.\n\nGLS should iteratively improve a complete TSP tour by applying local search moves,\nwhile using adaptive penalties on solution features (e.g., edges or city transitions)\nto escape local optima.\n\nThe function receives an archive of non-dominated tours. It should:\n- Select a promising tour from the archive,\n- Apply a penalized local search step using non-standard neighborhood structures\n  (e.g., node relocation, insertion, or segment reordering),\n- Adapt penalties implicitly through feature-aware decision making,\n- Return a new feasible TSP tour.\n\nAvoid standard 2-opt operators.\nThe returned solution must always be a valid permutation that visits each city\nexactly once and returns to the starting city.\n\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    # --- persistent penalty memory (per function instance) ---\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n",
        "score": [
            -0.7670068705574976,
            0.4996155261993408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\nfrom collections import defaultdict\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Guided Local Search (GLS) operator for Bi-objective TSP.\n    \"\"\"\n    if not hasattr(select_neighbor, \"penalties\"):\n        select_neighbor.penalties = defaultdict(int)\n    penalties = select_neighbor.penalties\n\n    def edge_key(a, b):\n        return tuple(sorted((int(a), int(b))))\n\n    def penalized_cost(tour, lam=0.1):\n        cost = 0.0\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            cost += distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            cost += lam * penalties[edge_key(a, b)]\n        return cost\n\n    def update_penalties(tour):\n        utilities = []\n        n = len(tour)\n        for i in range(n):\n            a, b = tour[i], tour[(i + 1) % n]\n            base = distance_matrix_1[a][b] + distance_matrix_2[a][b]\n            util = base / (1 + penalties[edge_key(a, b)])\n            utilities.append((util, edge_key(a, b)))\n\n        max_util = max(u for u, _ in utilities)\n        for u, e in utilities:\n            if u == max_util:\n                penalties[e] += 1\n\n    def relocate_move(tour):\n        n = len(tour)\n        i, j = random.sample(range(n), 2)\n        new = list(tour)\n        city = new.pop(i)\n        new.insert(j, city)\n        return np.array(new)\n\n    # --- pick base solution ---\n    base_tour = random.choice(archive)[0].copy()\n    best = base_tour\n    best_cost = penalized_cost(best)\n\n    # --- local search ---\n    for _ in range(10):\n        cand = relocate_move(best)\n        c_cost = penalized_cost(cand)\n        if c_cost < best_cost:\n            best, best_cost = cand, c_cost\n\n    # --- GLS penalty update ---\n    update_penalties(best)\n\n    return best\n\n"
    }
]