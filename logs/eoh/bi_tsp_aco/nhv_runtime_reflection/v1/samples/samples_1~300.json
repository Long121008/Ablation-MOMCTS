[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function combines an ant colony optimization-inspired approach with elitist pheromone updates to intelligently select and improve a solution from the archive, using a probabilistic transition rule that balances pheromone trails and heuristic information to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8625163197517395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function combines an ant colony optimization-inspired approach with elitist pheromone updates to intelligently select and improve a solution from the archive, using a probabilistic transition rule that balances pheromone trails and heuristic information to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8625163197517395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function combines an ant colony optimization-inspired approach with elitist pheromone updates to intelligently select and improve a solution from the archive, using a probabilistic transition rule that balances pheromone trails and heuristic information to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8625163197517395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A hybrid local search algorithm that combines ACO-inspired neighborhood exploration with a novel adaptive edge-swap strategy to balance exploration and exploitation while ensuring feasibility, leveraging pheromone trails and heuristic information to guide the search towards high-quality solutions across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9244569420814515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm combines ant colony optimization (ACO) principles with elitist pheromone updates from an archive of solutions to generate high-quality TSP tours by balancing exploration (via heuristic information) and exploitation (via pheromone trails).}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8055681109428405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm combines ant colony optimization (ACO) principles with elitist pheromone updates from an archive of solutions to generate high-quality TSP tours by balancing exploration (via heuristic information) and exploitation (via pheromone trails).}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8055681109428405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm implements an ant colony optimization-inspired local search that constructs a new tour by probabilistically selecting nodes based on pheromone trails and heuristic information, then updates pheromones using elitist solutions from the archive to guide future exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9460166215896606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The heuristic function employs an ant colony optimization-inspired approach, combining pheromone trails with problem-specific heuristics to construct a novel neighbor solution from the archive, while dynamically updating pheromones to guide exploration toward promising regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7561952233314514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The heuristic function employs an ant colony optimization-inspired approach, combining pheromone trails with problem-specific heuristics to construct a novel neighbor solution from the archive, while dynamically updating pheromones to guide exploration toward promising regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7561952233314514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A hybrid local search algorithm that combines ant colony optimization-inspired neighbor selection with a novel edge-swapping strategy that prioritizes high-potential edges based on both distance matrices and pheromone trails, ensuring feasibility while exploring diverse neighborhoods to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8347091794013977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A hybrid ant colony optimization-inspired local search that combines pheromone-guided exploration with heuristic-driven exploitation to generate high-quality neighbor solutions by intelligently selecting and perturbing promising tours from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8963587880134583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to select and modify a solution from the archive, combining pheromone trails with heuristic information to construct a new neighbor solution while updating pheromones based on the archive's solutions for guided exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8018628597259522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, combining pheromone trails with heuristic information to construct a new neighbor solution through a novel local search strategy that dynamically balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8186853051185607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The heuristic function employs a hybrid ant colony optimization (ACO) approach, where solutions are probabilistically constructed based on pheromone trails and heuristic information, followed by an elitist pheromone update from the archive to guide exploration toward promising regions in the bi-objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8169561505317688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This heuristic selects a promising solution from the archive using a combination of pheromone-based probabilistic selection and a novel local search operator that dynamically adjusts edge weights based on both objective distances and pheromone trails to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both objectives and pheromone\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Probabilistic selection of a parent solution\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    probs = 1.0 / np.array(costs)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    parent_tour = archive[selected_idx][0].copy()\n\n    # Novel local search operator: Edge-based perturbation with pheromone guidance\n    tour = parent_tour.copy()\n    for _ in range(3):  # Number of perturbation steps\n        # Select a random segment to perturb\n        start = random.randint(0, n - 1)\n        length = random.randint(2, min(5, n - 1))\n        end = (start + length) % n\n\n        # Extract the segment and reverse it (with pheromone guidance)\n        segment = tour[start:end]\n        segment = segment[::-1]\n\n        # Reconstruct the tour with the perturbed segment\n        new_tour = np.concatenate([tour[:start], segment, tour[end:]])\n        new_tour = np.roll(new_tour, -start)  # Ensure continuity\n\n        # Accept if the new tour is better in either objective\n        new_obj1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_obj2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        old_obj1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n        old_obj2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2):\n            tour = new_tour\n\n    # Update pheromones based on the best solution in archive\n    best_sol = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = best_sol[k]\n        b = best_sol[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (sum(best_sol) + 1e-12)\n        pheromone[b, a] += 1.0 / (sum(best_sol) + 1e-12)\n\n    return tour\n\n",
        "score": [
            0.0,
            0.5219888687133789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both objectives and pheromone\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Probabilistic selection of a parent solution\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    probs = 1.0 / np.array(costs)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    parent_tour = archive[selected_idx][0].copy()\n\n    # Novel local search operator: Edge-based perturbation with pheromone guidance\n    tour = parent_tour.copy()\n    for _ in range(3):  # Number of perturbation steps\n        # Select a random segment to perturb\n        start = random.randint(0, n - 1)\n        length = random.randint(2, min(5, n - 1))\n        end = (start + length) % n\n\n        # Extract the segment and reverse it (with pheromone guidance)\n        segment = tour[start:end]\n        segment = segment[::-1]\n\n        # Reconstruct the tour with the perturbed segment\n        new_tour = np.concatenate([tour[:start], segment, tour[end:]])\n        new_tour = np.roll(new_tour, -start)  # Ensure continuity\n\n        # Accept if the new tour is better in either objective\n        new_obj1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_obj2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        old_obj1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n        old_obj2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2):\n            tour = new_tour\n\n    # Update pheromones based on the best solution in archive\n    best_sol = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = best_sol[k]\n        b = best_sol[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (sum(best_sol) + 1e-12)\n        pheromone[b, a] += 1.0 / (sum(best_sol) + 1e-12)\n\n    return tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This heuristic selects a promising solution from the archive using a combination of pheromone-based probabilistic selection and a novel local search operator that dynamically adjusts edge weights based on both objective distances and pheromone trails to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both objectives and pheromone\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Probabilistic selection of a parent solution\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    probs = 1.0 / np.array(costs)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    parent_tour = archive[selected_idx][0].copy()\n\n    # Novel local search operator: Edge-based perturbation with pheromone guidance\n    tour = parent_tour.copy()\n    for _ in range(3):  # Number of perturbation steps\n        # Select a random segment to perturb\n        start = random.randint(0, n - 1)\n        length = random.randint(2, min(5, n - 1))\n        end = (start + length) % n\n\n        # Extract the segment and reverse it (with pheromone guidance)\n        segment = tour[start:end]\n        segment = segment[::-1]\n\n        # Reconstruct the tour with the perturbed segment\n        new_tour = np.concatenate([tour[:start], segment, tour[end:]])\n        new_tour = np.roll(new_tour, -start)  # Ensure continuity\n\n        # Accept if the new tour is better in either objective\n        new_obj1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_obj2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        old_obj1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n        old_obj2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2):\n            tour = new_tour\n\n    # Update pheromones based on the best solution in archive\n    best_sol = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = best_sol[k]\n        b = best_sol[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (sum(best_sol) + 1e-12)\n        pheromone[b, a] += 1.0 / (sum(best_sol) + 1e-12)\n\n    return tour\n\n",
        "score": [
            0.0,
            0.5219888687133789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both objectives and pheromone\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Probabilistic selection of a parent solution\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    probs = 1.0 / np.array(costs)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    parent_tour = archive[selected_idx][0].copy()\n\n    # Novel local search operator: Edge-based perturbation with pheromone guidance\n    tour = parent_tour.copy()\n    for _ in range(3):  # Number of perturbation steps\n        # Select a random segment to perturb\n        start = random.randint(0, n - 1)\n        length = random.randint(2, min(5, n - 1))\n        end = (start + length) % n\n\n        # Extract the segment and reverse it (with pheromone guidance)\n        segment = tour[start:end]\n        segment = segment[::-1]\n\n        # Reconstruct the tour with the perturbed segment\n        new_tour = np.concatenate([tour[:start], segment, tour[end:]])\n        new_tour = np.roll(new_tour, -start)  # Ensure continuity\n\n        # Accept if the new tour is better in either objective\n        new_obj1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        new_obj2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n        old_obj1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n        old_obj2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2):\n            tour = new_tour\n\n    # Update pheromones based on the best solution in archive\n    best_sol = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = best_sol[k]\n        b = best_sol[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (sum(best_sol) + 1e-12)\n        pheromone[b, a] += 1.0 / (sum(best_sol) + 1e-12)\n\n    return tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm uses a hybrid ant colony optimization (ACO) approach combined with a novel local search strategy that intelligently selects promising solutions from the archive and applies a creative edge-swap operator to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- intelligent selection of promising solution ----\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    selected_sol = archive[selected_idx][0]\n\n    # ---- novel hybrid local search operator ----\n    new_tour = selected_sol.copy()\n    for _ in range(min(10, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Check feasibility and apply edge swap\n        if len(segment) > 1:\n            new_tour[i:j+1] = reversed_segment\n\n            # Additional swap for multi-objective diversity\n            if random.random() < 0.3:\n                k, l = sorted(random.sample(range(n), 2))\n                new_tour[k], new_tour[l] = new_tour[l], new_tour[k]\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return new_tour\n\n",
        "score": [
            0.0,
            0.29801632165908815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- intelligent selection of promising solution ----\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    selected_sol = archive[selected_idx][0]\n\n    # ---- novel hybrid local search operator ----\n    new_tour = selected_sol.copy()\n    for _ in range(min(10, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Check feasibility and apply edge swap\n        if len(segment) > 1:\n            new_tour[i:j+1] = reversed_segment\n\n            # Additional swap for multi-objective diversity\n            if random.random() < 0.3:\n                k, l = sorted(random.sample(range(n), 2))\n                new_tour[k], new_tour[l] = new_tour[l], new_tour[k]\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return new_tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm uses a hybrid ant colony optimization (ACO) approach combined with a novel local search strategy that intelligently selects promising solutions from the archive and applies a creative edge-swap operator to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- intelligent selection of promising solution ----\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    selected_sol = archive[selected_idx][0]\n\n    # ---- novel hybrid local search operator ----\n    new_tour = selected_sol.copy()\n    for _ in range(min(10, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Check feasibility and apply edge swap\n        if len(segment) > 1:\n            new_tour[i:j+1] = reversed_segment\n\n            # Additional swap for multi-objective diversity\n            if random.random() < 0.3:\n                k, l = sorted(random.sample(range(n), 2))\n                new_tour[k], new_tour[l] = new_tour[l], new_tour[k]\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return new_tour\n\n",
        "score": [
            0.0,
            0.29801632165908815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- intelligent selection of promising solution ----\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    selected_sol = archive[selected_idx][0]\n\n    # ---- novel hybrid local search operator ----\n    new_tour = selected_sol.copy()\n    for _ in range(min(10, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Check feasibility and apply edge swap\n        if len(segment) > 1:\n            new_tour[i:j+1] = reversed_segment\n\n            # Additional swap for multi-objective diversity\n            if random.random() < 0.3:\n                k, l = sorted(random.sample(range(n), 2))\n                new_tour[k], new_tour[l] = new_tour[l], new_tour[k]\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return new_tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm uses a hybrid ant colony optimization approach with adaptive pheromone updating and heuristic guidance to intelligently select and improve a solution from the archive, combining probabilistic selection with local search to explore high-quality neighbors in the bi-objective TSP space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8532501459121704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The heuristic function uses an ant colony optimization-inspired approach to construct a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through a novel local search operator that combines edge swaps with adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8213746666908264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm combines ant colony optimization principles with elitist pheromone updates to intelligently select and improve solutions from the archive, using a hybrid heuristic that balances pheromone trails and distance-based attractiveness to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7958317875862122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This heuristic function selects a promising solution from the archive using a hybrid ant colony optimization approach, combining probabilistic selection with a novel local search operator that dynamically adjusts pheromone trails to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.830119001865387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm implements an Ant Colony Optimization (ACO) inspired local search that constructs a new solution probabilistically based on pheromone trails and heuristic information, then updates the pheromone matrix using elitist solutions from the archive to guide future search toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8061144232749939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This heuristic function implements an ant colony optimization (ACO)-inspired local search that constructs a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while periodically updating pheromone levels from the archive to guide the search toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8689994812011719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, where pheromone trails guide the construction of a new tour, combining path selection probabilities with heuristic information derived from both objective spaces to ensure diversity and quality in the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9472535252571106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This heuristic function selects a promising solution from the archive using a pheromone-based approach, where solutions with lower combined cost leave more pheromone trails, and constructs a neighbor solution by probabilistically choosing nodes based on pheromone levels and heuristic information (inverse of combined distance), ensuring feasibility through a constructive ant-colony-like method.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.876155161857605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The algorithm combines ant colony optimization principles with a probabilistic selection of nodes based on pheromone trails and heuristic information, while ensuring the generated solution remains a valid TSP tour by tracking visited nodes and updating pheromones from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8443769693374634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, where solutions are constructed probabilistically based on pheromone trails and heuristic information, and pheromones are updated elitistically to guide future searches toward high-quality regions of the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8615146994590759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The heuristic function uses an ant colony optimization-inspired approach with adaptive pheromone trails and a hybrid local search that combines probabilistic selection with elitist pheromone updates to generate high-quality neighbor solutions for the bi-objective TSP.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- Hybrid local search: apply a novel operator ----\n    # Select a segment to relocate (random but biased towards high-potential edges)\n    if len(tour) > 3:\n        # Find the edge with highest pheromone value\n        max_pheromone = -1\n        best_edge = None\n        for k in range(n):\n            a = tour[k]\n            b = tour[(k + 1) % n]\n            if pheromone[a, b] > max_pheromone:\n                max_pheromone = pheromone[a, b]\n                best_edge = (a, b)\n\n        if best_edge:\n            a, b = best_edge\n            # Find the best position to insert 'b' after 'a' to break the edge\n            best_insert_pos = None\n            min_insert_cost = float('inf')\n            for i in range(n):\n                if tour[i] == a and tour[(i + 1) % n] != b:\n                    # Try inserting 'b' at different positions\n                    for j in range(n):\n                        if j != i and j != (i + 1) % n:\n                            # Calculate cost of inserting 'b' at position j\n                            cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + \\\n                                   distance_matrix_1[b, tour[(j + 1) % n]] + distance_matrix_2[b, tour[(j + 1) % n]]\n                            if cost < min_insert_cost:\n                                min_insert_cost = cost\n                                best_insert_pos = j\n\n            if best_insert_pos is not None:\n                # Perform the insertion\n                idx_a = tour.index(a)\n                idx_b = tour.index(b)\n                if idx_a < idx_b:\n                    tour = tour[:idx_a + 1] + [b] + tour[idx_a + 1:idx_b] + tour[idx_b + 1:]\n                else:\n                    tour = tour[:idx_b + 1] + [a] + tour[idx_b + 1:idx_a] + tour[idx_a + 1:]\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.928784441947937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- Hybrid local search: apply a novel operator ----\n    # Select a segment to relocate (random but biased towards high-potential edges)\n    if len(tour) > 3:\n        # Find the edge with highest pheromone value\n        max_pheromone = -1\n        best_edge = None\n        for k in range(n):\n            a = tour[k]\n            b = tour[(k + 1) % n]\n            if pheromone[a, b] > max_pheromone:\n                max_pheromone = pheromone[a, b]\n                best_edge = (a, b)\n\n        if best_edge:\n            a, b = best_edge\n            # Find the best position to insert 'b' after 'a' to break the edge\n            best_insert_pos = None\n            min_insert_cost = float('inf')\n            for i in range(n):\n                if tour[i] == a and tour[(i + 1) % n] != b:\n                    # Try inserting 'b' at different positions\n                    for j in range(n):\n                        if j != i and j != (i + 1) % n:\n                            # Calculate cost of inserting 'b' at position j\n                            cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + \\\n                                   distance_matrix_1[b, tour[(j + 1) % n]] + distance_matrix_2[b, tour[(j + 1) % n]]\n                            if cost < min_insert_cost:\n                                min_insert_cost = cost\n                                best_insert_pos = j\n\n            if best_insert_pos is not None:\n                # Perform the insertion\n                idx_a = tour.index(a)\n                idx_b = tour.index(b)\n                if idx_a < idx_b:\n                    tour = tour[:idx_a + 1] + [b] + tour[idx_a + 1:idx_b] + tour[idx_b + 1:]\n                else:\n                    tour = tour[:idx_b + 1] + [a] + tour[idx_b + 1:idx_a] + tour[idx_a + 1:]\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The heuristic function uses an ant colony optimization-inspired approach to construct a neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through careful node selection and pheromone updates from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.861994743347168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This heuristic function employs an ant colony optimization-inspired approach to intelligently select and modify a solution from the archive, combining pheromone-based exploration with problem-specific heuristic information to generate high-quality neighbor solutions while ensuring feasibility through careful construction and elitist pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1    # Evaporation rate\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from the archive with preference for those with better combined objective\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = 1.0 / (objectives + 1e-12)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    selected_sol = archive[selected_idx][0]\n\n    # Hybrid local search: combine ACO construction with guided perturbations\n    tour = selected_sol.tolist()\n    visited = set(tour)\n\n    # Perform a segment reversal between two random points\n    a, b = sorted(random.sample(range(n), 2))\n    tour[a:b] = tour[a:b][::-1]\n\n    # Attempt to fix any duplicates by swapping with unvisited nodes\n    duplicates = [node for node in tour if tour.count(node) > 1]\n    for dup in duplicates:\n        pos = tour.index(dup)\n        unvisited = [node for node in range(n) if node not in visited]\n        if unvisited:\n            new_node = random.choice(unvisited)\n            tour[pos] = new_node\n            visited.add(new_node)\n\n    # Apply ACO-like construction to the remaining unvisited nodes\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        if not candidates:\n            break\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Ensure we have a valid tour (fallback to random if needed)\n    if len(tour) != n or len(set(tour)) != n:\n        tour = list(range(n))\n        random.shuffle(tour)\n\n    # Update pheromones with elitist strategy\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.6858124732971191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1    # Evaporation rate\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from the archive with preference for those with better combined objective\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = 1.0 / (objectives + 1e-12)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    selected_sol = archive[selected_idx][0]\n\n    # Hybrid local search: combine ACO construction with guided perturbations\n    tour = selected_sol.tolist()\n    visited = set(tour)\n\n    # Perform a segment reversal between two random points\n    a, b = sorted(random.sample(range(n), 2))\n    tour[a:b] = tour[a:b][::-1]\n\n    # Attempt to fix any duplicates by swapping with unvisited nodes\n    duplicates = [node for node in tour if tour.count(node) > 1]\n    for dup in duplicates:\n        pos = tour.index(dup)\n        unvisited = [node for node in range(n) if node not in visited]\n        if unvisited:\n            new_node = random.choice(unvisited)\n            tour[pos] = new_node\n            visited.add(new_node)\n\n    # Apply ACO-like construction to the remaining unvisited nodes\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        if not candidates:\n            break\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Ensure we have a valid tour (fallback to random if needed)\n    if len(tour) != n or len(set(tour)) != n:\n        tour = list(range(n))\n        random.shuffle(tour)\n\n    # Update pheromones with elitist strategy\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A hybrid local search strategy combining ant colony optimization-inspired neighborhood generation with a novel edge-swapping mechanism that considers both objectives' distance matrices to dynamically explore high-potential regions while maintaining feasibility through constrained edge swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Ant-inspired construction\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Hybrid edge-swapping local search\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Check feasibility before swapping\n        if (i != j and k != l and\n            all(x not in {i, j, k, l} for x in {tour[(i+1)%n], tour[(j+1)%n], tour[(k+1)%n], tour[(l+1)%n]}) and\n            all(tour[x] not in {i, j, k, l} for x in range(n) if x not in {i, j, k, l})):\n\n            # Calculate objective changes\n            old_edges = [(tour[i], tour[(i+1)%n]), (tour[j], tour[(j+1)%n]),\n                         (tour[k], tour[(k+1)%n]), (tour[l], tour[(l+1)%n])]\n            new_edges = [(tour[i], tour[k]), (tour[j], tour[l])]\n\n            old_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in old_edges)\n            new_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in new_edges)\n\n            if new_cost < old_cost:\n                # Perform the swap\n                tour[i], tour[k] = tour[k], tour[i]\n                tour[j], tour[l] = tour[l], tour[j]\n\n    # Pheromone update\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9866358518600464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Ant-inspired construction\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Hybrid edge-swapping local search\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Check feasibility before swapping\n        if (i != j and k != l and\n            all(x not in {i, j, k, l} for x in {tour[(i+1)%n], tour[(j+1)%n], tour[(k+1)%n], tour[(l+1)%n]}) and\n            all(tour[x] not in {i, j, k, l} for x in range(n) if x not in {i, j, k, l})):\n\n            # Calculate objective changes\n            old_edges = [(tour[i], tour[(i+1)%n]), (tour[j], tour[(j+1)%n]),\n                         (tour[k], tour[(k+1)%n]), (tour[l], tour[(l+1)%n])]\n            new_edges = [(tour[i], tour[k]), (tour[j], tour[l])]\n\n            old_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in old_edges)\n            new_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in new_edges)\n\n            if new_cost < old_cost:\n                # Perform the swap\n                tour[i], tour[k] = tour[k], tour[i]\n                tour[j], tour[l] = tour[l], tour[j]\n\n    # Pheromone update\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The heuristic function 'select_neighbor' employs an ant colony optimization-inspired approach to construct a neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while maintaining feasibility and updating pheromone levels based on the archive's elite solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9223375678062439
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A hybrid adaptive local search method that combines ant colony optimization-inspired selection with a novel edge-swap operator that dynamically balances exploration and exploitation by adapting to the pheromone trails and heuristic information from both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- adaptive edge-swap operator ----\n    best_tour = tour.copy()\n    for _ in range(10):  # limit iterations for efficiency\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_tour = tour[:a] + tour[a:b][::-1] + tour[b:]\n\n        # check feasibility and quality\n        if len(set(new_tour)) == n:\n            cost1 = sum(distance_matrix_1[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n            new_cost = cost1 + cost2\n\n            old_cost1 = sum(distance_matrix_1[tour[k], tour[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[tour[k], tour[(k+1)%n]] for k in range(n))\n            old_cost = old_cost1 + old_cost2\n\n            if new_cost < old_cost or random.random() < 0.1:  # allow some randomness\n                tour = new_tour\n                if new_cost < sum(distance_matrix_1[best_tour[k], best_tour[(k+1)%n]] for k in range(n)) + sum(distance_matrix_2[best_tour[k], best_tour[(k+1)%n]] for k in range(n)):\n                    best_tour = new_tour\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(best_tour)\n\n",
        "score": [
            0.0,
            1.2172416687011718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- adaptive edge-swap operator ----\n    best_tour = tour.copy()\n    for _ in range(10):  # limit iterations for efficiency\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_tour = tour[:a] + tour[a:b][::-1] + tour[b:]\n\n        # check feasibility and quality\n        if len(set(new_tour)) == n:\n            cost1 = sum(distance_matrix_1[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n            new_cost = cost1 + cost2\n\n            old_cost1 = sum(distance_matrix_1[tour[k], tour[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[tour[k], tour[(k+1)%n]] for k in range(n))\n            old_cost = old_cost1 + old_cost2\n\n            if new_cost < old_cost or random.random() < 0.1:  # allow some randomness\n                tour = new_tour\n                if new_cost < sum(distance_matrix_1[best_tour[k], best_tour[(k+1)%n]] for k in range(n)) + sum(distance_matrix_2[best_tour[k], best_tour[(k+1)%n]] for k in range(n)):\n                    best_tour = new_tour\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(best_tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This heuristic function employs an ant colony optimization-inspired approach to construct a new neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through an elitist pheromone update mechanism from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8572839260101318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This heuristic function selects a promising solution from the archive using a hybrid approach combining ant colony optimization principles with a novel local search strategy that iteratively improves the tour by considering both objective spaces and leveraging pheromone trails to guide exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8342642784118652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, where solutions are constructed probabilistically based on pheromone trails and heuristic information, and pheromone trails are updated from the archive to guide future searches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9524590849876404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The heuristic function selects a promising solution from the archive using a hybrid approach combining ant colony optimization (ACO) principles with a novel local search strategy that dynamically adapts pheromone trails to guide exploration of high-quality regions in the solution space, while ensuring feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7642756342887879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The algorithm combines an ant colony optimization-inspired heuristic with elitist pheromone updates to intelligently select and improve solutions from the archive, using a hybrid local search that balances exploration and exploitation of promising regions in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.851441252231598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This algorithm combines ant colony optimization principles with a greedy heuristic for local search, where solutions are constructed probabilistically based on pheromone trails and edge costs, then iteratively refined by elitist pheromone updates from the archive to guide exploration toward promising regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9575356245040894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This heuristic function uses a hybrid ant colony optimization approach with adaptive pheromone trails, where solutions from the archive influence the construction of new tours by combining pheromone and heuristic information, while elitist updates ensure convergence toward high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9215177893638611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm combines ant colony optimization principles with elitist pheromone updates to intelligently select and perturb solutions from the archive, using a novel hybrid local search that balances exploration and exploitation through probabilistic city selection and pheromone-guided moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7569589257240296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This heuristic function selects a high-potential solution from the archive using an ant colony optimization-inspired approach, combining pheromone trails with heuristic information to construct a new neighbor solution through a hybrid local search that adapts to the bi-objective structure of the problem.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8216605067253113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This algorithm combines ant colony optimization principles with intelligent random selection from the archive to generate high-quality neighbor solutions by leveraging pheromone trails and heuristic information to guide the construction of new TSP tours, ensuring feasibility while exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9841959357261658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The algorithm combines ant colony optimization (ACO) principles with elitist pheromone updates from a solution archive to intelligently select and perturb a neighbor solution, using a hybrid of probabilistic city selection and pheromone-guided exploration to avoid local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8652696490287781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The heuristic function employs an ant colony optimization-inspired approach to construct a neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through a set-based tracking of visited nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9342960834503173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm combines ant colony optimization with a heuristic-guided local search to intelligently select and improve a TSP tour from the archive, using pheromone trails and distance-based heuristics to guide the selection and modification of solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7995829582214355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This algorithm uses an ant-inspired local search that combines pheromone trails with heuristic information to construct a new solution, while periodically updating pheromone levels based on the archive's elite solutions to guide the search toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8838527917861938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, where solutions are constructed probabilistically based on pheromone trails and heuristic information, while ensuring the generated neighbor remains a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both distance matrices\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on combined cost and diversity\n    if len(archive) > 1:\n        # Calculate Pareto front dominance scores\n        dominance = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                       (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                        dominance[i] += 1\n\n        # Select solution with highest dominance score\n        selected_idx = np.argmax(dominance)\n    else:\n        selected_idx = 0\n\n    selected_solution = archive[selected_idx][0]\n\n    # Apply hybrid local search operator\n    # 1. Randomly select a segment to reverse (like in 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution = selected_solution.copy()\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 2. Apply insertion move to improve connectivity\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Verify solution is still valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    # Update pheromone trails\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return new_solution\n\n",
        "score": [
            0.0,
            0.38191856145858766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both distance matrices\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on combined cost and diversity\n    if len(archive) > 1:\n        # Calculate Pareto front dominance scores\n        dominance = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                       (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                        dominance[i] += 1\n\n        # Select solution with highest dominance score\n        selected_idx = np.argmax(dominance)\n    else:\n        selected_idx = 0\n\n    selected_solution = archive[selected_idx][0]\n\n    # Apply hybrid local search operator\n    # 1. Randomly select a segment to reverse (like in 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution = selected_solution.copy()\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 2. Apply insertion move to improve connectivity\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Verify solution is still valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    # Update pheromone trails\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm combines ant colony optimization with heuristic-guided local search to intelligently select and improve a solution from the archive by constructing a new tour using pheromone trails and distance-based heuristics, while updating pheromone levels based on archive solutions to guide future selections.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8315209984779358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm combines ant colony optimization principles with an elitist pheromone update strategy to intelligently select and improve solutions from the archive, using a novel hybrid local search that balances exploration and exploitation through pheromone trails and heuristic information.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.960166597366333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The heuristic function uses an ant colony optimization-inspired approach to construct a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information (inverse of combined distances), while ensuring feasibility through a greedy local search with adaptive pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9689933896064759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The algorithm combines ant colony optimization with elitist pheromone updates to intelligently select and improve solutions from the archive by constructing new tours based on pheromone trails and heuristic information, while ensuring feasibility through careful node selection and pheromone evaporation and reinforcement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7996079683303833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm combines ant colony optimization with elitist pheromone updates to intelligently explore and exploit the solution space of the bi-objective TSP, dynamically balancing exploration and exploitation through pheromone trails and heuristic information while ensuring feasibility through random tour construction and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8995777010917664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, where pheromone trails guide the construction of a new neighbor solution with a hybrid local search strategy combining probabilistic selection and elitist pheromone updates to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            1.092167901992798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization (ACO) inspired approach, combining pheromone trails with heuristic information to construct a new neighbor solution through a probabilistic local search strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.817217481136322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The algorithm uses an ant colony optimization-inspired local search that constructs a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while dynamically updating the pheromone matrix using elitist solutions from the archive to guide the search toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7692306160926818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The algorithm combines ant colony optimization with adaptive pheromone updates to intelligently select and improve solutions from the archive by constructing new tours based on pheromone trails and heuristic information, while ensuring feasibility through careful node selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7906898975372314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, combining pheromone trails with heuristic information to construct a neighbor solution through a probabilistic selection of nodes, while maintaining feasibility through careful edge updates and ensuring no revisits.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8201164245605469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The proposed algorithm is a hybrid local search strategy that combines ant colony optimization principles with a novel edge-swapping mechanism to intelligently explore the solution space, leveraging pheromone trails and heuristic information to guide the search toward promising regions while ensuring feasibility through a carefully designed neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7873252153396606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{A hybrid ant colony optimization (ACO) with adaptive pheromone updates, where solutions from the archive guide the construction of new tours by balancing pheromone trails and heuristic information (distance-based), while ensuring feasibility through a greedy selection process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7859198689460755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The heuristic function 'select_neighbor' uses an ant colony optimization-inspired approach to construct a new solution by probabilistically choosing nodes based on pheromone trails and heuristic information, while maintaining feasibility through careful node selection and pheromone updates from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8314296245574951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to construct a neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through a set of visited nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7493587732315063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The algorithm combines ant colony optimization with a novel hybrid local search that intelligently selects promising solutions from the archive, applies a randomized construction process inspired by ant behavior, and updates pheromones to guide future searches while ensuring feasibility through careful edge selection and probabilistic neighbor selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8442208051681519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The algorithm combines ant colony optimization principles with elitist pheromone updates to select and improve solutions by constructing a tour probabilistically weighted by pheromone trails and heuristic information, while periodically reinforcing high-quality solutions from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8053223252296448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm combines ant colony optimization with a novel local search operator that selectively reorders segments of the tour based on pheromone and heuristic information, ensuring feasibility while balancing exploration and exploitation of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search operator ----\n    new_tour = tour.copy()\n    for _ in range(10):  # number of local search iterations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # reverse segment\n        else:\n            segment = [segment[-1]] + segment[:-1]  # rotate segment\n        new_tour = new_tour[:i] + segment + new_tour[j:]\n\n    return np.array(new_tour)\n\n",
        "score": [
            0.0,
            0.4758838891983032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search operator ----\n    new_tour = tour.copy()\n    for _ in range(10):  # number of local search iterations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # reverse segment\n        else:\n            segment = [segment[-1]] + segment[:-1]  # rotate segment\n        new_tour = new_tour[:i] + segment + new_tour[j:]\n\n    return np.array(new_tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive using a hybrid approach combining ant colony optimization (ACO) principles with dynamic pheromone updates to explore high-quality neighbors through probabilistic edge selection, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7580014824867248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A hybrid ant colony optimization (ACO) approach that intelligently selects solutions from the archive, leverages pheromone trails and heuristic information to construct new tours, and updates pheromones based on elitist archive solutions to guide the search toward Pareto-optimal regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8876922845840454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{A novel hybrid local search operator combines an ant colony optimization-inspired selection with a dynamic edge-swap mechanism that prioritizes high-impact moves based on both objective distances and pheromone trails, ensuring feasibility and diversity in the generated neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9324873805046081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This heuristic function uses a hybrid ant colony optimization approach with a novel local search strategy that combines pheromone-guided exploration with adaptive neighborhood selection to generate high-quality neighbor solutions for the bi-objective TSP, ensuring feasibility through intelligent random selection and pheromone-based updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search: hybrid of 3-opt and adaptive mutation ----\n    if random.random() < 0.3:\n        # Adaptive 3-opt: select three random edges and attempt to reconnect\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_tour = tour[:a] + tour[b:c+1] + tour[a:b] + tour[c+1:]\n        if len(set(new_tour)) == n:\n            tour = new_tour\n\n    if random.random() < 0.2:\n        # Adaptive mutation: randomly swap two nodes\n        i, j = random.sample(range(n), 2)\n        tour[i], tour[j] = tour[j], tour[i]\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.6814270496368409
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search: hybrid of 3-opt and adaptive mutation ----\n    if random.random() < 0.3:\n        # Adaptive 3-opt: select three random edges and attempt to reconnect\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_tour = tour[:a] + tour[b:c+1] + tour[a:b] + tour[c+1:]\n        if len(set(new_tour)) == n:\n            tour = new_tour\n\n    if random.random() < 0.2:\n        # Adaptive mutation: randomly swap two nodes\n        i, j = random.sample(range(n), 2)\n        tour[i], tour[j] = tour[j], tour[i]\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm combines ant colony optimization with a novel local search strategy that adaptively selects and modifies segments of the tour based on both objective-specific distance matrices and pheromone trails, ensuring feasibility and promoting diverse high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- adaptive local search with multi-objective awareness ----\n    tour = np.array(tour)\n    for _ in range(5):  # limit iterations to prevent excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = tour[a:b]\n\n        # reverse segment with probability based on multi-objective improvement\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # insert segment at a new position\n        new_pos = random.randint(0, n - len(segment))\n        new_tour = np.concatenate([tour[:new_pos], segment, tour[new_pos:]])\n        new_tour = np.unique(new_tour, return_index=True)[1]\n        new_tour = np.concatenate([new_tour, np.setdiff1d(np.arange(n), new_tour)])\n        tour = new_tour\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return tour\n\n",
        "score": [
            0.0,
            0.5410660862922668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- adaptive local search with multi-objective awareness ----\n    tour = np.array(tour)\n    for _ in range(5):  # limit iterations to prevent excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = tour[a:b]\n\n        # reverse segment with probability based on multi-objective improvement\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # insert segment at a new position\n        new_pos = random.randint(0, n - len(segment))\n        new_tour = np.concatenate([tour[:new_pos], segment, tour[new_pos:]])\n        new_tour = np.unique(new_tour, return_index=True)[1]\n        new_tour = np.concatenate([new_tour, np.setdiff1d(np.arange(n), new_tour)])\n        tour = new_tour\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm uses an ant colony optimization-inspired approach to select a parent solution from the archive, constructs a new solution by probabilistically choosing edges based on pheromone trails and heuristic information, and updates the pheromone matrix to guide future searches toward high-quality regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both objectives\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone influence\n    beta = 2.0   # Heuristic influence\n    rho = 0.1    # Evaporation rate\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            1.0023545265197753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Hybrid heuristic combining both objectives\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone influence\n    beta = 2.0   # Heuristic influence\n    rho = 0.1    # Evaporation rate\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{The algorithm combines ant colony optimization principles with an elitist pheromone update strategy to probabilistically construct a neighbor solution while prioritizing promising regions of the solution space, guided by both heuristic information and pheromone trails, ensuring feasibility through careful node selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8231087446212768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This heuristic function selects a promising solution from the archive using a pheromone-based ant colony optimization approach, then constructs a neighbor solution by probabilistically choosing edges based on pheromone trails and heuristic information, while ensuring feasibility through a novel edge-selection strategy that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8123157858848572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This heuristic function employs an ant colony optimization-inspired approach to intelligently select and improve a solution from the archive by combining pheromone trails with problem-specific heuristics, while ensuring feasibility through a constructive tour-building process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.776582396030426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A hybrid local search heuristic that combines ant colony optimization principles with a novel edge insertion strategy to intelligently select and improve solutions from the archive while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8381249308586121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The heuristic function 'select_neighbor' uses an ant colony optimization-inspired approach to intelligently select and modify a solution from the archive, combining pheromone trails, heuristic information, and elitist updates to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8368139386177063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The novel local search strategy combines an ant colony optimization (ACO) approach with a dynamic heuristic to probabilistically select and improve solutions from the archive, while maintaining feasibility through careful edge swaps and pheromone updates to guide exploration in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.8479607224464416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm combines ant colony optimization principles with elitist pheromone updates from the archive to intelligently select and perturb solutions, using a hybrid of probabilistic and heuristic-based neighborhood exploration to generate high-quality bi-objective TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9803140044212342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm combines ant colony optimization principles with elitist pheromone updates from the archive to intelligently select and perturb solutions, using a hybrid of probabilistic and heuristic-based neighborhood exploration to generate high-quality bi-objective TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9803140044212342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm combines ant colony optimization principles with elitist pheromone updates from the archive to intelligently select and perturb solutions, using a hybrid of probabilistic and heuristic-based neighborhood exploration to generate high-quality bi-objective TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9803140044212342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search heuristic combines ant colony optimization with a custom edge-swapping strategy to intelligently select and improve TSP solutions by balancing pheromone-guided exploration and distance-aware exploitation, ensuring feasibility while diversifying the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9985862970352173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm combines ant colony optimization with an elitist pheromone update strategy to intelligently select and improve solutions by constructing tours probabilistically guided by pheromone trails and heuristic information, while ensuring feasibility through careful node selection and pheromone evaporation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            1.102376115322113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A hybrid ant colony optimization (ACO) with adaptive local search that combines pheromone-based exploration with objective-aware selection to generate high-quality TSP tours by dynamically balancing exploration and exploitation using pheromone trails and heuristic information from both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9062053442001343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A hybrid ant colony optimization (ACO) with adaptive local search that combines pheromone-based exploration with objective-aware selection to generate high-quality TSP tours by dynamically balancing exploration and exploitation using pheromone trails and heuristic information from both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.9062053442001343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a solution from the archive based on pheromone-guided probabilistic selection, then constructs a new neighbor solution using an ant colony optimization-inspired approach with adaptive pheromone updates and heuristic guidance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7447006106376648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a solution from the archive based on pheromone-guided probabilistic selection, then constructs a new neighbor solution using an ant colony optimization-inspired approach with adaptive pheromone updates and heuristic guidance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7447006106376648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function selects a solution from the archive based on pheromone-guided probabilistic selection, then constructs a new neighbor solution using an ant colony optimization-inspired approach with adaptive pheromone updates and heuristic guidance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            0.0,
            0.7447006106376648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to select a promising solution from the archive, then applies a hybrid local search combining edge insertion with a novel segment-based perturbation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1     # Evaporation rate\n\n    # Calculate heuristic information\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on pheromone and heuristic\n    selected_sol = None\n    max_score = -np.inf\n    for sol, obj in archive:\n        score = 0.0\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            score += pheromone[a, b] * heuristic[a, b]\n        if score > max_score:\n            max_score = score\n            selected_sol = sol.copy()\n\n    # Hybrid local search: segment-based perturbation\n    tour = selected_sol.copy()\n    if len(tour) > 3:\n        # Randomly select a segment to perturb\n        seg_start = random.randint(0, n - 2)\n        seg_length = min(random.randint(2, n // 3), n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        # Extract the segment and reverse it\n        segment = tour[seg_start:seg_end+1]\n        reversed_segment = segment[::-1]\n        tour[seg_start:seg_end+1] = reversed_segment\n\n        # Apply edge insertion to improve the segment\n        for _ in range(2):  # Perform 2 insertions\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove edge (i, i+1)\n                removed = tour[i]\n                tour = np.delete(tour, i)\n                # Insert at position j\n                tour = np.insert(tour, j, removed)\n\n    # Ensure the solution is valid\n    assert len(tour) == n and len(set(tour)) == n, \"Invalid tour generated\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = tour[k]\n        b = tour[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (obj[0] + obj[1])\n        pheromone[b, a] += 1.0 / (obj[0] + obj[1])\n\n    return tour\n\n",
        "score": [
            -0.7650078931011006,
            0.2610738635063171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1     # Evaporation rate\n\n    # Calculate heuristic information\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on pheromone and heuristic\n    selected_sol = None\n    max_score = -np.inf\n    for sol, obj in archive:\n        score = 0.0\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            score += pheromone[a, b] * heuristic[a, b]\n        if score > max_score:\n            max_score = score\n            selected_sol = sol.copy()\n\n    # Hybrid local search: segment-based perturbation\n    tour = selected_sol.copy()\n    if len(tour) > 3:\n        # Randomly select a segment to perturb\n        seg_start = random.randint(0, n - 2)\n        seg_length = min(random.randint(2, n // 3), n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        # Extract the segment and reverse it\n        segment = tour[seg_start:seg_end+1]\n        reversed_segment = segment[::-1]\n        tour[seg_start:seg_end+1] = reversed_segment\n\n        # Apply edge insertion to improve the segment\n        for _ in range(2):  # Perform 2 insertions\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove edge (i, i+1)\n                removed = tour[i]\n                tour = np.delete(tour, i)\n                # Insert at position j\n                tour = np.insert(tour, j, removed)\n\n    # Ensure the solution is valid\n    assert len(tour) == n and len(set(tour)) == n, \"Invalid tour generated\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = tour[k]\n        b = tour[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (obj[0] + obj[1])\n        pheromone[b, a] += 1.0 / (obj[0] + obj[1])\n\n    return tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to select a promising solution from the archive, then applies a hybrid local search combining edge insertion with a novel segment-based perturbation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1     # Evaporation rate\n\n    # Calculate heuristic information\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on pheromone and heuristic\n    selected_sol = None\n    max_score = -np.inf\n    for sol, obj in archive:\n        score = 0.0\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            score += pheromone[a, b] * heuristic[a, b]\n        if score > max_score:\n            max_score = score\n            selected_sol = sol.copy()\n\n    # Hybrid local search: segment-based perturbation\n    tour = selected_sol.copy()\n    if len(tour) > 3:\n        # Randomly select a segment to perturb\n        seg_start = random.randint(0, n - 2)\n        seg_length = min(random.randint(2, n // 3), n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        # Extract the segment and reverse it\n        segment = tour[seg_start:seg_end+1]\n        reversed_segment = segment[::-1]\n        tour[seg_start:seg_end+1] = reversed_segment\n\n        # Apply edge insertion to improve the segment\n        for _ in range(2):  # Perform 2 insertions\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove edge (i, i+1)\n                removed = tour[i]\n                tour = np.delete(tour, i)\n                # Insert at position j\n                tour = np.insert(tour, j, removed)\n\n    # Ensure the solution is valid\n    assert len(tour) == n and len(set(tour)) == n, \"Invalid tour generated\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = tour[k]\n        b = tour[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (obj[0] + obj[1])\n        pheromone[b, a] += 1.0 / (obj[0] + obj[1])\n\n    return tour\n\n",
        "score": [
            -0.7650078931011006,
            0.2610738635063171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1     # Evaporation rate\n\n    # Calculate heuristic information\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on pheromone and heuristic\n    selected_sol = None\n    max_score = -np.inf\n    for sol, obj in archive:\n        score = 0.0\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            score += pheromone[a, b] * heuristic[a, b]\n        if score > max_score:\n            max_score = score\n            selected_sol = sol.copy()\n\n    # Hybrid local search: segment-based perturbation\n    tour = selected_sol.copy()\n    if len(tour) > 3:\n        # Randomly select a segment to perturb\n        seg_start = random.randint(0, n - 2)\n        seg_length = min(random.randint(2, n // 3), n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        # Extract the segment and reverse it\n        segment = tour[seg_start:seg_end+1]\n        reversed_segment = segment[::-1]\n        tour[seg_start:seg_end+1] = reversed_segment\n\n        # Apply edge insertion to improve the segment\n        for _ in range(2):  # Perform 2 insertions\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove edge (i, i+1)\n                removed = tour[i]\n                tour = np.delete(tour, i)\n                # Insert at position j\n                tour = np.insert(tour, j, removed)\n\n    # Ensure the solution is valid\n    assert len(tour) == n and len(set(tour)) == n, \"Invalid tour generated\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = tour[k]\n        b = tour[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (obj[0] + obj[1])\n        pheromone[b, a] += 1.0 / (obj[0] + obj[1])\n\n    return tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to select a promising solution from the archive, then applies a hybrid local search combining edge insertion with a novel segment-based perturbation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1     # Evaporation rate\n\n    # Calculate heuristic information\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on pheromone and heuristic\n    selected_sol = None\n    max_score = -np.inf\n    for sol, obj in archive:\n        score = 0.0\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            score += pheromone[a, b] * heuristic[a, b]\n        if score > max_score:\n            max_score = score\n            selected_sol = sol.copy()\n\n    # Hybrid local search: segment-based perturbation\n    tour = selected_sol.copy()\n    if len(tour) > 3:\n        # Randomly select a segment to perturb\n        seg_start = random.randint(0, n - 2)\n        seg_length = min(random.randint(2, n // 3), n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        # Extract the segment and reverse it\n        segment = tour[seg_start:seg_end+1]\n        reversed_segment = segment[::-1]\n        tour[seg_start:seg_end+1] = reversed_segment\n\n        # Apply edge insertion to improve the segment\n        for _ in range(2):  # Perform 2 insertions\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove edge (i, i+1)\n                removed = tour[i]\n                tour = np.delete(tour, i)\n                # Insert at position j\n                tour = np.insert(tour, j, removed)\n\n    # Ensure the solution is valid\n    assert len(tour) == n and len(set(tour)) == n, \"Invalid tour generated\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = tour[k]\n        b = tour[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (obj[0] + obj[1])\n        pheromone[b, a] += 1.0 / (obj[0] + obj[1])\n\n    return tour\n\n",
        "score": [
            -0.7650078931011006,
            0.2610738635063171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1     # Evaporation rate\n\n    # Calculate heuristic information\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Select a solution from archive based on pheromone and heuristic\n    selected_sol = None\n    max_score = -np.inf\n    for sol, obj in archive:\n        score = 0.0\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            score += pheromone[a, b] * heuristic[a, b]\n        if score > max_score:\n            max_score = score\n            selected_sol = sol.copy()\n\n    # Hybrid local search: segment-based perturbation\n    tour = selected_sol.copy()\n    if len(tour) > 3:\n        # Randomly select a segment to perturb\n        seg_start = random.randint(0, n - 2)\n        seg_length = min(random.randint(2, n // 3), n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        # Extract the segment and reverse it\n        segment = tour[seg_start:seg_end+1]\n        reversed_segment = segment[::-1]\n        tour[seg_start:seg_end+1] = reversed_segment\n\n        # Apply edge insertion to improve the segment\n        for _ in range(2):  # Perform 2 insertions\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove edge (i, i+1)\n                removed = tour[i]\n                tour = np.delete(tour, i)\n                # Insert at position j\n                tour = np.insert(tour, j, removed)\n\n    # Ensure the solution is valid\n    assert len(tour) == n and len(set(tour)) == n, \"Invalid tour generated\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for k in range(n):\n        a = tour[k]\n        b = tour[(k + 1) % n]\n        pheromone[a, b] += 1.0 / (obj[0] + obj[1])\n        pheromone[b, a] += 1.0 / (obj[0] + obj[1])\n\n    return tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm combines an ant colony optimization-inspired construction heuristic with a pheromone-based local search to generate high-quality neighbors by probabilistically selecting nodes based on pheromone trails and heuristic information (inverse of combined distance), while ensuring feasibility through dynamic updates of the pheromone matrix.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7476830212982043,
            0.7894018292427063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to construct a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while maintaining feasibility through an elitist pheromone update from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7897092754997883,
            0.8815446257591247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to construct a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while maintaining feasibility through an elitist pheromone update from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7897092754997883,
            0.8815446257591247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm combines ant colony optimization with elitist pheromone updates to intelligently select and improve solutions from the archive, using a hybrid heuristic that balances pheromone trails and edge costs to explore high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Construct solution like an ant\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Pheromone update from archive (elitist)\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.793028771770188,
            0.8716037392616272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Construct solution like an ant\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Pheromone update from archive (elitist)\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm combines ant colony optimization with elitist pheromone updates to intelligently select and improve solutions from the archive, using a hybrid heuristic that balances pheromone trails and edge costs to explore high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Construct solution like an ant\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Pheromone update from archive (elitist)\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.793028771770188,
            0.8716037392616272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Construct solution like an ant\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Pheromone update from archive (elitist)\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm combines ant colony optimization principles with an elitist pheromone update to intelligently select and improve solutions by constructing tours probabilistically based on pheromone trails and heuristic information, while reinforcing promising edges from the archive to guide future exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7519756951009249,
            0.8444967031478882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization (ACO) inspired approach, where solutions are probabilistically chosen based on pheromone trails and heuristic information, followed by a hybrid local search combining ACO and 3-opt moves to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1    # Evaporation rate\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- Hybrid local search: 3-opt with ACO guidance ----\n    def calculate_cost(tour):\n        cost1 = sum(distance_matrix_1[tour[i], tour[(i + 1) % n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[tour[i], tour[(i + 1) % n]] for i in range(n))\n        return cost1 + cost2\n\n    best_tour = tour.copy()\n    best_cost = calculate_cost(best_tour)\n\n    for _ in range(10):  # Number of 3-opt iterations\n        # Randomly select 3 edges to reverse\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Generate 3 new tours by reversing segments\n        new_tours = [\n            tour[:a] + tour[a:b][::-1] + tour[b:],\n            tour[:b] + tour[b:c][::-1] + tour[c:],\n            tour[:a] + tour[a:c][::-1] + tour[c:]\n        ]\n\n        # Evaluate and keep the best\n        for new_tour in new_tours:\n            current_cost = calculate_cost(new_tour)\n            if current_cost < best_cost:\n                best_tour = new_tour.copy()\n                best_cost = current_cost\n\n    return np.array(best_tour)\n\n",
        "score": [
            -0.7710722953364149,
            1.2941365122795105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    # Parameters for ACO\n    alpha = 1.0  # Pheromone importance\n    beta = 2.0   # Heuristic importance\n    rho = 0.1    # Evaporation rate\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- Hybrid local search: 3-opt with ACO guidance ----\n    def calculate_cost(tour):\n        cost1 = sum(distance_matrix_1[tour[i], tour[(i + 1) % n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[tour[i], tour[(i + 1) % n]] for i in range(n))\n        return cost1 + cost2\n\n    best_tour = tour.copy()\n    best_cost = calculate_cost(best_tour)\n\n    for _ in range(10):  # Number of 3-opt iterations\n        # Randomly select 3 edges to reverse\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Generate 3 new tours by reversing segments\n        new_tours = [\n            tour[:a] + tour[a:b][::-1] + tour[b:],\n            tour[:b] + tour[b:c][::-1] + tour[c:],\n            tour[:a] + tour[a:c][::-1] + tour[c:]\n        ]\n\n        # Evaluate and keep the best\n        for new_tour in new_tours:\n            current_cost = calculate_cost(new_tour)\n            if current_cost < best_cost:\n                best_tour = new_tour.copy()\n                best_cost = current_cost\n\n    return np.array(best_tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm hybridizes ant colony optimization with a novel local search that dynamically adapts pheromone trails based on archive solutions, while ensuring feasibility through constrained random walks and elitist pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.804963733984307,
            0.8477068781852722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm hybridizes ant colony optimization with a novel local search that dynamically adapts pheromone trails based on archive solutions, while ensuring feasibility through constrained random walks and elitist pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.804963733984307,
            0.8477068781852722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The heuristic function employs an ant colony optimization-inspired approach to intelligently select a neighbor solution from the archive, where each ant constructs a tour by balancing pheromone trails and heuristic information (inverse of combined distance costs), followed by elitist pheromone updates to guide future explorations toward promising regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7691948828416464,
            0.8137092232704163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This heuristic function employs an ant colony optimization-inspired approach with a hybrid local search strategy that dynamically balances exploration and exploitation by combining pheromone trails with problem-specific heuristics, while ensuring feasibility through intelligent node selection and elitist pheromone updates from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7967012494328459,
            0.8345012784004211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A hybrid adaptive local search algorithm that combines ant colony optimization principles with a dynamic edge selection strategy to generate high-quality neighbors by probabilistically balancing pheromone trails and heuristic information while ensuring feasibility through careful edge swaps and path reconstruction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8656883004631742,
            0.890949547290802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A hybrid adaptive local search algorithm that combines ant colony optimization principles with a dynamic edge selection strategy to generate high-quality neighbors by probabilistically balancing pheromone trails and heuristic information while ensuring feasibility through careful edge swaps and path reconstruction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8656883004631742,
            0.890949547290802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm combines ant colony optimization with a novel heuristic-guided local search to generate high-quality neighbors by dynamically balancing exploration and exploitation through pheromone trails and problem-specific heuristics, while ensuring feasibility through careful edge selection and visited tracking.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.71769288695982,
            0.9065547585487366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm combines ant colony optimization with a hybrid local search strategy, where solutions are constructed probabilistically based on pheromone trails and heuristic information, followed by elitist pheromone updates to guide the search toward promising regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7798487611565382,
            0.8786313772201538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm combines ant colony optimization with a greedy construction heuristic to intelligently select and perturb solutions from the archive, using pheromone trails and adaptive edge selection to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8013867407798246,
            0.8082182765007019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This heuristic function combines ACO-inspired selection with a novel local search strategy that adaptively balances exploration and exploitation by leveraging pheromone trails and objective-based heuristic information to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8492273672201694,
            0.8657723426818847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This function implements a hybrid ant colony optimization (ACO) approach that intelligently selects a solution from the archive, constructs a neighbor tour using probabilistic selection based on pheromone trails and heuristic information, and updates the pheromone trails to guide future searches toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8268968154297808,
            0.7984483361244201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm combines ant colony optimization principles with a novel local search strategy that adaptively refines solutions by balancing pheromone-based exploration and heuristic-guided exploitation, while ensuring feasibility through a constrained neighborhood exploration process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search: adaptive segment reversal with objective-aware selection ----\n    best_tour = np.array(tour)\n    best_cost = sum(distance_matrix_1[best_tour[i], best_tour[(i+1)%n]] + distance_matrix_2[best_tour[i], best_tour[(i+1)%n]] for i in range(n))\n\n    for _ in range(10):  # Limited iterations for efficiency\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_tour = np.concatenate([best_tour[:a], best_tour[a:b][::-1], best_tour[b:]])\n\n        # Evaluate new tour\n        new_cost = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] + distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n        # Accept if improvement is found\n        if new_cost < best_cost:\n            best_tour = new_tour\n            best_cost = new_cost\n\n    return best_tour\n\n",
        "score": [
            -0.793768556439333,
            1.0740036725997926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search: adaptive segment reversal with objective-aware selection ----\n    best_tour = np.array(tour)\n    best_cost = sum(distance_matrix_1[best_tour[i], best_tour[(i+1)%n]] + distance_matrix_2[best_tour[i], best_tour[(i+1)%n]] for i in range(n))\n\n    for _ in range(10):  # Limited iterations for efficiency\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_tour = np.concatenate([best_tour[:a], best_tour[a:b][::-1], best_tour[b:]])\n\n        # Evaluate new tour\n        new_cost = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] + distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n        # Accept if improvement is found\n        if new_cost < best_cost:\n            best_tour = new_tour\n            best_cost = new_cost\n\n    return best_tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The algorithm employs an ant colony optimization-inspired heuristic to select a promising solution from the archive, constructs a neighbor solution using a biased random walk that balances pheromone trails and heuristic information, and updates pheromone trails to guide future searches toward improved regions of the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8521328577596264,
            0.8332980990409851
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm combines ant colony optimization principles with elitist pheromone updates to generate high-quality neighbor solutions by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through careful node selection and pheromone evaporation and deposition.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7435129384003715,
            0.846228814125061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This algorithm implements an Ant Colony Optimization-inspired local search that selects a solution from the archive, constructs a neighbor tour using pheromone and heuristic information, and updates the pheromone matrix based on the archive's elitist solutions to guide future searches toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7796523381175445,
            0.7614809274673462
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The heuristic function uses a hybrid ant colony optimization (ACO) approach with a novel local search operator that combines pheromone-based path selection with adaptive heuristic weights, ensuring feasible tours while exploring the solution space more effectively than standard 2-opt methods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8664554245944528,
            0.887006402015686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The heuristic function uses a hybrid ant colony optimization (ACO) approach with a novel local search operator that combines pheromone-based path selection with adaptive heuristic weights, ensuring feasible tours while exploring the solution space more effectively than standard 2-opt methods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8664554245944528,
            0.887006402015686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This heuristic combines an ant colony optimization-inspired neighbor selection with a dynamic pheromone update mechanism to guide the search toward promising regions of the solution space, while ensuring feasibility through a constructive approach that avoids revisiting nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8391945864621478,
            0.7662316918373108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This heuristic combines ant colony optimization principles with elitist pheromone updates to intelligently select and improve solutions by constructing new tours probabilistically weighted by pheromone trails and heuristic information, while maintaining feasibility through careful node selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8874422857486716,
            0.8221628308296204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This heuristic combines ant colony optimization principles with elitist pheromone updates to intelligently select and improve solutions by constructing new tours probabilistically weighted by pheromone trails and heuristic information, while maintaining feasibility through careful node selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8874422857486716,
            0.8221628308296204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The heuristic function combines ant colony optimization with a novel local search strategy that intelligently selects promising solutions from the archive, applies a hybrid operator that combines edge exchange with path relinking, and ensures feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- hybrid local search: edge exchange + path relinking ----\n    current_sol = np.array(tour)\n    best_sol = current_sol.copy()\n    best_cost = sum(distance_matrix_1[current_sol[i], current_sol[(i+1)%n]] + distance_matrix_2[current_sol[i], current_sol[(i+1)%n]] for i in range(n))\n\n    # Select a reference solution from archive with probability proportional to inverse cost\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    probs = [1.0 / (cost + 1e-12) for cost in costs]\n    probs = np.array(probs) / np.sum(probs)\n    ref_sol, _ = random.choices(archive, weights=probs)[0]\n\n    # Path relinking: interpolate between current and reference solution\n    for k in range(1, n):\n        # Create a candidate solution by combining segments from both tours\n        candidate = []\n        visited = set()\n        i = 0\n        while len(candidate) < n:\n            # Alternate between current and reference solution segments\n            if i % 2 == 0:\n                # Take a segment from current solution\n                start_idx = i % n\n                segment_length = random.randint(1, max(1, n // 4))\n                for _ in range(segment_length):\n                    if current_sol[start_idx] not in visited:\n                        candidate.append(current_sol[start_idx])\n                        visited.add(current_sol[start_idx])\n                    start_idx = (start_idx + 1) % n\n            else:\n                # Take a segment from reference solution\n                start_idx = i % n\n                segment_length = random.randint(1, max(1, n // 4))\n                for _ in range(segment_length):\n                    if ref_sol[start_idx] not in visited:\n                        candidate.append(ref_sol[start_idx])\n                        visited.add(ref_sol[start_idx])\n                    start_idx = (start_idx + 1) % n\n            i += 1\n\n        # Ensure all nodes are visited (last resort: complete with remaining nodes)\n        remaining = [node for node in range(n) if node not in visited]\n        candidate.extend(remaining)\n\n        # Evaluate candidate\n        candidate_cost = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] + distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        if candidate_cost < best_cost:\n            best_sol = np.array(candidate)\n            best_cost = candidate_cost\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return best_sol\n\n",
        "score": [
            -0.8153265616521302,
            1.603477370738983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- hybrid local search: edge exchange + path relinking ----\n    current_sol = np.array(tour)\n    best_sol = current_sol.copy()\n    best_cost = sum(distance_matrix_1[current_sol[i], current_sol[(i+1)%n]] + distance_matrix_2[current_sol[i], current_sol[(i+1)%n]] for i in range(n))\n\n    # Select a reference solution from archive with probability proportional to inverse cost\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    probs = [1.0 / (cost + 1e-12) for cost in costs]\n    probs = np.array(probs) / np.sum(probs)\n    ref_sol, _ = random.choices(archive, weights=probs)[0]\n\n    # Path relinking: interpolate between current and reference solution\n    for k in range(1, n):\n        # Create a candidate solution by combining segments from both tours\n        candidate = []\n        visited = set()\n        i = 0\n        while len(candidate) < n:\n            # Alternate between current and reference solution segments\n            if i % 2 == 0:\n                # Take a segment from current solution\n                start_idx = i % n\n                segment_length = random.randint(1, max(1, n // 4))\n                for _ in range(segment_length):\n                    if current_sol[start_idx] not in visited:\n                        candidate.append(current_sol[start_idx])\n                        visited.add(current_sol[start_idx])\n                    start_idx = (start_idx + 1) % n\n            else:\n                # Take a segment from reference solution\n                start_idx = i % n\n                segment_length = random.randint(1, max(1, n // 4))\n                for _ in range(segment_length):\n                    if ref_sol[start_idx] not in visited:\n                        candidate.append(ref_sol[start_idx])\n                        visited.add(ref_sol[start_idx])\n                    start_idx = (start_idx + 1) % n\n            i += 1\n\n        # Ensure all nodes are visited (last resort: complete with remaining nodes)\n        remaining = [node for node in range(n) if node not in visited]\n        candidate.extend(remaining)\n\n        # Evaluate candidate\n        candidate_cost = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] + distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        if candidate_cost < best_cost:\n            best_sol = np.array(candidate)\n            best_cost = candidate_cost\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return best_sol\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm uses an ant colony system-inspired approach to construct a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while maintaining feasibility and updating pheromones from the archive to guide future selections.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.881195644494548,
            0.874874746799469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A hybrid adaptive local search strategy combining ant colony optimization principles with a novel edge-based perturbation mechanism to intelligently explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel edge-based perturbation ----\n    tour = np.array(tour)\n    k = random.randint(2, min(5, n // 2))\n    indices = random.sample(range(n), k)\n    indices.sort()\n\n    new_tour = []\n    for i in range(len(indices)):\n        start_idx = indices[i]\n        end_idx = indices[(i + 1) % len(indices)]\n        if start_idx < end_idx:\n            segment = tour[start_idx:end_idx]\n        else:\n            segment = np.concatenate([tour[start_idx:], tour[:end_idx]])\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        new_tour.extend(segment)\n\n    remaining_nodes = set(range(n)) - set(new_tour)\n    if remaining_nodes:\n        insertion_point = random.randint(0, len(new_tour))\n        new_tour = np.concatenate([new_tour[:insertion_point], list(remaining_nodes), new_tour[insertion_point:]])\n\n    return np.array(new_tour)\n\n",
        "score": [
            -0.8169777683362739,
            0.6456170201301574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel edge-based perturbation ----\n    tour = np.array(tour)\n    k = random.randint(2, min(5, n // 2))\n    indices = random.sample(range(n), k)\n    indices.sort()\n\n    new_tour = []\n    for i in range(len(indices)):\n        start_idx = indices[i]\n        end_idx = indices[(i + 1) % len(indices)]\n        if start_idx < end_idx:\n            segment = tour[start_idx:end_idx]\n        else:\n            segment = np.concatenate([tour[start_idx:], tour[:end_idx]])\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        new_tour.extend(segment)\n\n    remaining_nodes = set(range(n)) - set(new_tour)\n    if remaining_nodes:\n        insertion_point = random.randint(0, len(new_tour))\n        new_tour = np.concatenate([new_tour[:insertion_point], list(remaining_nodes), new_tour[insertion_point:]])\n\n    return np.array(new_tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{The algorithm combines an ant colony optimization (ACO) approach with a heuristic-based selection of promising solutions from the archive, using pheromone trails and local distance information to guide the construction of a new neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7833614095339001,
            0.9199478983879089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This heuristic function combines ant colony optimization principles with an elitist pheromone update strategy to intelligently select and improve solutions from the archive, using a hybrid of probabilistic selection and pheromone-guided local search to explore high-quality neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7670803532233316,
            0.8968068122863769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to select a parent solution from the archive, where solutions with lower combined objective costs contribute more to the pheromone trails, and then constructs a new neighbor solution by probabilistically traversing nodes based on pheromone and heuristic information (inverse of combined distances), while ensuring the solution remains a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7967837760834393,
            0.8168009757995606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{A hybrid ant colony optimization-inspired local search that intelligently selects a promising solution from the archive, constructs a neighbor tour by probabilistically choosing edges based on pheromone trails and heuristic information, and updates pheromone trails using elitist strategy to guide exploration toward high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.730102877594389,
            0.8761215209960938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm combines ant colony optimization principles with a hybrid local search strategy, leveraging a dynamic pheromone matrix to guide the construction of new solutions while ensuring feasibility through intelligent edge swaps and insertions to balance exploration and exploitation across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8295616549447224,
            0.8323252558708191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm combines ant colony optimization with elitist pheromone updates to intelligently select and improve solutions by probabilistically constructing tours based on pheromone trails and heuristic information, while leveraging the archive to guide the search toward higher-quality regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8054415464189904,
            1.0116687536239624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The algorithm uses an ant colony optimization-inspired heuristic to select and modify a solution from the archive, combining pheromone trails, heuristic information, and elitist updates to guide the search toward high-quality multi-objective TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7713486213837986,
            0.9819383740425109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The algorithm combines ant colony optimization with elitist pheromone updates to intelligently select and improve solutions by leveraging pheromone trails and heuristic information to guide the exploration of promising neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7851968639632624,
            0.8513479709625245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The heuristic function employs an ant colony optimization-inspired approach to construct a neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through a guided local search strategy that combines exploration and exploitation of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8095393514217794,
            1.004805612564087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A hybrid ant colony optimization (ACO) approach with adaptive pheromone updates and heuristic bias, combining elitist selection from the archive, probabilistic neighbor selection, and dynamic pheromone evaporation to balance exploration and exploitation while ensuring feasibility through constrained random walks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7806070944270628,
            0.902475917339325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The algorithm combines ant colony optimization principles with elitist pheromone updates to intelligently select and improve solutions from the archive, using a probabilistic approach that balances pheromone trails and heuristic information to construct high-quality neighbor tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- probabilistic selection based on potential ----\n    scores = [1.0 / (obj[0] + obj[1] + 1e-12) for _, obj in archive]\n    probs = np.array(scores)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    selected_tour, _ = archive[selected_idx]\n\n    # ---- hybrid local search: 3-opt with adaptive perturbation ----\n    def apply_3opt(tour, i, j, k):\n        segment1 = tour[i:j]\n        segment2 = tour[j:k]\n        new_tour = np.concatenate([tour[:i], segment2[::-1], segment1[::-1], tour[k:]])\n        return new_tour\n\n    best_tour = selected_tour.copy()\n    improved = True\n    max_iter = 10  # Limit iterations for efficiency\n\n    while improved and max_iter > 0:\n        improved = False\n        max_iter -= 1\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                for k in range(j + 2, n):\n                    if k + 1 >= n:\n                        continue\n\n                    # Evaluate 3-opt move\n                    new_tour = apply_3opt(best_tour, i, j, k)\n                    new_cost1 = sum(distance_matrix_1[new_tour[l], new_tour[(l + 1) % n]] for l in range(n))\n                    new_cost2 = sum(distance_matrix_2[new_tour[l], new_tour[(l + 1) % n]] for l in range(n))\n\n                    # Accept if at least one objective improves\n                    if (new_cost1 < sum(distance_matrix_1[best_tour[l], best_tour[(l + 1) % n]] for l in range(n)) or\n                        new_cost2 < sum(distance_matrix_2[best_tour[l], best_tour[(l + 1) % n]] for l in range(n))):\n                        best_tour = new_tour\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    # ---- pheromone update with elitism ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive[:3]:  # Consider top 3 solutions\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return best_tour\n\n",
        "score": [
            -0.6659486409236958,
            2.261305046081543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- probabilistic selection based on potential ----\n    scores = [1.0 / (obj[0] + obj[1] + 1e-12) for _, obj in archive]\n    probs = np.array(scores)\n    probs /= probs.sum()\n    selected_idx = random.choices(range(len(archive)), weights=probs)[0]\n    selected_tour, _ = archive[selected_idx]\n\n    # ---- hybrid local search: 3-opt with adaptive perturbation ----\n    def apply_3opt(tour, i, j, k):\n        segment1 = tour[i:j]\n        segment2 = tour[j:k]\n        new_tour = np.concatenate([tour[:i], segment2[::-1], segment1[::-1], tour[k:]])\n        return new_tour\n\n    best_tour = selected_tour.copy()\n    improved = True\n    max_iter = 10  # Limit iterations for efficiency\n\n    while improved and max_iter > 0:\n        improved = False\n        max_iter -= 1\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                for k in range(j + 2, n):\n                    if k + 1 >= n:\n                        continue\n\n                    # Evaluate 3-opt move\n                    new_tour = apply_3opt(best_tour, i, j, k)\n                    new_cost1 = sum(distance_matrix_1[new_tour[l], new_tour[(l + 1) % n]] for l in range(n))\n                    new_cost2 = sum(distance_matrix_2[new_tour[l], new_tour[(l + 1) % n]] for l in range(n))\n\n                    # Accept if at least one objective improves\n                    if (new_cost1 < sum(distance_matrix_1[best_tour[l], best_tour[(l + 1) % n]] for l in range(n)) or\n                        new_cost2 < sum(distance_matrix_2[best_tour[l], best_tour[(l + 1) % n]] for l in range(n))):\n                        best_tour = new_tour\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    # ---- pheromone update with elitism ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive[:3]:  # Consider top 3 solutions\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return best_tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This heuristic function selects a promising solution from the archive by using a hybrid ant colony optimization approach with adaptive pheromone trails and a novel local search operator that combines edge insertion with adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8716963346108708,
            0.8749510288238526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The heuristic function employs an ant colony optimization-inspired approach to construct a neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through a dynamic tour construction process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.812338461020867,
            0.8334210038185119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The algorithm combines an ant colony optimization-inspired heuristic with a dynamic pheromone update mechanism to intelligently explore the solution space, balancing exploration and exploitation through probabilistic selection of neighbors while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Construct solution like an ant\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Pheromone update from archive (elitist)\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8535640227670422,
            0.8928886294364929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Construct solution like an ant\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # Pheromone update from archive (elitist)\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This heuristic function selects a neighbor solution by combining ant colony optimization principles with elitist pheromone updates, where promising solutions from the archive influence the construction of new tours through adaptive probabilistic selection and pheromone trails, while ensuring feasibility through strict node visitation constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8300222799078364,
            0.8300857901573181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This heuristic selects a promising solution from the archive using a hybrid of ant colony optimization and adaptive local search, where the best solutions guide pheromone updates to bias exploration toward high-quality regions, while a novel edge-swap operator with objective-aware perturbation ensures feasible neighbors are generated while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7583820906584732,
            0.8284058690071106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The heuristic function 'select_neighbor' employs an ant colony optimization-inspired approach to construct a new TSP tour by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through a dynamic update of pheromone levels guided by the archive of solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7019912165712892,
            0.8828779816627502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This heuristic function selects a promising solution from the archive, applies a hybrid ant colony optimization-inspired local search to generate a neighbor solution by combining pheromone-based path selection with heuristic information from both distance matrices, and ensures feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.784894195404834,
            0.8697714328765869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{The algorithm combines ant colony optimization with a novel local search that intelligently selects promising solutions from the archive, applies a hybrid of edge exchange and path relinking to generate high-quality neighbors, and updates pheromones based on solution quality to guide future selections.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Intelligent selection: prioritize solutions with high pheromone concentration\n    selected = None\n    max_pheromone = -1\n    for sol, _ in archive:\n        total_pheromone = sum(pheromone[sol[k], sol[(k+1)%n]] for k in range(n))\n        if total_pheromone > max_pheromone:\n            max_pheromone = total_pheromone\n            selected = sol\n\n    # Hybrid local search: path relinking with edge exchange\n    tour = selected.copy()\n    for _ in range(10):  # Limited iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        # Edge exchange\n        new_tour = np.concatenate((tour[:i], tour[j:j+1], tour[i+1:j], tour[i:i+1], tour[j+1:]))\n        # Path relinking: interpolate between current and selected solution\n        if random.random() < 0.5:\n            for k in range(n):\n                if random.random() < 0.3:\n                    idx = (k + random.randint(1, n-1)) % n\n                    tour[k], tour[idx] = tour[idx], tour[k]\n        else:\n            tour = new_tour\n\n    # Ensure feasibility\n    assert len(np.unique(tour)) == n, \"Generated solution is not a valid tour\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return tour\n\n",
        "score": [
            -0.7729097014706495,
            0.35864166021347044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # Intelligent selection: prioritize solutions with high pheromone concentration\n    selected = None\n    max_pheromone = -1\n    for sol, _ in archive:\n        total_pheromone = sum(pheromone[sol[k], sol[(k+1)%n]] for k in range(n))\n        if total_pheromone > max_pheromone:\n            max_pheromone = total_pheromone\n            selected = sol\n\n    # Hybrid local search: path relinking with edge exchange\n    tour = selected.copy()\n    for _ in range(10):  # Limited iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        # Edge exchange\n        new_tour = np.concatenate((tour[:i], tour[j:j+1], tour[i+1:j], tour[i:i+1], tour[j+1:]))\n        # Path relinking: interpolate between current and selected solution\n        if random.random() < 0.5:\n            for k in range(n):\n                if random.random() < 0.3:\n                    idx = (k + random.randint(1, n-1)) % n\n                    tour[k], tour[idx] = tour[idx], tour[k]\n        else:\n            tour = new_tour\n\n    # Ensure feasibility\n    assert len(np.unique(tour)) == n, \"Generated solution is not a valid tour\"\n\n    # Update pheromones\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return tour\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm uses an ant colony optimization-inspired approach to intelligently select and improve solutions by combining pheromone trails with heuristic information to construct new tours, while leveraging an elitist pheromone update strategy to guide the search toward high-quality solutions across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7481019977406421,
            0.9730151176452637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to construct a new neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while maintaining feasibility through careful node selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7697906617025814,
            0.9214834570884705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The heuristic function 'select_neighbor' employs a hybrid approach combining ACO (Ant Colony Optimization) and a novel local search operator that dynamically adjusts edge selection probabilities based on both pheromone trails and heuristic information, while ensuring feasibility through a constructive method and elitist pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8188712798145608,
            0.7275983572006226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This heuristic function selects a neighbor solution using an ant colony optimization-inspired approach, where solutions are constructed probabilistically based on pheromone trails and heuristic information, with elitist pheromone updates from the archive to guide exploration toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7894691941247365,
            0.9201598644256592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The algorithm combines ant colony optimization principles with elitist pheromone updates to construct a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through careful node selection and pheromone evaporation and reinforcement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7574607422807583,
            0.7909209847450256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A hybrid ant colony optimization (ACO) with adaptive pheromone trails and heuristic information to explore the solution space while balancing exploitation and exploration, incorporating elitist updates from the archive to guide the search toward high-quality regions in the bi-objective TSP landscape.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.846204184081266,
            0.8826149940490723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This algorithm combines ant colony optimization with elite solution guidance to intelligently select and improve a TSP tour by leveraging pheromone trails and heuristic information from both objective spaces, while ensuring feasibility through careful neighbor selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7379493110923199,
            0.9713187575340271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The heuristic function employs an ant colony optimization-inspired approach, where solutions are probabilistically constructed based on pheromone trails and heuristic information, with elitist pheromone updates from the archive to guide exploration toward high-quality regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7562438243539589,
            0.9818680286407471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This algorithm combines ant colony optimization with a novel local search strategy that adaptively selects and modifies segments of the tour based on pheromone trails and heuristic information, ensuring feasibility while exploring diverse neighborhoods for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel hybrid local search ----\n    for _ in range(5):\n        # Select a segment to modify\n        seg_start = random.randint(0, n - 1)\n        seg_length = random.randint(2, min(5, n // 2))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            segment = tour[seg_start:seg_end]\n        else:\n            segment = tour[seg_start:] + tour[:seg_end]\n\n        # Reverse the segment (like 2-opt but with adaptive segment length)\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            # Shuffle the segment (novelty)\n            random.shuffle(segment)\n\n        # Reinsert the modified segment\n        if seg_start < seg_end:\n            tour[seg_start:seg_end] = segment\n        else:\n            tour[seg_start:] = segment[:n - seg_start]\n            tour[:seg_end] = segment[n - seg_start:]\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8362358719708649,
            0.48016479015350344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel hybrid local search ----\n    for _ in range(5):\n        # Select a segment to modify\n        seg_start = random.randint(0, n - 1)\n        seg_length = random.randint(2, min(5, n // 2))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            segment = tour[seg_start:seg_end]\n        else:\n            segment = tour[seg_start:] + tour[:seg_end]\n\n        # Reverse the segment (like 2-opt but with adaptive segment length)\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            # Shuffle the segment (novelty)\n            random.shuffle(segment)\n\n        # Reinsert the modified segment\n        if seg_start < seg_end:\n            tour[seg_start:seg_end] = segment\n        else:\n            tour[seg_start:] = segment[:n - seg_start]\n            tour[:seg_end] = segment[n - seg_start:]\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This heuristic combines an ant colony optimization-inspired selection with a novel local search operator that intelligently perturbs the tour by considering both objective spaces, using pheromone trails and heuristic information to guide the exploration of high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search operator ----\n    new_tour = tour.copy()\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j+1]\n        reversed_segment = segment[::-1]\n        new_tour[i:j+1] = reversed_segment\n\n        # Check feasibility\n        if len(set(new_tour)) != n:\n            new_tour = tour.copy()\n\n        # Accept if improvement in at least one objective\n        old_cost1 = sum(distance_matrix_1[tour[k], tour[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[tour[k], tour[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n\n        if not (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_tour = tour.copy()\n\n    return np.array(new_tour)\n\n",
        "score": [
            -0.8553185824736877,
            0.9415615916252136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel local search operator ----\n    new_tour = tour.copy()\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_tour[i:j+1]\n        reversed_segment = segment[::-1]\n        new_tour[i:j+1] = reversed_segment\n\n        # Check feasibility\n        if len(set(new_tour)) != n:\n            new_tour = tour.copy()\n\n        # Accept if improvement in at least one objective\n        old_cost1 = sum(distance_matrix_1[tour[k], tour[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[tour[k], tour[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_tour[k], new_tour[(k+1)%n]] for k in range(n))\n\n        if not (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_tour = tour.copy()\n\n    return np.array(new_tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The algorithm combines an ant colony optimization-inspired heuristic selection with a novel local search strategy that dynamically adapts to the pheromone trails and heuristic information, while ensuring feasibility by always maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel hybrid local search ----\n    # Randomly select a segment and reverse it (like 2-opt but with probabilistic segment selection)\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        tour[a:b+1] = tour[a:b+1][::-1]\n\n    # Randomly swap two non-adjacent edges (like edge insertion)\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 != b:\n            tour[a], tour[b] = tour[b], tour[a]\n\n    # Ensure feasibility by repairing invalid tours (if any)\n    if len(set(tour)) != n:\n        remaining = [i for i in range(n) if i not in tour]\n        for i in range(n):\n            if tour[i] not in visited:\n                tour[i] = remaining.pop()\n\n    return np.array(tour)\n\n",
        "score": [
            -0.834652730854138,
            0.5980167865753174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    # ---- novel hybrid local search ----\n    # Randomly select a segment and reverse it (like 2-opt but with probabilistic segment selection)\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        tour[a:b+1] = tour[a:b+1][::-1]\n\n    # Randomly swap two non-adjacent edges (like edge insertion)\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 != b:\n            tour[a], tour[b] = tour[b], tour[a]\n\n    # Ensure feasibility by repairing invalid tours (if any)\n    if len(set(tour)) != n:\n        remaining = [i for i in range(n) if i not in tour]\n        for i in range(n):\n            if tour[i] not in visited:\n                tour[i] = remaining.pop()\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, where solutions with better combined objective values deposit more pheromones, guiding the construction of a new neighbor solution through a biased random walk that balances pheromone trails and heuristic information (inverse distance) to explore high-quality regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7789699722791573,
            0.8421678066253662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This algorithm combines ant colony optimization principles with elitist pheromone updates to intelligently select and improve solutions from the archive, using a hybrid of probabilistic selection and pheromone-guided local search to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7473494498724722,
            1.0719762444496155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The heuristic function uses an ant colony optimization-inspired approach to construct a neighbor solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while ensuring feasibility through a novel pheromone update mechanism that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7871587607742745,
            0.8344729542732239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This heuristic combines ACO principles with elitist pheromone updates to explore high-quality regions of the search space by balancing exploration (random selection) and exploitation (pheromone-guided moves), while ensuring feasibility through strict TSP tour constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8447077115902791,
            0.8297431111335755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to select and modify a solution from the archive, where solutions are probabilistically extended based on pheromone trails and heuristic information, while ensuring feasibility through careful node selection and pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8928489392500802,
            0.8178546667098999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to select and modify a solution from the archive, where solutions are probabilistically extended based on pheromone trails and heuristic information, while ensuring feasibility through careful node selection and pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8928489392500802,
            0.8178546667098999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This heuristic function selects a neighbor solution by combining an ant colony optimization-inspired approach with a novel local search strategy that dynamically adapts pheromone trails based on archive solutions, while ensuring feasibility through a constrained random walk that avoids revisited nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8315694555669466,
            0.8337018013000488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to construct a new tour by probabilistically selecting nodes based on pheromone trails and heuristic information (inverse distance), while maintaining feasibility through careful node selection and updating pheromones based on the archive's elite solutions to guide future searches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.814387458904735,
            0.8421959757804871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This heuristic function combines ant colony optimization principles with a novel local search operator that dynamically adapts pheromone trails to guide the exploration of high-quality solutions in the bi-objective TSP, ensuring feasibility through intelligent random selection and constructive neighborhood generation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7228776302690381,
            0.8748360395431518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm implements an ant colony optimization-based local search that constructs a new solution by probabilistically selecting nodes based on pheromone trails and heuristic information, while periodically updating pheromones from the archive to guide the search toward high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7975568746407717,
            0.867037832736969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm combines an ant colony optimization-inspired heuristic with a dynamic pheromone-based selection mechanism to generate high-quality TSP solutions by balancing exploration and exploitation through probabilistic edge selection and elitist pheromone updates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7012510435010402,
            0.8731818199157715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This heuristic selects a promising solution from the archive using a combination of pheromone-based probabilistic selection and a novel ant-inspired local search that dynamically balances exploration and exploitation by integrating pheromone trails with heuristic information, while ensuring feasibility through a constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8284702320777706,
            0.8232882380485534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This heuristic function uses an ant colony optimization-inspired approach to intelligently select and modify a solution from the archive by constructing a new tour based on pheromone trails and heuristic information, while ensuring feasibility through a novel adaptive local search strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.772988360736836,
            0.8541516304016114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm combines ant colony optimization with a novel local search that intelligently selects a promising solution from the archive, constructs a new tour using probabilistic selection based on pheromone trails and heuristic information, and updates pheromone levels to guide future searches toward high-quality solutions across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7777530828647494,
            0.8652060508728028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The heuristic function uses a hybrid ACO-inspired local search that combines elitist pheromone updates with adaptive edge selection based on both distance matrices, while ensuring feasibility by maintaining a visited set and constructing a complete tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.783931838298011,
            0.8006237387657166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, where solutions are constructed probabilistically based on pheromone trails and heuristic information, then refined with an elitist pheromone update to guide future searches toward high-quality regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.805358513779073,
            0.843116021156311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm combines ACO principles with elitist pheromone updates to intelligently select and improve solutions by constructing neighbors through probabilistic transitions weighted by pheromones and heuristic information, while ensuring feasibility through a greedy construction process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.8491813665723107,
            0.8468448042869567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This heuristic function selects a promising solution from the archive using an ant colony optimization-inspired approach, combining pheromone trails and heuristic information to construct a new neighbor solution through a novel local search strategy that dynamically updates pheromone trails based on archive solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n",
        "score": [
            -0.7558530813331131,
            1.0156484842300415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random\n\npheromone = None\nalpha = 1.0\nbeta = 2.0\nrho = 0.1\n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    global pheromone\n\n    n = len(archive[0][0])\n    if pheromone is None:\n        pheromone = np.ones((n, n))\n\n    heuristic = 1.0 / (distance_matrix_1 + distance_matrix_2 + 1e-12)\n\n    # ---- construct solution like an ant ----\n    start = random.randint(0, n - 1)\n    tour = [start]\n    visited = set(tour)\n\n    while len(tour) < n:\n        i = tour[-1]\n        probs = []\n        candidates = []\n\n        for j in range(n):\n            if j not in visited:\n                p = (pheromone[i, j] ** alpha) * (heuristic[i, j] ** beta)\n                probs.append(p)\n                candidates.append(j)\n\n        probs = np.array(probs)\n        probs /= probs.sum()\n\n        next_city = random.choices(candidates, weights=probs)[0]\n        tour.append(next_city)\n        visited.add(next_city)\n\n    # ---- pheromone update from archive (elitist) ----\n    pheromone *= (1 - rho)\n    for sol, obj in archive:\n        cost = obj[0] + obj[1]\n        for k in range(n):\n            a = sol[k]\n            b = sol[(k + 1) % n]\n            pheromone[a, b] += 1.0 / cost\n            pheromone[b, a] += 1.0 / cost\n\n    return np.array(tour)\n\n"
    }
]