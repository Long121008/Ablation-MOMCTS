[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and 3-opt for diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to manipulate\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments and reinsert in a different order\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create new solution by combining segments in a novel way\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n\n    # Ensure validity by removing duplicates and filling missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length and ensure no duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.9458979915478504,
            0.2847060561180115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and 3-opt for diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to manipulate\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments and reinsert in a different order\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create new solution by combining segments in a novel way\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n\n    # Ensure validity by removing duplicates and filling missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length and ensure no duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and 3-opt for diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to manipulate\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments and reinsert in a different order\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create new solution by combining segments in a novel way\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n\n    # Ensure validity by removing duplicates and filling missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length and ensure no duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.9458979915478504,
            0.2847060561180115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and 3-opt for diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to manipulate\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments and reinsert in a different order\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create new solution by combining segments in a novel way\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n\n    # Ensure validity by removing duplicates and filling missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length and ensure no duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and 3-opt for diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to manipulate\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments and reinsert in a different order\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create new solution by combining segments in a novel way\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n\n    # Ensure validity by removing duplicates and filling missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length and ensure no duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.9458979915478504,
            0.2847060561180115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and 3-opt for diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to manipulate\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Extract segments and reinsert in a different order\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create new solution by combining segments in a novel way\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n\n    # Ensure validity by removing duplicates and filling missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length and ensure no duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search operator combines a dynamic edge-segmentation approach with a biased random walk to explore high-potential regions of the search space, while a Pareto-dominance-based selection mechanism intelligently prioritizes solutions with diverse trade-offs for further improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        if len(candidates) < 5 or random.random() < 0.3:  # Randomly sample some candidates\n            candidates.append((sol.copy(), obj))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Select the candidate with the highest objective variance (indicating potential for improvement)\n    selected = max(candidates, key=lambda x: abs(x[1][0] - x[1][1]))[0]\n\n    # Hybrid local search: Dynamic edge-segmentation + biased random walk\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic edge-segmentation (divide the tour into segments and shuffle within segments)\n    segment_size = max(2, n // random.randint(2, 5))\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        np.random.shuffle(segment)\n        new_solution[i:i+segment_size] = segment\n\n    # Step 2: Biased random walk (move nodes based on distance in both objectives)\n    for _ in range(random.randint(1, 3)):\n        i, j = random.sample(range(n), 2)\n        # Calculate combined distance in both objectives\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if (dist1 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] or\n            dist2 < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7504276106121182,
            0.45099198818206787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        if len(candidates) < 5 or random.random() < 0.3:  # Randomly sample some candidates\n            candidates.append((sol.copy(), obj))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Select the candidate with the highest objective variance (indicating potential for improvement)\n    selected = max(candidates, key=lambda x: abs(x[1][0] - x[1][1]))[0]\n\n    # Hybrid local search: Dynamic edge-segmentation + biased random walk\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic edge-segmentation (divide the tour into segments and shuffle within segments)\n    segment_size = max(2, n // random.randint(2, 5))\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        np.random.shuffle(segment)\n        new_solution[i:i+segment_size] = segment\n\n    # Step 2: Biased random walk (move nodes based on distance in both objectives)\n    for _ in range(random.randint(1, 3)):\n        i, j = random.sample(range(n), 2)\n        # Calculate combined distance in both objectives\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if (dist1 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] or\n            dist2 < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its non-dominated status and high potential for improvement, then applies a hybrid local search combining edge-swap and path-relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution, _ = archive[0]\n    else:\n        # Select the solution with the highest sum of normalized objectives\n        max_sum = -1\n        selected_sol = None\n        for sol, obj in non_dominated:\n            normalized_obj = (obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2))\n            current_sum = sum(normalized_obj)\n            if current_sum > max_sum:\n                max_sum = current_sum\n                selected_sol = sol\n        base_solution = selected_sol\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge-swap followed by path-relinking\n    # Edge-swap\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path-relinking\n    target_sol = archive[np.random.randint(len(archive))][0]\n    for i in range(n):\n        if np.random.rand() < 0.3:  # 30% chance to adopt from target solution\n            node = target_sol[i]\n            if node in new_solution:\n                pos = np.where(new_solution == node)[0][0]\n                new_solution[i], new_solution[pos] = new_solution[pos], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.686218400383813,
            0.7021712064743042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution, _ = archive[0]\n    else:\n        # Select the solution with the highest sum of normalized objectives\n        max_sum = -1\n        selected_sol = None\n        for sol, obj in non_dominated:\n            normalized_obj = (obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2))\n            current_sum = sum(normalized_obj)\n            if current_sum > max_sum:\n                max_sum = current_sum\n                selected_sol = sol\n        base_solution = selected_sol\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge-swap followed by path-relinking\n    # Edge-swap\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path-relinking\n    target_sol = archive[np.random.randint(len(archive))][0]\n    for i in range(n):\n        if np.random.rand() < 0.3:  # 30% chance to adopt from target solution\n            node = target_sol[i]\n            if node in new_solution:\n                pos = np.where(new_solution == node)[0][0]\n                new_solution[i], new_solution[pos] = new_solution[pos], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator, combining a multi-segment inversion with a biased 3-opt move, is applied to a randomly selected elite solution from the archive, prioritizing segments with high objective-space diversity to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    elite_size = max(1, len(archive_sorted) // 5)\n    elite_solutions = archive_sorted[:elite_size]\n    selected_idx = random.randint(0, elite_size - 1)\n    base_solution = elite_solutions[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-segment inversion (randomly select 2-4 segments and reverse them)\n    num_segments = random.randint(2, 4)\n    segment_lengths = np.random.choice(range(2, n // num_segments), num_segments, replace=False)\n    segment_lengths = np.clip(segment_lengths, 2, n // 2)\n\n    current_pos = 0\n    for length in segment_lengths:\n        if current_pos + length >= n:\n            break\n        start = current_pos\n        end = min(current_pos + length, n - 1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n        current_pos = end\n\n    # Step 2: Biased 3-opt move (select 3 nodes with high objective-space diversity)\n    if n >= 3:\n        # Calculate diversity scores for each node (difference in distance matrices)\n        diversity_scores = []\n        for i in range(n):\n            node = base_solution[i]\n            div_score = abs(distance_matrix_1[node, base_solution[(i+1)%n]] - distance_matrix_2[node, base_solution[(i+1)%n]])\n            diversity_scores.append(div_score)\n\n        # Select 3 nodes with highest diversity\n        top_indices = np.argsort(diversity_scores)[-3:]\n        i, j, k = sorted(top_indices)\n\n        # Perform 3-opt move\n        if i < j < k and j - i > 1 and k - j > 1:\n            # Reverse the middle segment\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            # Reverse the last segment\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7216375935244218,
            0.547206461429596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    elite_size = max(1, len(archive_sorted) // 5)\n    elite_solutions = archive_sorted[:elite_size]\n    selected_idx = random.randint(0, elite_size - 1)\n    base_solution = elite_solutions[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-segment inversion (randomly select 2-4 segments and reverse them)\n    num_segments = random.randint(2, 4)\n    segment_lengths = np.random.choice(range(2, n // num_segments), num_segments, replace=False)\n    segment_lengths = np.clip(segment_lengths, 2, n // 2)\n\n    current_pos = 0\n    for length in segment_lengths:\n        if current_pos + length >= n:\n            break\n        start = current_pos\n        end = min(current_pos + length, n - 1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n        current_pos = end\n\n    # Step 2: Biased 3-opt move (select 3 nodes with high objective-space diversity)\n    if n >= 3:\n        # Calculate diversity scores for each node (difference in distance matrices)\n        diversity_scores = []\n        for i in range(n):\n            node = base_solution[i]\n            div_score = abs(distance_matrix_1[node, base_solution[(i+1)%n]] - distance_matrix_2[node, base_solution[(i+1)%n]])\n            diversity_scores.append(div_score)\n\n        # Select 3 nodes with highest diversity\n        top_indices = np.argsort(diversity_scores)[-3:]\n        i, j, k = sorted(top_indices)\n\n        # Perform 3-opt move\n        if i < j < k and j - i > 1 and k - j > 1:\n            # Reverse the middle segment\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            # Reverse the last segment\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel hybrid local search operator that combines a segment-based relocation with a dynamic edge-swapping mechanism to intelligently explore the solution space, prioritizing regions with high potential for multi-objective improvement by analyzing the archive's non-dominated solutions and adaptively adjusting the search focus based on current performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts (simplified for selection)\n    dominance_counts = []\n    for i in range(len(archive_objectives)):\n        count = 0\n        for j in range(len(archive_objectives)):\n            if i != j:\n                if (archive_objectives[i][0] >= archive_objectives[j][0] and archive_objectives[i][1] > archive_objectives[j][1]) or \\\n                   (archive_objectives[i][0] > archive_objectives[j][0] and archive_objectives[i][1] >= archive_objectives[j][1]):\n                    count += 1\n        dominance_counts.append(count)\n\n    # Select the solution with the highest dominance count (most potential for improvement)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment-based relocation (move a segment of nodes to a new position)\n    segment_start = np.random.randint(0, n - 3)\n    segment_length = np.random.randint(2, n - segment_start - 1)\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_start + segment_length:],\n        segment\n    ])\n\n    # Step 2: Dynamic edge-swapping (swap edges based on multi-objective cost)\n    for _ in range(3):  # Limited iterations for efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8790497476285941,
            2.245676636695862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts (simplified for selection)\n    dominance_counts = []\n    for i in range(len(archive_objectives)):\n        count = 0\n        for j in range(len(archive_objectives)):\n            if i != j:\n                if (archive_objectives[i][0] >= archive_objectives[j][0] and archive_objectives[i][1] > archive_objectives[j][1]) or \\\n                   (archive_objectives[i][0] > archive_objectives[j][0] and archive_objectives[i][1] >= archive_objectives[j][1]):\n                    count += 1\n        dominance_counts.append(count)\n\n    # Select the solution with the highest dominance count (most potential for improvement)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment-based relocation (move a segment of nodes to a new position)\n    segment_start = np.random.randint(0, n - 3)\n    segment_length = np.random.randint(2, n - segment_start - 1)\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_start + segment_length:],\n        segment\n    ])\n\n    # Step 2: Dynamic edge-swapping (swap edges based on multi-objective cost)\n    for _ in range(3):  # Limited iterations for efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive edge selection with a multi-objective-aware perturbation strategy to explore high-quality neighbors by dynamically adjusting segment lengths and considering both distance matrices to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with multi-objective awareness\n    n = len(new_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Dynamic segment length\n\n    # Select two distinct positions\n    i = random.randint(0, n - 1)\n    j = (i + segment_length) % n\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment and evaluate both objectives\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Check if the reversal improves both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # If not better in both, try a different perturbation\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # Try a swap of two random nodes\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8080207380336196,
            0.569147527217865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with multi-objective awareness\n    n = len(new_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Dynamic segment length\n\n    # Select two distinct positions\n    i = random.randint(0, n - 1)\n    j = (i + segment_length) % n\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment and evaluate both objectives\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Check if the reversal improves both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # If not better in both, try a different perturbation\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # Try a swap of two random nodes\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: segment reversal with edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 3)\n    end = np.random.randint(start + 2, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly swap two edges\n    i, j = np.random.choice(range(n), 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        # Find all occurrences of the duplicate\n        indices = np.where(new_solution == dup)[0]\n        # Replace duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for idx, missing in zip(indices[1:], missing_nodes[:len(indices)-1]):\n            new_solution[idx] = missing\n\n    return new_solution\n\n",
        "score": [
            -0.873277932858753,
            0.46661078929901123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: segment reversal with edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 3)\n    end = np.random.randint(start + 2, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly swap two edges\n    i, j = np.random.choice(range(n), 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        # Find all occurrences of the duplicate\n        indices = np.where(new_solution == dup)[0]\n        # Replace duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for idx, missing in zip(indices[1:], missing_nodes[:len(indices)-1]):\n            new_solution[idx] = missing\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search operator that combines a multi-swap mechanism with a conflict-aware edge insertion strategy to intelligently explore the solution space while ensuring feasibility and promoting diverse improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the number of nodes to swap (between 2 and min(10, N//2))\n    N = len(base_solution)\n    k = random.randint(2, min(10, N // 2))\n\n    # Select k distinct nodes to perform a multi-swap\n    swap_indices = random.sample(range(N), k)\n    swap_indices.sort()\n\n    # Perform a cyclic permutation among the selected nodes\n    for i in range(len(swap_indices)):\n        new_solution[swap_indices[i]] = base_solution[swap_indices[(i + 1) % len(swap_indices)]]\n\n    # Identify edges that are problematic in either objective space\n    def get_edge_costs(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i + 1) % N]] for i in range(N))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i + 1) % N]] for i in range(N))\n        return cost1, cost2\n\n    base_cost1, base_cost2 = get_edge_costs(base_solution)\n    new_cost1, new_cost2 = get_edge_costs(new_solution)\n\n    # If the multi-swap worsened the solution, try an edge insertion step\n    if (new_cost1 > base_cost1 and new_cost2 > base_cost2) or random.random() < 0.3:\n        # Select a random edge to remove\n        remove_idx = random.randint(0, N - 1)\n        removed_node = new_solution[remove_idx]\n\n        # Remove the node and reinsert it in a position that minimizes the increase in both objectives\n        remaining_nodes = np.delete(new_solution, remove_idx)\n        best_insert_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(N - 1):\n            # Try inserting the removed node at position 'pos'\n            candidate_solution = np.insert(remaining_nodes, pos, removed_node)\n            candidate_cost1, candidate_cost2 = get_edge_costs(candidate_solution)\n            improvement = (candidate_cost1 - base_cost1) + (candidate_cost2 - base_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        new_solution = np.insert(remaining_nodes, best_insert_pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8637230379716825,
            3.0482000708580017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the number of nodes to swap (between 2 and min(10, N//2))\n    N = len(base_solution)\n    k = random.randint(2, min(10, N // 2))\n\n    # Select k distinct nodes to perform a multi-swap\n    swap_indices = random.sample(range(N), k)\n    swap_indices.sort()\n\n    # Perform a cyclic permutation among the selected nodes\n    for i in range(len(swap_indices)):\n        new_solution[swap_indices[i]] = base_solution[swap_indices[(i + 1) % len(swap_indices)]]\n\n    # Identify edges that are problematic in either objective space\n    def get_edge_costs(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i + 1) % N]] for i in range(N))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i + 1) % N]] for i in range(N))\n        return cost1, cost2\n\n    base_cost1, base_cost2 = get_edge_costs(base_solution)\n    new_cost1, new_cost2 = get_edge_costs(new_solution)\n\n    # If the multi-swap worsened the solution, try an edge insertion step\n    if (new_cost1 > base_cost1 and new_cost2 > base_cost2) or random.random() < 0.3:\n        # Select a random edge to remove\n        remove_idx = random.randint(0, N - 1)\n        removed_node = new_solution[remove_idx]\n\n        # Remove the node and reinsert it in a position that minimizes the increase in both objectives\n        remaining_nodes = np.delete(new_solution, remove_idx)\n        best_insert_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(N - 1):\n            # Try inserting the removed node at position 'pos'\n            candidate_solution = np.insert(remaining_nodes, pos, removed_node)\n            candidate_cost1, candidate_cost2 = get_edge_costs(candidate_solution)\n            improvement = (candidate_cost1 - base_cost1) + (candidate_cost2 - base_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        new_solution = np.insert(remaining_nodes, best_insert_pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator combining edge swaps and node reinsertions to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives (can be replaced with Pareto dominance)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (like 2-opt but with more flexibility)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility (should always be true for this operator)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8711495263875936,
            0.5057877898216248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives (can be replaced with Pareto dominance)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (like 2-opt but with more flexibility)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility (should always be true for this operator)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator combining edge swaps and node reinsertions to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives (can be replaced with Pareto dominance)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (like 2-opt but with more flexibility)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility (should always be true for this operator)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8711495263875936,
            0.5057877898216248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives (can be replaced with Pareto dominance)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (like 2-opt but with more flexibility)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility (should always be true for this operator)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator combining edge swaps and node reinsertions to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives (can be replaced with Pareto dominance)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (like 2-opt but with more flexibility)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility (should always be true for this operator)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8711495263875936,
            0.5057877898216248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives (can be replaced with Pareto dominance)\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (like 2-opt but with more flexibility)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility (should always be true for this operator)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping with multi-objective crossover, prioritizing high-potential solutions in the archive while ensuring feasibility through intelligent random segment selection and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined normalized objective values (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)))\n        # Select from top 30% of solutions with higher probability\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        probabilities = np.linspace(1.0, 0.1, len(selection_pool))\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(selection_pool), p=probabilities)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Adaptive Segment Swap with Multi-Objective Crossover\n    if n > 3:\n        # Step 1: Select two non-overlapping segments adaptively\n        segment_length = random.randint(2, min(5, n // 2))\n        start1 = random.randint(0, n - segment_length)\n        end1 = start1 + segment_length\n        start2 = random.randint(0, n - segment_length)\n        end2 = start2 + segment_length\n\n        # Ensure segments are not overlapping\n        while (start1 <= start2 <= end1) or (start2 <= start1 <= end2):\n            start2 = random.randint(0, n - segment_length)\n            end2 = start2 + segment_length\n\n        # Step 2: Swap segments and repair to maintain feasibility\n        segment1 = new_solution[start1:end1]\n        segment2 = new_solution[start2:end2]\n\n        # Create a temporary solution with segments swapped\n        temp_solution = new_solution.copy()\n        temp_solution[start1:end1] = segment2\n        temp_solution[start2:end2] = segment1\n\n        # Repair by inserting missing nodes in order\n        missing_nodes = [node for node in base_solution if node not in temp_solution]\n        insert_pos = [i for i in range(n) if i not in range(start1, end1) and i not in range(start2, end2)]\n        random.shuffle(insert_pos)\n        for i, node in enumerate(missing_nodes):\n            if i < len(insert_pos):\n                temp_solution[insert_pos[i]] = node\n\n        # Step 3: Evaluate the new solution's potential\n        def evaluate(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = evaluate(new_solution)\n        new_cost1, new_cost2 = evaluate(temp_solution)\n\n        # Accept if at least one objective improves significantly\n        if (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n            new_solution = temp_solution\n\n        # Step 4: Multi-objective crossover with a random solution from archive\n        if len(archive) > 1:\n            crossover_solution = random.choice(archive)[0]\n            crossover_point = random.randint(1, n-1)\n            child_solution = np.concatenate([\n                new_solution[:crossover_point],\n                [node for node in crossover_solution if node not in new_solution[:crossover_point]]\n            ])\n\n            # Repair if needed\n            if len(child_solution) < n:\n                missing = [node for node in base_solution if node not in child_solution]\n                child_solution = np.concatenate([child_solution, missing])\n\n            child_cost1, child_cost2 = evaluate(child_solution)\n            if (child_cost1 < current_cost1 and child_cost2 <= current_cost2 * 1.05) or \\\n               (child_cost2 < current_cost2 and child_cost1 <= current_cost1 * 1.05):\n                new_solution = child_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5369850289807332,
            4.371015310287476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined normalized objective values (lower is better)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)))\n        # Select from top 30% of solutions with higher probability\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        probabilities = np.linspace(1.0, 0.1, len(selection_pool))\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(selection_pool), p=probabilities)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Adaptive Segment Swap with Multi-Objective Crossover\n    if n > 3:\n        # Step 1: Select two non-overlapping segments adaptively\n        segment_length = random.randint(2, min(5, n // 2))\n        start1 = random.randint(0, n - segment_length)\n        end1 = start1 + segment_length\n        start2 = random.randint(0, n - segment_length)\n        end2 = start2 + segment_length\n\n        # Ensure segments are not overlapping\n        while (start1 <= start2 <= end1) or (start2 <= start1 <= end2):\n            start2 = random.randint(0, n - segment_length)\n            end2 = start2 + segment_length\n\n        # Step 2: Swap segments and repair to maintain feasibility\n        segment1 = new_solution[start1:end1]\n        segment2 = new_solution[start2:end2]\n\n        # Create a temporary solution with segments swapped\n        temp_solution = new_solution.copy()\n        temp_solution[start1:end1] = segment2\n        temp_solution[start2:end2] = segment1\n\n        # Repair by inserting missing nodes in order\n        missing_nodes = [node for node in base_solution if node not in temp_solution]\n        insert_pos = [i for i in range(n) if i not in range(start1, end1) and i not in range(start2, end2)]\n        random.shuffle(insert_pos)\n        for i, node in enumerate(missing_nodes):\n            if i < len(insert_pos):\n                temp_solution[insert_pos[i]] = node\n\n        # Step 3: Evaluate the new solution's potential\n        def evaluate(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = evaluate(new_solution)\n        new_cost1, new_cost2 = evaluate(temp_solution)\n\n        # Accept if at least one objective improves significantly\n        if (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n            new_solution = temp_solution\n\n        # Step 4: Multi-objective crossover with a random solution from archive\n        if len(archive) > 1:\n            crossover_solution = random.choice(archive)[0]\n            crossover_point = random.randint(1, n-1)\n            child_solution = np.concatenate([\n                new_solution[:crossover_point],\n                [node for node in crossover_solution if node not in new_solution[:crossover_point]]\n            ])\n\n            # Repair if needed\n            if len(child_solution) < n:\n                missing = [node for node in base_solution if node not in child_solution]\n                child_solution = np.concatenate([child_solution, missing])\n\n            child_cost1, child_cost2 = evaluate(child_solution)\n            if (child_cost1 < current_cost1 and child_cost2 <= current_cost2 * 1.05) or \\\n               (child_cost2 < current_cost2 and child_cost1 <= current_cost1 * 1.05):\n                new_solution = child_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with lower objective values, then applies a hybrid local search combining a randomized 3-opt move with a novel edge insertion mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: randomized 3-opt + edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No enough nodes for 3-opt\n\n    # Randomly select three distinct edges\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge insertion: try to improve by inserting a random node\n    if n > 4:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        # Find best insertion point\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(n - 1):\n            temp_solution = np.insert(new_solution, i, node)\n            cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            for j in range(n - 1):\n                cost1 += distance_matrix_1[temp_solution[j], temp_solution[j+1]]\n                cost2 += distance_matrix_2[temp_solution[j], temp_solution[j+1]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8085803585087465,
            3.0361937880516052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: randomized 3-opt + edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No enough nodes for 3-opt\n\n    # Randomly select three distinct edges\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge insertion: try to improve by inserting a random node\n    if n > 4:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        # Find best insertion point\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(n - 1):\n            temp_solution = np.insert(new_solution, i, node)\n            cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            for j in range(n - 1):\n                cost1 += distance_matrix_1[temp_solution[j], temp_solution[j+1]]\n                cost2 += distance_matrix_2[temp_solution[j], temp_solution[j+1]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining random segment inversion and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in one objective)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])  # Example: select the worst solution to improve\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion + edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge exchange: swap two non-adjacent edges\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to standard 2-opt if hybrid fails\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9097733138388383,
            0.5166113376617432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in one objective)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])  # Example: select the worst solution to improve\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion + edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge exchange: swap two non-adjacent edges\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to standard 2-opt if hybrid fails\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining random segment inversion and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in one objective)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])  # Example: select the worst solution to improve\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion + edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge exchange: swap two non-adjacent edges\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to standard 2-opt if hybrid fails\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9097733138388383,
            0.5166113376617432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in one objective)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])  # Example: select the worst solution to improve\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion + edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge exchange: swap two non-adjacent edges\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to standard 2-opt if hybrid fails\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A hybrid local search algorithm combining a novel adaptive edge-swap operator with a biased random walk to explore the solution space while balancing exploration and exploitation based on the archive's non-dominated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [s for s, _ in archive]\n    archive_objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: adaptive edge-swap with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive edge-swap\n    for _ in range(10):  # Number of swap attempts\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        prev_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < prev_cost:\n            # Perform swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Biased random walk (explore nearby solutions)\n    for _ in range(5):  # Number of walk steps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if np.random.rand() < 0.7:  # Higher probability for beneficial moves\n            # Check if swap improves at least one objective\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if (cost1_after < cost1_before or cost2_after < cost2_before):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Random swap for exploration\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7156882694727918,
            0.6774680018424988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [s for s, _ in archive]\n    archive_objectives = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: adaptive edge-swap with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive edge-swap\n    for _ in range(10):  # Number of swap attempts\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        prev_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < prev_cost:\n            # Perform swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Biased random walk (explore nearby solutions)\n    for _ in range(5):  # Number of walk steps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if np.random.rand() < 0.7:  # Higher probability for beneficial moves\n            # Check if swap improves at least one objective\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if (cost1_after < cost1_before or cost2_after < cost2_before):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Random swap for exploration\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two nodes to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    if len(np.unique(new_solution)) != n:\n        # Revert to the original segment if invalid\n        new_solution[a:b+1] = selected_solution[a:b+1]\n\n    return new_solution\n\n",
        "score": [
            -0.9327063695879598,
            0.5074189305305481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two nodes to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    if len(np.unique(new_solution)) != n:\n        # Revert to the original segment if invalid\n        new_solution[a:b+1] = selected_solution[a:b+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two nodes to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    if len(np.unique(new_solution)) != n:\n        # Revert to the original segment if invalid\n        new_solution[a:b+1] = selected_solution[a:b+1]\n\n    return new_solution\n\n",
        "score": [
            -0.9327063695879598,
            0.5074189305305481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two nodes to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    if len(np.unique(new_solution)) != n:\n        # Revert to the original segment if invalid\n        new_solution[a:b+1] = selected_solution[a:b+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search strategy combines a variable-length segment relocation with a probabilistic edge swap, guided by a Pareto-dominance-based selection of promising segments from the archive, ensuring feasibility and diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with better objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 - (normalized_objectives[:, 0] + normalized_objectives[:, 1]) / 2  # Combine objectives for selection\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Variable-length segment relocation\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic edge swap based on distance matrices\n    for _ in range(2):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if new_cost < current_cost or random.random() < 0.3:  # Accept if better or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8903297263811838,
            0.4962884783744812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with better objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 - (normalized_objectives[:, 0] + normalized_objectives[:, 1]) / 2  # Combine objectives for selection\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Variable-length segment relocation\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic edge swap based on distance matrices\n    for _ in range(2):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if new_cost < current_cost or random.random() < 0.3:  # Accept if better or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search strategy combines a variable-length segment relocation with a probabilistic edge swap, guided by a Pareto-dominance-based selection of promising segments from the archive, ensuring feasibility and diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with better objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 - (normalized_objectives[:, 0] + normalized_objectives[:, 1]) / 2  # Combine objectives for selection\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Variable-length segment relocation\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic edge swap based on distance matrices\n    for _ in range(2):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if new_cost < current_cost or random.random() < 0.3:  # Accept if better or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8903297263811838,
            0.4962884783744812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with better objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 - (normalized_objectives[:, 0] + normalized_objectives[:, 1]) / 2  # Combine objectives for selection\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Variable-length segment relocation\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic edge swap based on distance matrices\n    for _ in range(2):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if new_cost < current_cost or random.random() < 0.3:  # Accept if better or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This heuristic function intelligently selects a solution from the archive based on its non-dominated status and applies a hybrid local search combining edge exchange with a novel segment inversion operator to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, _ in archive if not any(sol_obj[0] <= sol[0] and sol_obj[1] <= sol[1] and (sol_obj[0] < sol[0] or sol_obj[1] < sol[1]) for _, sol_obj in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated)\n    else:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion with edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Apply edge exchange if beneficial\n    for _ in range(2):  # Limit to a few exchanges\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        potential_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if both objectives improve or one improves while the other doesn't worsen too much\n        if (potential_cost1 < current_cost1 and potential_cost2 <= current_cost2 * 1.1) or \\\n           (potential_cost2 < current_cost2 and potential_cost1 <= current_cost1 * 1.1):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8759535871152195,
            0.6494068503379822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, _ in archive if not any(sol_obj[0] <= sol[0] and sol_obj[1] <= sol[1] and (sol_obj[0] < sol[0] or sol_obj[1] < sol[1]) for _, sol_obj in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated)\n    else:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion with edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    # Apply edge exchange if beneficial\n    for _ in range(2):  # Limit to a few exchanges\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        potential_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if both objectives improve or one improves while the other doesn't worsen too much\n        if (potential_cost1 < current_cost1 and potential_cost2 <= current_cost2 * 1.1) or \\\n           (potential_cost2 < current_cost2 and potential_cost1 <= current_cost1 * 1.1):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: reverse a random segment and then perform a double-bridge move\n    n = len(best_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution = best_solution.copy()\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n\n    # Double-bridge move: select two random non-overlapping segments and swap them\n    c, d = sorted(random.sample(range(n), 2))\n    e, f = sorted(random.sample(range(n), 2))\n    if c < d < e < f:\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[e:f+1]\n        new_solution = np.concatenate([new_solution[:c], segment2, new_solution[d+1:e], segment1, new_solution[f+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6998292173838782,
            0.4544413089752197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: reverse a random segment and then perform a double-bridge move\n    n = len(best_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution = best_solution.copy()\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n\n    # Double-bridge move: select two random non-overlapping segments and swap them\n    c, d = sorted(random.sample(range(n), 2))\n    e, f = sorted(random.sample(range(n), 2))\n    if c < d < e < f:\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[e:f+1]\n        new_solution = np.concatenate([new_solution[:c], segment2, new_solution[d+1:e], segment1, new_solution[f+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: reverse a random segment and then perform a double-bridge move\n    n = len(best_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution = best_solution.copy()\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n\n    # Double-bridge move: select two random non-overlapping segments and swap them\n    c, d = sorted(random.sample(range(n), 2))\n    e, f = sorted(random.sample(range(n), 2))\n    if c < d < e < f:\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[e:f+1]\n        new_solution = np.concatenate([new_solution[:c], segment2, new_solution[d+1:e], segment1, new_solution[f+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6998292173838782,
            0.4544413089752197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: reverse a random segment and then perform a double-bridge move\n    n = len(best_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution = best_solution.copy()\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n\n    # Double-bridge move: select two random non-overlapping segments and swap them\n    c, d = sorted(random.sample(range(n), 2))\n    e, f = sorted(random.sample(range(n), 2))\n    if c < d < e < f:\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[e:f+1]\n        new_solution = np.concatenate([new_solution[:c], segment2, new_solution[d+1:e], segment1, new_solution[f+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Example: Select the solution with the highest total cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify (3-opt)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: Reverse segments between selected edges\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge-swapping: Swap edges between the two objectives to balance costs\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If one objective dominates the other, swap a pair of edges to balance\n    if obj1_cost > obj2_cost * 1.2:  # Threshold for imbalance\n        # Find the worst edge in the dominant objective and swap it with a better edge in the other\n        worst_edge = max(range(n), key=lambda i: distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        candidate_edges = [(i, (i+2)%n) for i in range(n) if abs(i - worst_edge) > 1]\n        if candidate_edges:\n            i, j = random.choice(candidate_edges)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9889335253751291,
            0.5145214796066284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Example: Select the solution with the highest total cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify (3-opt)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: Reverse segments between selected edges\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge-swapping: Swap edges between the two objectives to balance costs\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If one objective dominates the other, swap a pair of edges to balance\n    if obj1_cost > obj2_cost * 1.2:  # Threshold for imbalance\n        # Find the worst edge in the dominant objective and swap it with a better edge in the other\n        worst_edge = max(range(n), key=lambda i: distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        candidate_edges = [(i, (i+2)%n) for i in range(n) if abs(i - worst_edge) > 1]\n        if candidate_edges:\n            i, j = random.choice(candidate_edges)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Example: Select the solution with the highest total cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify (3-opt)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: Reverse segments between selected edges\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge-swapping: Swap edges between the two objectives to balance costs\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If one objective dominates the other, swap a pair of edges to balance\n    if obj1_cost > obj2_cost * 1.2:  # Threshold for imbalance\n        # Find the worst edge in the dominant objective and swap it with a better edge in the other\n        worst_edge = max(range(n), key=lambda i: distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        candidate_edges = [(i, (i+2)%n) for i in range(n) if abs(i - worst_edge) > 1]\n        if candidate_edges:\n            i, j = random.choice(candidate_edges)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9889335253751291,
            0.5145214796066284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Example: Select the solution with the highest total cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify (3-opt)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: Reverse segments between selected edges\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge-swapping: Swap edges between the two objectives to balance costs\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If one objective dominates the other, swap a pair of edges to balance\n    if obj1_cost > obj2_cost * 1.2:  # Threshold for imbalance\n        # Find the worst edge in the dominant objective and swap it with a better edge in the other\n        worst_edge = max(range(n), key=lambda i: distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        candidate_edges = [(i, (i+2)%n) for i in range(n) if abs(i - worst_edge) > 1]\n        if candidate_edges:\n            i, j = random.choice(candidate_edges)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel local search operator combines adaptive segment reversal and guided edge insertion, prioritizing solutions with high crowding distance in the archive to balance exploration and exploitation, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[sorted_indices[0]] = float('inf')\n        distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = crowding_distance([sol for (sol, _) in archive], objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment reversal + guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    # Find the worst edge in both spaces\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        combined_cost = cost1 + cost2\n        if combined_cost > worst_edge_cost:\n            worst_edge_cost = combined_cost\n            worst_edge_idx = i\n\n    # Insert the next node after the worst edge\n    if worst_edge_idx != -1:\n        next_node = new_solution[(worst_edge_idx + 2) % n]\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx + 1],\n            [next_node],\n            new_solution[worst_edge_idx + 2:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9260560999289557,
            0.1654607653617859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[sorted_indices[0]] = float('inf')\n        distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = crowding_distance([sol for (sol, _) in archive], objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment reversal + guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    # Find the worst edge in both spaces\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        combined_cost = cost1 + cost2\n        if combined_cost > worst_edge_cost:\n            worst_edge_cost = combined_cost\n            worst_edge_idx = i\n\n    # Insert the next node after the worst edge\n    if worst_edge_idx != -1:\n        next_node = new_solution[(worst_edge_idx + 2) % n]\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx + 1],\n            [next_node],\n            new_solution[worst_edge_idx + 2:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel local search operator combines adaptive segment reversal and guided edge insertion, prioritizing solutions with high crowding distance in the archive to balance exploration and exploitation, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[sorted_indices[0]] = float('inf')\n        distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = crowding_distance([sol for (sol, _) in archive], objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment reversal + guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    # Find the worst edge in both spaces\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        combined_cost = cost1 + cost2\n        if combined_cost > worst_edge_cost:\n            worst_edge_cost = combined_cost\n            worst_edge_idx = i\n\n    # Insert the next node after the worst edge\n    if worst_edge_idx != -1:\n        next_node = new_solution[(worst_edge_idx + 2) % n]\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx + 1],\n            [next_node],\n            new_solution[worst_edge_idx + 2:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9260560999289557,
            0.1654607653617859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[sorted_indices[0]] = float('inf')\n        distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = crowding_distance([sol for (sol, _) in archive], objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment reversal + guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    # Find the worst edge in both spaces\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        combined_cost = cost1 + cost2\n        if combined_cost > worst_edge_cost:\n            worst_edge_cost = combined_cost\n            worst_edge_idx = i\n\n    # Insert the next node after the worst edge\n    if worst_edge_idx != -1:\n        next_node = new_solution[(worst_edge_idx + 2) % n]\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx + 1],\n            [next_node],\n            new_solution[worst_edge_idx + 2:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel local search operator combines adaptive segment reversal and guided edge insertion, prioritizing solutions with high crowding distance in the archive to balance exploration and exploitation, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[sorted_indices[0]] = float('inf')\n        distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = crowding_distance([sol for (sol, _) in archive], objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment reversal + guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    # Find the worst edge in both spaces\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        combined_cost = cost1 + cost2\n        if combined_cost > worst_edge_cost:\n            worst_edge_cost = combined_cost\n            worst_edge_idx = i\n\n    # Insert the next node after the worst edge\n    if worst_edge_idx != -1:\n        next_node = new_solution[(worst_edge_idx + 2) % n]\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx + 1],\n            [next_node],\n            new_solution[worst_edge_idx + 2:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9260560999289557,
            0.1654607653617859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions, objectives):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[sorted_indices[0]] = float('inf')\n        distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = crowding_distance([sol for (sol, _) in archive], objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment reversal + guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    # Find the worst edge in both spaces\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        combined_cost = cost1 + cost2\n        if combined_cost > worst_edge_cost:\n            worst_edge_cost = combined_cost\n            worst_edge_idx = i\n\n    # Insert the next node after the worst edge\n    if worst_edge_idx != -1:\n        next_node = new_solution[(worst_edge_idx + 2) % n]\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx + 1],\n            [next_node],\n            new_solution[worst_edge_idx + 2:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and local improvement potential, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive)//4)])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and node reordering\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select a segment to modify\n        segment_start = random.randint(0, n-3)\n        segment_length = random.randint(2, min(5, n-segment_start-1))\n\n        # Extract and reverse the segment\n        segment = new_solution[segment_start:segment_start+segment_length]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[new_solution[segment_start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[segment_start+segment_length]]\n        new_cost1 = distance_matrix_1[new_solution[segment_start-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[segment_start+segment_length]]\n\n        old_cost2 = distance_matrix_2[new_solution[segment_start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[segment_start+segment_length]]\n        new_cost2 = distance_matrix_2[new_solution[segment_start-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[segment_start+segment_length]]\n\n        # Apply if both objectives improve\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.2:  # Allow some randomness\n            new_solution[segment_start:segment_start+segment_length] = reversed_segment\n\n        # Additional edge insertion step\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8326201760808996,
            0.431756854057312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = random.choice(archive_sorted[:max(3, len(archive)//4)])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and node reordering\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select a segment to modify\n        segment_start = random.randint(0, n-3)\n        segment_length = random.randint(2, min(5, n-segment_start-1))\n\n        # Extract and reverse the segment\n        segment = new_solution[segment_start:segment_start+segment_length]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[new_solution[segment_start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[segment_start+segment_length]]\n        new_cost1 = distance_matrix_1[new_solution[segment_start-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[segment_start+segment_length]]\n\n        old_cost2 = distance_matrix_2[new_solution[segment_start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[segment_start+segment_length]]\n        new_cost2 = distance_matrix_2[new_solution[segment_start-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[segment_start+segment_length]]\n\n        # Apply if both objectives improve\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.2:  # Allow some randomness\n            new_solution[segment_start:segment_start+segment_length] = reversed_segment\n\n        # Additional edge insertion step\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search strategy that combines edge swapping with a multi-objective crossover operator to intelligently perturb solutions while preserving feasibility, ensuring both objectives are improved.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a segment of the tour\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Reverse the segment (a simple but effective perturbation)\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Step 3: Apply a multi-objective crossover-like operation\n    # Select two random nodes and swap their positions if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate current and potential swap costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # If swap improves both objectives, perform it\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6751205260540133,
            0.43508052825927734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a segment of the tour\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Reverse the segment (a simple but effective perturbation)\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Step 3: Apply a multi-objective crossover-like operation\n    # Select two random nodes and swap their positions if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate current and potential swap costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # If swap improves both objectives, perform it\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator combining edge swaps, node insertions, and path reversals to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its objective values\n    weights = [1.0 / (obj[0] + obj[1] + 1e-10) for _, obj in archive]\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Randomly select a node and reinsert it at a different position\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8078746676112991,
            0.5186154842376709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its objective values\n    weights = [1.0 / (obj[0] + obj[1] + 1e-10) for _, obj in archive]\n    weights = np.array(weights) / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Randomly select a node and reinsert it at a different position\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The heuristic function selects a solution from the archive with the lowest combined objective value, then applies a novel hybrid local search operator that combines edge exchange with segment reversal, ensuring feasibility by maintaining valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with segment reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7025274604380384,
            0.43687355518341064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with segment reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of nodes to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges to diversify\n    if n > 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8887959607196466,
            0.5076084733009338
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of nodes to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges to diversify\n    if n > 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to base if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search operator combines a dynamic edge exchange strategy with a multi-objective path relinking mechanism, where non-dominated edges from the archive are selectively integrated into a base solution while preserving feasibility, followed by a guided perturbation step to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, base_obj = random.choices(\n        archive,\n        weights=[1.0 / (1e-6 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Dynamic Edge Exchange + Path Relinking\n    N = len(new_solution)\n\n    # Step 1: Dynamic Edge Exchange (selective edge replacement)\n    for _ in range(2):\n        i, j = sorted(random.sample(range(N), 2))\n        segment = new_solution[i:j+1]\n\n        # Find the best insertion point for this segment in another solution\n        best_pos = i\n        best_improvement = 0\n        for pos in range(N):\n            if pos >= i and pos < j:\n                continue\n            # Calculate improvement in both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(j+1)%N]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_improvement > 0:\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j+1:best_pos+1],\n                segment,\n                new_solution[best_pos+1:]\n            ])\n\n    # Step 2: Multi-objective Path Relinking (selective edge incorporation)\n    for _ in range(2):\n        # Select a random solution from archive\n        other_sol, _ = random.choice(archive)\n\n        # Find non-dominated edges in other_sol that could improve our solution\n        for i in range(N):\n            u, v = other_sol[i], other_sol[(i+1)%N]\n            # Check if this edge could improve our solution\n            old_u_idx = np.where(new_solution == u)[0][0]\n            old_v_idx = np.where(new_solution == v)[0][0]\n\n            if abs(old_u_idx - old_v_idx) > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[old_u_idx-1], new_solution[old_u_idx]] +\n                            distance_matrix_1[new_solution[old_v_idx], new_solution[(old_v_idx+1)%N]])\n                old_cost2 = (distance_matrix_2[new_solution[old_u_idx-1], new_solution[old_u_idx]] +\n                            distance_matrix_2[new_solution[old_v_idx], new_solution[(old_v_idx+1)%N]])\n\n                new_cost1 = distance_matrix_1[new_solution[old_u_idx-1], u] + distance_matrix_1[v, new_solution[(old_v_idx+1)%N]]\n                new_cost2 = distance_matrix_2[new_solution[old_u_idx-1], u] + distance_matrix_2[v, new_solution[(old_v_idx+1)%N]]\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n                   (random.random() < 0.3 and (new_cost1 < old_cost1 or new_cost2 < old_cost2)):\n                    # Perform the edge swap\n                    if old_u_idx < old_v_idx:\n                        new_solution[old_u_idx:old_v_idx+1] = new_solution[old_u_idx:old_v_idx+1][::-1]\n                    else:\n                        temp = np.concatenate([new_solution[old_v_idx:old_u_idx+1], new_solution[old_v_idx+1:old_u_idx]])\n                        new_solution[old_v_idx:old_u_idx+1] = temp\n\n    # Step 3: Guided Perturbation (diversification)\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(N), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6927538679703952,
            1.479196012020111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, base_obj = random.choices(\n        archive,\n        weights=[1.0 / (1e-6 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Dynamic Edge Exchange + Path Relinking\n    N = len(new_solution)\n\n    # Step 1: Dynamic Edge Exchange (selective edge replacement)\n    for _ in range(2):\n        i, j = sorted(random.sample(range(N), 2))\n        segment = new_solution[i:j+1]\n\n        # Find the best insertion point for this segment in another solution\n        best_pos = i\n        best_improvement = 0\n        for pos in range(N):\n            if pos >= i and pos < j:\n                continue\n            # Calculate improvement in both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(j+1)%N]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_improvement > 0:\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j+1:best_pos+1],\n                segment,\n                new_solution[best_pos+1:]\n            ])\n\n    # Step 2: Multi-objective Path Relinking (selective edge incorporation)\n    for _ in range(2):\n        # Select a random solution from archive\n        other_sol, _ = random.choice(archive)\n\n        # Find non-dominated edges in other_sol that could improve our solution\n        for i in range(N):\n            u, v = other_sol[i], other_sol[(i+1)%N]\n            # Check if this edge could improve our solution\n            old_u_idx = np.where(new_solution == u)[0][0]\n            old_v_idx = np.where(new_solution == v)[0][0]\n\n            if abs(old_u_idx - old_v_idx) > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[old_u_idx-1], new_solution[old_u_idx]] +\n                            distance_matrix_1[new_solution[old_v_idx], new_solution[(old_v_idx+1)%N]])\n                old_cost2 = (distance_matrix_2[new_solution[old_u_idx-1], new_solution[old_u_idx]] +\n                            distance_matrix_2[new_solution[old_v_idx], new_solution[(old_v_idx+1)%N]])\n\n                new_cost1 = distance_matrix_1[new_solution[old_u_idx-1], u] + distance_matrix_1[v, new_solution[(old_v_idx+1)%N]]\n                new_cost2 = distance_matrix_2[new_solution[old_u_idx-1], u] + distance_matrix_2[v, new_solution[(old_v_idx+1)%N]]\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n                   (random.random() < 0.3 and (new_cost1 < old_cost1 or new_cost2 < old_cost2)):\n                    # Perform the edge swap\n                    if old_u_idx < old_v_idx:\n                        new_solution[old_u_idx:old_v_idx+1] = new_solution[old_u_idx:old_v_idx+1][::-1]\n                    else:\n                        temp = np.concatenate([new_solution[old_v_idx:old_u_idx+1], new_solution[old_v_idx+1:old_u_idx]])\n                        new_solution[old_v_idx:old_u_idx+1] = temp\n\n    # Step 3: Guided Perturbation (diversification)\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(N), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A hybrid local search algorithm that combines a 3-opt move with a novel \"objective-aware\" edge swap strategy, dynamically selecting segments to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_combined = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_combined[0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a 3-opt move\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Reverse segments between i-j and j-k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        return base_solution\n\n    # Perform objective-aware edge swap\n    for _ in range(2):  # Limit swaps for computational efficiency\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n        # Calculate cost changes\n        cost1_change = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                        distance_matrix_1[current_edges[0]] - distance_matrix_1[current_edges[1]])\n        cost2_change = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                        distance_matrix_2[current_edges[0]] - distance_matrix_2[current_edges[1]])\n\n        # Accept if both objectives improve\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7907274602018041,
            0.472262442111969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_combined = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_combined[0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a 3-opt move\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Reverse segments between i-j and j-k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        return base_solution\n\n    # Perform objective-aware edge swap\n    for _ in range(2):  # Limit swaps for computational efficiency\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Get current and potential edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n        # Calculate cost changes\n        cost1_change = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                        distance_matrix_1[current_edges[0]] - distance_matrix_1[current_edges[1]])\n        cost2_change = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                        distance_matrix_2[current_edges[0]] - distance_matrix_2[current_edges[1]])\n\n        # Accept if both objectives improve\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and node relocation with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j or abs(i - j) == 1:\n        j = np.random.randint(0, n)\n\n    # Calculate the cost difference for both objectives\n    old_edges = [\n        (new_solution[i-1], new_solution[i]),\n        (new_solution[j-1], new_solution[j])\n    ]\n    new_edges = [\n        (new_solution[i-1], new_solution[j]),\n        (new_solution[j-1], new_solution[i])\n    ]\n\n    delta_cost1 = (\n        distance_matrix_1[old_edges[0][0], old_edges[0][1]] +\n        distance_matrix_1[old_edges[1][0], old_edges[1][1]] -\n        distance_matrix_1[new_edges[0][0], new_edges[0][1]] -\n        distance_matrix_1[new_edges[1][0], new_edges[1][1]]\n    )\n\n    delta_cost2 = (\n        distance_matrix_2[old_edges[0][0], old_edges[0][1]] +\n        distance_matrix_2[old_edges[1][0], old_edges[1][1]] -\n        distance_matrix_2[new_edges[0][0], new_edges[0][1]] -\n        distance_matrix_2[new_edges[1][0], new_edges[1][1]]\n    )\n\n    # Only perform insertion if it improves both objectives or at least one\n    if delta_cost1 <= 0 or delta_cost2 <= 0:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node relocation with objective-aware selection\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l:\n        l = np.random.randint(0, n)\n\n    # Calculate the cost difference for both objectives\n    old_edges_reloc = [\n        (new_solution[k-1], new_solution[k]),\n        (new_solution[k], new_solution[(k+1)%n]),\n        (new_solution[l-1], new_solution[l])\n    ]\n    new_edges_reloc = [\n        (new_solution[k-1], new_solution[(k+1)%n]),\n        (new_solution[l-1], new_solution[k]),\n        (new_solution[k], new_solution[l])\n    ]\n\n    delta_cost1_reloc = (\n        distance_matrix_1[old_edges_reloc[0][0], old_edges_reloc[0][1]] +\n        distance_matrix_1[old_edges_reloc[1][0], old_edges_reloc[1][1]] +\n        distance_matrix_1[old_edges_reloc[2][0], old_edges_reloc[2][1]] -\n        distance_matrix_1[new_edges_reloc[0][0], new_edges_reloc[0][1]] -\n        distance_matrix_1[new_edges_reloc[1][0], new_edges_reloc[1][1]] -\n        distance_matrix_1[new_edges_reloc[2][0], new_edges_reloc[2][1]]\n    )\n\n    delta_cost2_reloc = (\n        distance_matrix_2[old_edges_reloc[0][0], old_edges_reloc[0][1]] +\n        distance_matrix_2[old_edges_reloc[1][0], old_edges_reloc[1][1]] +\n        distance_matrix_2[old_edges_reloc[2][0], old_edges_reloc[2][1]] -\n        distance_matrix_2[new_edges_reloc[0][0], new_edges_reloc[0][1]] -\n        distance_matrix_2[new_edges_reloc[1][0], new_edges_reloc[1][1]] -\n        distance_matrix_2[new_edges_reloc[2][0], new_edges_reloc[2][1]]\n    )\n\n    # Only perform relocation if it improves both objectives or at least one\n    if delta_cost1_reloc <= 0 or delta_cost2_reloc <= 0:\n        # Remove node k and insert it after node l\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, (l+1)%(n-1), node)\n\n    return new_solution\n\n",
        "score": [
            -0.8173805021004714,
            0.4759729504585266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and node relocation with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j or abs(i - j) == 1:\n        j = np.random.randint(0, n)\n\n    # Calculate the cost difference for both objectives\n    old_edges = [\n        (new_solution[i-1], new_solution[i]),\n        (new_solution[j-1], new_solution[j])\n    ]\n    new_edges = [\n        (new_solution[i-1], new_solution[j]),\n        (new_solution[j-1], new_solution[i])\n    ]\n\n    delta_cost1 = (\n        distance_matrix_1[old_edges[0][0], old_edges[0][1]] +\n        distance_matrix_1[old_edges[1][0], old_edges[1][1]] -\n        distance_matrix_1[new_edges[0][0], new_edges[0][1]] -\n        distance_matrix_1[new_edges[1][0], new_edges[1][1]]\n    )\n\n    delta_cost2 = (\n        distance_matrix_2[old_edges[0][0], old_edges[0][1]] +\n        distance_matrix_2[old_edges[1][0], old_edges[1][1]] -\n        distance_matrix_2[new_edges[0][0], new_edges[0][1]] -\n        distance_matrix_2[new_edges[1][0], new_edges[1][1]]\n    )\n\n    # Only perform insertion if it improves both objectives or at least one\n    if delta_cost1 <= 0 or delta_cost2 <= 0:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node relocation with objective-aware selection\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l:\n        l = np.random.randint(0, n)\n\n    # Calculate the cost difference for both objectives\n    old_edges_reloc = [\n        (new_solution[k-1], new_solution[k]),\n        (new_solution[k], new_solution[(k+1)%n]),\n        (new_solution[l-1], new_solution[l])\n    ]\n    new_edges_reloc = [\n        (new_solution[k-1], new_solution[(k+1)%n]),\n        (new_solution[l-1], new_solution[k]),\n        (new_solution[k], new_solution[l])\n    ]\n\n    delta_cost1_reloc = (\n        distance_matrix_1[old_edges_reloc[0][0], old_edges_reloc[0][1]] +\n        distance_matrix_1[old_edges_reloc[1][0], old_edges_reloc[1][1]] +\n        distance_matrix_1[old_edges_reloc[2][0], old_edges_reloc[2][1]] -\n        distance_matrix_1[new_edges_reloc[0][0], new_edges_reloc[0][1]] -\n        distance_matrix_1[new_edges_reloc[1][0], new_edges_reloc[1][1]] -\n        distance_matrix_1[new_edges_reloc[2][0], new_edges_reloc[2][1]]\n    )\n\n    delta_cost2_reloc = (\n        distance_matrix_2[old_edges_reloc[0][0], old_edges_reloc[0][1]] +\n        distance_matrix_2[old_edges_reloc[1][0], old_edges_reloc[1][1]] +\n        distance_matrix_2[old_edges_reloc[2][0], old_edges_reloc[2][1]] -\n        distance_matrix_2[new_edges_reloc[0][0], new_edges_reloc[0][1]] -\n        distance_matrix_2[new_edges_reloc[1][0], new_edges_reloc[1][1]] -\n        distance_matrix_2[new_edges_reloc[2][0], new_edges_reloc[2][1]]\n    )\n\n    # Only perform relocation if it improves both objectives or at least one\n    if delta_cost1_reloc <= 0 or delta_cost2_reloc <= 0:\n        # Remove node k and insert it after node l\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, (l+1)%(n-1), node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on non-dominated fronts and applies a combination of edge-swapping and node-reinsertion moves to explore high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive)] * len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge-swapping and node-reinsertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge-swapping move\n    if np.random.rand() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node-reinsertion move\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9019677786077207,
            0.4953455328941345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive)] * len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge-swapping and node-reinsertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge-swapping move\n    if np.random.rand() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node-reinsertion move\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search strategy combining a novel edge insertion heuristic with a dynamic segment reversal operator to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30%)\n    top_n = max(1, int(len(archive) * 0.3))\n    candidates = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[:top_n]\n    selected = random.choice(candidates)[0].copy()\n\n    # Hybrid local search: Edge Insertion + Dynamic Segment Reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic Segment Reversal (identify and reverse promising segments)\n    for _ in range(2):  # Perform 2 iterations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 <= old_cost2 * 1.1) or \\\n           (new_cost2 < old_cost2 and new_cost1 <= old_cost1 * 1.1):\n            new_solution[i:j+1] = reversed_segment\n\n    # Step 2: Edge Insertion (for further improvement)\n    for _ in range(2):  # Perform 2 iterations\n        # Select a random node and remove it\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n        remaining = np.delete(new_solution, idx)\n\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n        for i in range(n-1):\n            cost1 = distance_matrix_1[remaining[i], node] + distance_matrix_1[node, remaining[(i+1)%(n-1)]]\n            cost2 = distance_matrix_2[remaining[i], node] + distance_matrix_2[node, remaining[(i+1)%(n-1)]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i + 1\n\n        # Insert the node at the best position\n        new_solution = np.insert(remaining, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4937772573721926,
            0.7295088768005371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30%)\n    top_n = max(1, int(len(archive) * 0.3))\n    candidates = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[:top_n]\n    selected = random.choice(candidates)[0].copy()\n\n    # Hybrid local search: Edge Insertion + Dynamic Segment Reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic Segment Reversal (identify and reverse promising segments)\n    for _ in range(2):  # Perform 2 iterations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 <= old_cost2 * 1.1) or \\\n           (new_cost2 < old_cost2 and new_cost1 <= old_cost1 * 1.1):\n            new_solution[i:j+1] = reversed_segment\n\n    # Step 2: Edge Insertion (for further improvement)\n    for _ in range(2):  # Perform 2 iterations\n        # Select a random node and remove it\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n        remaining = np.delete(new_solution, idx)\n\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n        for i in range(n-1):\n            cost1 = distance_matrix_1[remaining[i], node] + distance_matrix_1[node, remaining[(i+1)%(n-1)]]\n            cost2 = distance_matrix_2[remaining[i], node] + distance_matrix_2[node, remaining[(i+1)%(n-1)]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i + 1\n\n        # Insert the node at the best position\n        new_solution = np.insert(remaining, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a promising solution from the archive using a multi-objective selection criterion, then applies a hybrid local search combining edge exchange and node relocation with a probabilistic acceptance strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probabilistic approach based on objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + np.sum(normalized_obj, axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge exchange and node relocation\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges\n        i, j = np.random.choice(n, size=2, replace=False)\n        a, b = np.random.choice(n, size=2, replace=False)\n\n        # Perform edge exchange\n        temp = new_solution.copy()\n        temp[i], temp[j] = temp[j], temp[i]\n\n        # Check feasibility (no duplicates)\n        if len(np.unique(temp)) == n:\n            new_solution = temp\n            break\n\n    # Node relocation with probabilistic acceptance\n    for _ in range(5):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n\n        # Relocate node i to position j\n        temp = new_solution.copy()\n        node = temp[i]\n        temp = np.delete(temp, i)\n        temp = np.insert(temp, j, node)\n\n        # Accept with probability based on improvement\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[temp[j-1], temp[j]] + distance_matrix_1[temp[j], temp[(j+1)%n]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[temp[j-1], temp[j]] + distance_matrix_2[temp[j], temp[(j+1)%n]]\n        delta2 = new_cost2 - old_cost2\n\n        if delta1 + delta2 < 0 or np.random.rand() < 0.3:  # Accept worse solutions with small probability\n            new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8302226922927423,
            0.60777348279953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probabilistic approach based on objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + np.sum(normalized_obj, axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge exchange and node relocation\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges\n        i, j = np.random.choice(n, size=2, replace=False)\n        a, b = np.random.choice(n, size=2, replace=False)\n\n        # Perform edge exchange\n        temp = new_solution.copy()\n        temp[i], temp[j] = temp[j], temp[i]\n\n        # Check feasibility (no duplicates)\n        if len(np.unique(temp)) == n:\n            new_solution = temp\n            break\n\n    # Node relocation with probabilistic acceptance\n    for _ in range(5):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n\n        # Relocate node i to position j\n        temp = new_solution.copy()\n        node = temp[i]\n        temp = np.delete(temp, i)\n        temp = np.insert(temp, j, node)\n\n        # Accept with probability based on improvement\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[temp[j-1], temp[j]] + distance_matrix_1[temp[j], temp[(j+1)%n]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[temp[j-1], temp[j]] + distance_matrix_2[temp[j], temp[(j+1)%n]]\n        delta2 = new_cost2 - old_cost2\n\n        if delta1 + delta2 < 0 or np.random.rand() < 0.3:  # Accept worse solutions with small probability\n            new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A hybrid local search operator combines a novel edge-swap strategy with a multi-objective-aware perturbation mechanism to generate high-quality neighbors by adaptively selecting and modifying segments of the tour based on the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment modification\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n\n    # Extract segment and reverse it (with multi-objective awareness)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Apply the reversed segment\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation for multi-objective exploration\n    if random.random() < 0.3:  # 30% chance of additional modification\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7979984839087202,
            0.5076742768287659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment modification\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n\n    # Extract segment and reverse it (with multi-objective awareness)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Apply the reversed segment\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation for multi-objective exploration\n    if random.random() < 0.3:  # 30% chance of additional modification\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A hybrid local search operator combines a novel edge-swap strategy with a multi-objective-aware perturbation mechanism to generate high-quality neighbors by adaptively selecting and modifying segments of the tour based on the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment modification\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n\n    # Extract segment and reverse it (with multi-objective awareness)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Apply the reversed segment\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation for multi-objective exploration\n    if random.random() < 0.3:  # 30% chance of additional modification\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7979984839087202,
            0.5076742768287659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment modification\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n\n    # Extract segment and reverse it (with multi-objective awareness)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Apply the reversed segment\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation for multi-objective exploration\n    if random.random() < 0.3:  # 30% chance of additional modification\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A hybrid local search operator combines a novel edge-swap strategy with a multi-objective-aware perturbation mechanism to generate high-quality neighbors by adaptively selecting and modifying segments of the tour based on the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment modification\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n\n    # Extract segment and reverse it (with multi-objective awareness)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Apply the reversed segment\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation for multi-objective exploration\n    if random.random() < 0.3:  # 30% chance of additional modification\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7979984839087202,
            0.5076742768287659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment modification\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n\n    # Extract segment and reverse it (with multi-objective awareness)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Apply the reversed segment\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation for multi-objective exploration\n    if random.random() < 0.3:  # 30% chance of additional modification\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 <= cost2) and (other_cost1 < cost1 or other_cost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = archive[0][0]  # Fallback to first solution if all are dominated\n\n    # Hybrid local search: combine edge exchange with random segment inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure at least two edges are involved\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random segment inversion with distance-based selection\n    if random.random() < 0.5:  # 50% chance to apply this step\n        # Select a segment where the sum of distances in both objectives is high\n        segment_length = min(5, n // 2)  # Limit segment length for feasibility\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate total distance of the segment in both objectives\n        total_dist1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        total_dist2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # If the segment's distance is high in either objective, invert it\n        if total_dist1 > np.mean(distance_matrix_1) or total_dist2 > np.mean(distance_matrix_2):\n            new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7566508942509346,
            0.43556368350982666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 <= cost2) and (other_cost1 < cost1 or other_cost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = archive[0][0]  # Fallback to first solution if all are dominated\n\n    # Hybrid local search: combine edge exchange with random segment inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure at least two edges are involved\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random segment inversion with distance-based selection\n    if random.random() < 0.5:  # 50% chance to apply this step\n        # Select a segment where the sum of distances in both objectives is high\n        segment_length = min(5, n // 2)  # Limit segment length for feasibility\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate total distance of the segment in both objectives\n        total_dist1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        total_dist2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # If the segment's distance is high in either objective, invert it\n        if total_dist1 > np.mean(distance_matrix_1) or total_dist2 > np.mean(distance_matrix_2):\n            new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 <= cost2) and (other_cost1 < cost1 or other_cost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = archive[0][0]  # Fallback to first solution if all are dominated\n\n    # Hybrid local search: combine edge exchange with random segment inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure at least two edges are involved\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random segment inversion with distance-based selection\n    if random.random() < 0.5:  # 50% chance to apply this step\n        # Select a segment where the sum of distances in both objectives is high\n        segment_length = min(5, n // 2)  # Limit segment length for feasibility\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate total distance of the segment in both objectives\n        total_dist1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        total_dist2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # If the segment's distance is high in either objective, invert it\n        if total_dist1 > np.mean(distance_matrix_1) or total_dist2 > np.mean(distance_matrix_2):\n            new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7566508942509346,
            0.43556368350982666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 <= cost2) and (other_cost1 < cost1 or other_cost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = archive[0][0]  # Fallback to first solution if all are dominated\n\n    # Hybrid local search: combine edge exchange with random segment inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure at least two edges are involved\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Random segment inversion with distance-based selection\n    if random.random() < 0.5:  # 50% chance to apply this step\n        # Select a segment where the sum of distances in both objectives is high\n        segment_length = min(5, n // 2)  # Limit segment length for feasibility\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate total distance of the segment in both objectives\n        total_dist1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        total_dist2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # If the segment's distance is high in either objective, invert it\n        if total_dist1 > np.mean(distance_matrix_1) or total_dist2 > np.mean(distance_matrix_2):\n            new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search operator combines a modified 2-opt with a segment inversion heuristic, where critical segments are identified based on both objective distances and then optimized through a combination of edge swaps and segment reversals, ensuring feasibility while exploring diverse neighborhoods to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([1 / (1 + obj[0] + obj[1]) for _, obj in archive]) / sum([1 / (1 + obj[0] + obj[1]) for _, obj in archive]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: modified 2-opt with segment inversion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check for improvement in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # If no improvement, apply 2-opt-like swap\n    if new_cost1 >= original_cost1 and new_cost2 >= original_cost2:\n        k, l = np.random.choice(n, 2, replace=False)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9319158458629798,
            0.5634756684303284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([1 / (1 + obj[0] + obj[1]) for _, obj in archive]) / sum([1 / (1 + obj[0] + obj[1]) for _, obj in archive]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: modified 2-opt with segment inversion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check for improvement in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # If no improvement, apply 2-opt-like swap\n    if new_cost1 >= original_cost1 and new_cost2 >= original_cost2:\n        k, l = np.random.choice(n, 2, replace=False)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search operator combines a modified 2-opt with a segment inversion heuristic, where critical segments are identified based on both objective distances and then optimized through a combination of edge swaps and segment reversals, ensuring feasibility while exploring diverse neighborhoods to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([1 / (1 + obj[0] + obj[1]) for _, obj in archive]) / sum([1 / (1 + obj[0] + obj[1]) for _, obj in archive]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: modified 2-opt with segment inversion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check for improvement in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # If no improvement, apply 2-opt-like swap\n    if new_cost1 >= original_cost1 and new_cost2 >= original_cost2:\n        k, l = np.random.choice(n, 2, replace=False)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9319158458629798,
            0.5634756684303284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([1 / (1 + obj[0] + obj[1]) for _, obj in archive]) / sum([1 / (1 + obj[0] + obj[1]) for _, obj in archive]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: modified 2-opt with segment inversion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check for improvement in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # If no improvement, apply 2-opt-like swap\n    if new_cost1 >= original_cost1 and new_cost2 >= original_cost2:\n        k, l = np.random.choice(n, 2, replace=False)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines a segment-based perturbation with a multi-objective guided crossover, dynamically adjusting the search focus based on the Pareto dominance of solutions in the archive to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment-based perturbation with multi-objective guidance\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment-based perturbation\n        segment_size = max(2, n // 4)\n        start = random.randint(0, n - segment_size - 1)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-objective guided crossover: select a crossover point based on distance matrices\n        crossover_point = random.randint(1, n - 1)\n        parent2_idx = random.randint(0, len(archive) - 1)\n        parent2 = archive[parent2_idx][0]\n\n        # Ensure feasibility by preserving uniqueness\n        temp = np.concatenate((new_solution[:crossover_point], parent2[crossover_point:]))\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.9430386704226976,
            0.06618285179138184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment-based perturbation with multi-objective guidance\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment-based perturbation\n        segment_size = max(2, n // 4)\n        start = random.randint(0, n - segment_size - 1)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-objective guided crossover: select a crossover point based on distance matrices\n        crossover_point = random.randint(1, n - 1)\n        parent2_idx = random.randint(0, len(archive) - 1)\n        parent2 = archive[parent2_idx][0]\n\n        # Ensure feasibility by preserving uniqueness\n        temp = np.concatenate((new_solution[:crossover_point], parent2[crossover_point:]))\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines a segment-based perturbation with a multi-objective guided crossover, dynamically adjusting the search focus based on the Pareto dominance of solutions in the archive to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment-based perturbation with multi-objective guidance\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment-based perturbation\n        segment_size = max(2, n // 4)\n        start = random.randint(0, n - segment_size - 1)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-objective guided crossover: select a crossover point based on distance matrices\n        crossover_point = random.randint(1, n - 1)\n        parent2_idx = random.randint(0, len(archive) - 1)\n        parent2 = archive[parent2_idx][0]\n\n        # Ensure feasibility by preserving uniqueness\n        temp = np.concatenate((new_solution[:crossover_point], parent2[crossover_point:]))\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.9430386704226976,
            0.06618285179138184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment-based perturbation with multi-objective guidance\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment-based perturbation\n        segment_size = max(2, n // 4)\n        start = random.randint(0, n - segment_size - 1)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-objective guided crossover: select a crossover point based on distance matrices\n        crossover_point = random.randint(1, n - 1)\n        parent2_idx = random.randint(0, len(archive) - 1)\n        parent2 = archive[parent2_idx][0]\n\n        # Ensure feasibility by preserving uniqueness\n        temp = np.concatenate((new_solution[:crossover_point], parent2[crossover_point:]))\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines a segment-based perturbation with a multi-objective guided crossover, dynamically adjusting the search focus based on the Pareto dominance of solutions in the archive to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment-based perturbation with multi-objective guidance\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment-based perturbation\n        segment_size = max(2, n // 4)\n        start = random.randint(0, n - segment_size - 1)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-objective guided crossover: select a crossover point based on distance matrices\n        crossover_point = random.randint(1, n - 1)\n        parent2_idx = random.randint(0, len(archive) - 1)\n        parent2 = archive[parent2_idx][0]\n\n        # Ensure feasibility by preserving uniqueness\n        temp = np.concatenate((new_solution[:crossover_point], parent2[crossover_point:]))\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.9430386704226976,
            0.06618285179138184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment-based perturbation with multi-objective guidance\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment-based perturbation\n        segment_size = max(2, n // 4)\n        start = random.randint(0, n - segment_size - 1)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-objective guided crossover: select a crossover point based on distance matrices\n        crossover_point = random.randint(1, n - 1)\n        parent2_idx = random.randint(0, len(archive) - 1)\n        parent2 = archive[parent2_idx][0]\n\n        # Ensure feasibility by preserving uniqueness\n        temp = np.concatenate((new_solution[:crossover_point], parent2[crossover_point:]))\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with lower objective values, then applies a hybrid local search operator combining a novel edge-swap strategy with a probabilistic segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[random.randint(0, min(3, len(archive_sorted) - 1))][0].copy()\n\n    # Hybrid local search: novel edge-swap with probabilistic segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and reverse it with probability 0.5\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply edge-swap based on distance improvement\n    for _ in range(5):  # Limit iterations to balance exploration/exploitation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or (i + 1) % n == j or (j + 1) % n == i:\n            continue  # Skip adjacent nodes or same node\n\n        # Current edges: (i, i+1) and (j, j+1)\n        # Proposed edges: (i, j) and (i+1, j+1)\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        proposed_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                         distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i], new_solution[j]] +\n                         distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if proposed_cost < current_cost:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7233831698724958,
            0.6663027405738831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[random.randint(0, min(3, len(archive_sorted) - 1))][0].copy()\n\n    # Hybrid local search: novel edge-swap with probabilistic segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and reverse it with probability 0.5\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply edge-swap based on distance improvement\n    for _ in range(5):  # Limit iterations to balance exploration/exploitation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or (i + 1) % n == j or (j + 1) % n == i:\n            continue  # Skip adjacent nodes or same node\n\n        # Current edges: (i, i+1) and (j, j+1)\n        # Proposed edges: (i, j) and (i+1, j+1)\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        proposed_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                         distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i], new_solution[j]] +\n                         distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if proposed_cost < current_cost:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid local search strategy that combines adaptive segment inversion with objective-aware edge swaps, ensuring feasibility and high-quality neighbor generation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a hybrid criterion\n    def selection_criterion(sol_obj):\n        sol, (obj1, obj2) = sol_obj\n        # Normalized objective values\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        # Combine with diversity measure (number of unique edges)\n        unique_edges = len(set(zip(sol, np.roll(sol, -1))))\n        diversity_score = unique_edges / len(sol)\n        return (norm_obj1 + norm_obj2) * diversity_score\n\n    archive_sorted = sorted(archive, key=selection_criterion)\n    selected_sol = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Step 1: Objective-aware segment inversion\n    if n > 3:\n        # Select a random segment of size between 2 and n//2\n        seg_size = np.random.randint(2, n//2 + 1)\n        start = np.random.randint(0, n - seg_size)\n        end = start + seg_size\n\n        # Determine which objective to prioritize for inversion\n        if np.random.random() < 0.5:\n            # Prioritize first objective\n            seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            if seg_cost1 > seg_cost2:\n                new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Prioritize second objective\n            seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            if seg_cost2 > seg_cost1:\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Adaptive edge swap\n    if n > 4:\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n        k, l = i + 1, j + 1\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + \\\n                    distance_matrix_1[new_solution[j], new_solution[j+1]] + \\\n                    distance_matrix_1[new_solution[k-1], new_solution[k]] + \\\n                    distance_matrix_1[new_solution[l], new_solution[l+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + \\\n                    distance_matrix_1[new_solution[j], new_solution[l]] + \\\n                    distance_matrix_1[new_solution[i], new_solution[j+1]] + \\\n                    distance_matrix_1[new_solution[k-1], new_solution[l+1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                    distance_matrix_2[new_solution[j], new_solution[j+1]] + \\\n                    distance_matrix_2[new_solution[k-1], new_solution[k]] + \\\n                    distance_matrix_2[new_solution[l], new_solution[l+1]]\n\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + \\\n                    distance_matrix_2[new_solution[j], new_solution[l]] + \\\n                    distance_matrix_2[new_solution[i], new_solution[j+1]] + \\\n                    distance_matrix_2[new_solution[k-1], new_solution[l+1]]\n\n        # Accept if either objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            # Perform the swap\n            new_solution[i:j+1], new_solution[k:l+1] = new_solution[k:l+1], new_solution[i:j+1]\n\n    return new_solution\n\n",
        "score": [
            -0.5330626877771799,
            1.415437400341034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a hybrid criterion\n    def selection_criterion(sol_obj):\n        sol, (obj1, obj2) = sol_obj\n        # Normalized objective values\n        norm_obj1 = obj1 / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj2 / (distance_matrix_2.max() * len(sol))\n        # Combine with diversity measure (number of unique edges)\n        unique_edges = len(set(zip(sol, np.roll(sol, -1))))\n        diversity_score = unique_edges / len(sol)\n        return (norm_obj1 + norm_obj2) * diversity_score\n\n    archive_sorted = sorted(archive, key=selection_criterion)\n    selected_sol = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Step 1: Objective-aware segment inversion\n    if n > 3:\n        # Select a random segment of size between 2 and n//2\n        seg_size = np.random.randint(2, n//2 + 1)\n        start = np.random.randint(0, n - seg_size)\n        end = start + seg_size\n\n        # Determine which objective to prioritize for inversion\n        if np.random.random() < 0.5:\n            # Prioritize first objective\n            seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            if seg_cost1 > seg_cost2:\n                new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Prioritize second objective\n            seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            if seg_cost2 > seg_cost1:\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Adaptive edge swap\n    if n > 4:\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n        k, l = i + 1, j + 1\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + \\\n                    distance_matrix_1[new_solution[j], new_solution[j+1]] + \\\n                    distance_matrix_1[new_solution[k-1], new_solution[k]] + \\\n                    distance_matrix_1[new_solution[l], new_solution[l+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + \\\n                    distance_matrix_1[new_solution[j], new_solution[l]] + \\\n                    distance_matrix_1[new_solution[i], new_solution[j+1]] + \\\n                    distance_matrix_1[new_solution[k-1], new_solution[l+1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                    distance_matrix_2[new_solution[j], new_solution[j+1]] + \\\n                    distance_matrix_2[new_solution[k-1], new_solution[k]] + \\\n                    distance_matrix_2[new_solution[l], new_solution[l+1]]\n\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + \\\n                    distance_matrix_2[new_solution[j], new_solution[l]] + \\\n                    distance_matrix_2[new_solution[i], new_solution[j+1]] + \\\n                    distance_matrix_2[new_solution[k-1], new_solution[l+1]]\n\n        # Accept if either objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            # Perform the swap\n            new_solution[i:j+1], new_solution[k:l+1] = new_solution[k:l+1], new_solution[i:j+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This heuristic function selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines edge insertion with a novel segment reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n - 1)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Step 2: Insert a random edge from another part of the tour\n    if n > 4:\n        insert_pos = np.random.randint(1, n - 2)\n        edge_pos = np.random.choice([i for i in range(n) if i not in [insert_pos-1, insert_pos, insert_pos+1]])\n        edge_node = new_solution[edge_pos]\n\n        # Remove the edge and insert it at the new position\n        new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+1:]])\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    return new_solution\n\n",
        "score": [
            -0.9650472103766834,
            0.5166160464286804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n - 1)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Step 2: Insert a random edge from another part of the tour\n    if n > 4:\n        insert_pos = np.random.randint(1, n - 2)\n        edge_pos = np.random.choice([i for i in range(n) if i not in [insert_pos-1, insert_pos, insert_pos+1]])\n        edge_node = new_solution[edge_pos]\n\n        # Remove the edge and insert it at the new position\n        new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+1:]])\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This heuristic function selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines edge insertion with a novel segment reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n - 1)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Step 2: Insert a random edge from another part of the tour\n    if n > 4:\n        insert_pos = np.random.randint(1, n - 2)\n        edge_pos = np.random.choice([i for i in range(n) if i not in [insert_pos-1, insert_pos, insert_pos+1]])\n        edge_node = new_solution[edge_pos]\n\n        # Remove the edge and insert it at the new position\n        new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+1:]])\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    return new_solution\n\n",
        "score": [
            -0.9650472103766834,
            0.5166160464286804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n - 1)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Step 2: Insert a random edge from another part of the tour\n    if n > 4:\n        insert_pos = np.random.randint(1, n - 2)\n        edge_pos = np.random.choice([i for i in range(n) if i not in [insert_pos-1, insert_pos, insert_pos+1]])\n        edge_node = new_solution[edge_pos]\n\n        # Remove the edge and insert it at the new position\n        new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+1:]])\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search operator combines edge swapping with a dynamic segment reversal strategy, prioritizing solutions with high potential for improvement based on objective space dominance and diversity, while ensuring feasibility through constrained random perturbations and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance and diversity metrics\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives to [0, 1] range\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Score based on normalized objectives (smaller is better)\n    scores = np.sum(normalized, axis=1)\n\n    # Select top 3 candidates\n    candidate_indices = np.argsort(scores)[:min(3, len(archive))]\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Dynamic segment reversal with edge swapping\n    if n >= 4:\n        # Randomly select two segments to reverse\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        c, d = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Reverse segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Edge swapping between segments\n        if np.random.rand() < 0.5 and b < c:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure feasibility (no duplicates)\n    _, counts = np.unique(new_solution, return_counts=True)\n    if np.any(counts > 1):\n        # Repair by restoring missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for m in missing:\n            # Insert missing node at a random position\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, m)\n        # Trim to original length\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7087125043242214,
            0.5089275240898132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance and diversity metrics\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives to [0, 1] range\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Score based on normalized objectives (smaller is better)\n    scores = np.sum(normalized, axis=1)\n\n    # Select top 3 candidates\n    candidate_indices = np.argsort(scores)[:min(3, len(archive))]\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Dynamic segment reversal with edge swapping\n    if n >= 4:\n        # Randomly select two segments to reverse\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        c, d = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Reverse segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Edge swapping between segments\n        if np.random.rand() < 0.5 and b < c:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure feasibility (no duplicates)\n    _, counts = np.unique(new_solution, return_counts=True)\n    if np.any(counts > 1):\n        # Repair by restoring missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for m in missing:\n            # Insert missing node at a random position\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, m)\n        # Trim to original length\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, identified by high non-dominated ranks, and applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high non-dominated rank)\n    # Here, we randomly select from the top 20% of the archive based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion step\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal step\n    if len(new_solution) > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.4824395301235902,
            0.45344066619873047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high non-dominated rank)\n    # Here, we randomly select from the top 20% of the archive based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion step\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal step\n    if len(new_solution) > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # Sort solutions by the sum of normalized objectives to identify potential candidates\n    normalized_objectives = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2))\n        normalized_objectives.append((sol, norm_obj))\n\n    # Select top 20% of solutions with the highest sum of normalized objectives\n    sorted_solutions = sorted(normalized_objectives, key=lambda x: -(x[1][0] + x[1][1]))\n    candidate_solutions = [x[0] for x in sorted_solutions[:max(1, len(sorted_solutions) // 5)]]\n\n    # Randomly select one candidate solution\n    base_solution = random.choice(candidate_solutions).copy()\n\n    # Hybrid local search operator: variable-length segment relocation with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length (2 to min(10, n//2))\n    segment_length = random.randint(2, min(10, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Find the best insertion position for the segment in both objective spaces\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(new_solution) - segment_length + 1):\n        # Insert the segment at position 'pos'\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Combine costs using a weighted sum (equal weights for simplicity)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Additional edge insertion heuristic to further improve the solution\n    for _ in range(2):  # Perform 2 edge insertions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Extract the segment between i and j\n        segment = new_solution[i:j+1]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Find the best insertion position for the segment\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(remaining) - len(segment) + 1):\n            # Insert the segment at position 'pos'\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate the total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Combine costs using a weighted sum (equal weights for simplicity)\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7621375683290854,
            4.591505765914917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # Sort solutions by the sum of normalized objectives to identify potential candidates\n    normalized_objectives = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2))\n        normalized_objectives.append((sol, norm_obj))\n\n    # Select top 20% of solutions with the highest sum of normalized objectives\n    sorted_solutions = sorted(normalized_objectives, key=lambda x: -(x[1][0] + x[1][1]))\n    candidate_solutions = [x[0] for x in sorted_solutions[:max(1, len(sorted_solutions) // 5)]]\n\n    # Randomly select one candidate solution\n    base_solution = random.choice(candidate_solutions).copy()\n\n    # Hybrid local search operator: variable-length segment relocation with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length (2 to min(10, n//2))\n    segment_length = random.randint(2, min(10, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Find the best insertion position for the segment in both objective spaces\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(new_solution) - segment_length + 1):\n        # Insert the segment at position 'pos'\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Combine costs using a weighted sum (equal weights for simplicity)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Additional edge insertion heuristic to further improve the solution\n    for _ in range(2):  # Perform 2 edge insertions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Extract the segment between i and j\n        segment = new_solution[i:j+1]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Find the best insertion position for the segment\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(remaining) - len(segment) + 1):\n            # Insert the segment at position 'pos'\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate the total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Combine costs using a weighted sum (equal weights for simplicity)\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_obj1 = [obj[0] / max(obj[0] for _, obj in archive) for _, obj in archive]\n    normalized_obj2 = [obj[1] / max(obj[1] for _, obj in archive) for _, obj in archive]\n    combined_scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(archive))]\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion with bias towards high-distance edges\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Calculate the distance in both objectives\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if dist1 + dist2 > 0.7 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n            # Insert the segment between i and j after a random position\n            k = np.random.randint(0, n)\n            new_segment = np.concatenate([new_solution[i:j+1], new_solution[j+1:i], new_solution[:i]])\n            new_solution = np.concatenate([new_solution[:k], new_segment, new_solution[k:]])\n\n    # Step 2: Biased random walk to escape local optima\n    for _ in range(min(5, n // 2)):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Swap segments with probability based on distance improvement\n        old_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        if (new_dist1 + new_dist2) > (old_dist1 + old_dist2) * 1.1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.82523113283821,
            0.5380132794380188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_obj1 = [obj[0] / max(obj[0] for _, obj in archive) for _, obj in archive]\n    normalized_obj2 = [obj[1] / max(obj[1] for _, obj in archive) for _, obj in archive]\n    combined_scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(archive))]\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion with bias towards high-distance edges\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Calculate the distance in both objectives\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if dist1 + dist2 > 0.7 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n            # Insert the segment between i and j after a random position\n            k = np.random.randint(0, n)\n            new_segment = np.concatenate([new_solution[i:j+1], new_solution[j+1:i], new_solution[:i]])\n            new_solution = np.concatenate([new_solution[:k], new_segment, new_solution[k:]])\n\n    # Step 2: Biased random walk to escape local optima\n    for _ in range(min(5, n // 2)):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Swap segments with probability based on distance improvement\n        old_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        if (new_dist1 + new_dist2) > (old_dist1 + old_dist2) * 1.1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def combined_score(obj):\n        return obj[0] + obj[1]\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected = random.choice(archive_sorted[:max(1, len(archive_sorted) // 2)])[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Step 2: Novel segment reordering\n    if n > 4:\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, min(seg_start+5, n-1))\n        segment = new_solution[seg_start:seg_end]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Reverse segment\n        else:\n            segment = np.roll(segment, random.choice([-1, 1]))  # Rotate segment\n        new_solution = np.concatenate([new_solution[:seg_start], segment, new_solution[seg_end:]])\n\n    # Ensure validity\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7082451539083637,
            0.46461254358291626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def combined_score(obj):\n        return obj[0] + obj[1]\n\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    selected = random.choice(archive_sorted[:max(1, len(archive_sorted) // 2)])[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Step 2: Novel segment reordering\n    if n > 4:\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, min(seg_start+5, n-1))\n        segment = new_solution[seg_start:seg_end]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Reverse segment\n        else:\n            segment = np.roll(segment, random.choice([-1, 1]))  # Rotate segment\n        new_solution = np.concatenate([new_solution[:seg_start], segment, new_solution[seg_end:]])\n\n    # Ensure validity\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search operator combines 3-opt moves with adaptive path relinking, where segments of high-cost edges in both objectives are dynamically replaced with promising sub-tours from elite solutions in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on normalized Pareto front dominance\n    normalized_costs = np.array([(cost1 / np.max(distance_matrix_1), cost2 / np.max(distance_matrix_2))\n                               for _, (cost1, cost2) in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(normalized_costs[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (normalized_costs[sorted_indices[j+1], i] -\n                                                    normalized_costs[sorted_indices[j-1], i])\n\n    # Select solution with highest crowding distance (diversity) or random if all equal\n    if np.all(crowding_distances == crowding_distances[0]):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with adaptive path relinking\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Find high-cost edges in both objectives\n    cost1_edges = [(i, (i+1)%n, distance_matrix_1[base_solution[i], base_solution[(i+1)%n]])\n                  for i in range(n)]\n    cost2_edges = [(i, (i+1)%n, distance_matrix_2[base_solution[i], base_solution[(i+1)%n]])\n                  for i in range(n)]\n    cost1_edges.sort(key=lambda x: -x[2])\n    cost2_edges.sort(key=lambda x: -x[2])\n\n    # Select a segment to replace (from high-cost edges)\n    if random.random() < 0.5:\n        a, b, _ = cost1_edges[0]\n    else:\n        a, b, _ = cost2_edges[0]\n\n    # Find a replacement segment from another elite solution\n    elite_solutions = [sol[0] for sol in archive if sol[1][0] < archive[selected_idx][1][0] or\n                       sol[1][1] < archive[selected_idx][1][1]]\n    if elite_solutions:\n        replacement_sol = random.choice(elite_solutions)\n        # Find a matching segment in the replacement solution\n        for i in range(len(replacement_sol)-2):\n            # Simple matching heuristic (can be improved)\n            if (replacement_sol[i] == base_solution[a] and replacement_sol[i+1] == base_solution[b]) or \\\n               (replacement_sol[i] == base_solution[b] and replacement_sol[i+1] == base_solution[a]):\n                # Perform the replacement\n                new_solution = np.concatenate([\n                    base_solution[:a+1],\n                    replacement_sol[i+1:i+3][::-1],\n                    base_solution[b+1:]\n                ])\n                # Ensure validity\n                if len(np.unique(new_solution)) == n:\n                    return new_solution\n                break\n\n    # Fallback to random 3-opt if no better segment found\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution = np.concatenate([\n        base_solution[:a+1],\n        base_solution[b:c+1][::-1],\n        base_solution[a+1:b],\n        base_solution[c+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.6079160764557416,
            0.7899529337882996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on normalized Pareto front dominance\n    normalized_costs = np.array([(cost1 / np.max(distance_matrix_1), cost2 / np.max(distance_matrix_2))\n                               for _, (cost1, cost2) in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(normalized_costs[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (normalized_costs[sorted_indices[j+1], i] -\n                                                    normalized_costs[sorted_indices[j-1], i])\n\n    # Select solution with highest crowding distance (diversity) or random if all equal\n    if np.all(crowding_distances == crowding_distances[0]):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with adaptive path relinking\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Find high-cost edges in both objectives\n    cost1_edges = [(i, (i+1)%n, distance_matrix_1[base_solution[i], base_solution[(i+1)%n]])\n                  for i in range(n)]\n    cost2_edges = [(i, (i+1)%n, distance_matrix_2[base_solution[i], base_solution[(i+1)%n]])\n                  for i in range(n)]\n    cost1_edges.sort(key=lambda x: -x[2])\n    cost2_edges.sort(key=lambda x: -x[2])\n\n    # Select a segment to replace (from high-cost edges)\n    if random.random() < 0.5:\n        a, b, _ = cost1_edges[0]\n    else:\n        a, b, _ = cost2_edges[0]\n\n    # Find a replacement segment from another elite solution\n    elite_solutions = [sol[0] for sol in archive if sol[1][0] < archive[selected_idx][1][0] or\n                       sol[1][1] < archive[selected_idx][1][1]]\n    if elite_solutions:\n        replacement_sol = random.choice(elite_solutions)\n        # Find a matching segment in the replacement solution\n        for i in range(len(replacement_sol)-2):\n            # Simple matching heuristic (can be improved)\n            if (replacement_sol[i] == base_solution[a] and replacement_sol[i+1] == base_solution[b]) or \\\n               (replacement_sol[i] == base_solution[b] and replacement_sol[i+1] == base_solution[a]):\n                # Perform the replacement\n                new_solution = np.concatenate([\n                    base_solution[:a+1],\n                    replacement_sol[i+1:i+3][::-1],\n                    base_solution[b+1:]\n                ])\n                # Ensure validity\n                if len(np.unique(new_solution)) == n:\n                    return new_solution\n                break\n\n    # Fallback to random 3-opt if no better segment found\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution = np.concatenate([\n        base_solution[:a+1],\n        base_solution[b:c+1][::-1],\n        base_solution[a+1:b],\n        base_solution[c+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel adaptive hybrid local search operator combines a dynamic segment inversion strategy with a multi-objective-aware edge exchange mechanism, prioritizing regions with high Pareto front potential and adaptively balancing objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = obj[0] * 0.3 + obj[1] * 0.7  # Weighted gap metric\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment inversion\n        k = min(4, n // 2)\n        start = np.random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        # Multi-objective edge exchange\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, 2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9438454160461098,
            0.44376444816589355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = obj[0] * 0.3 + obj[1] * 0.7  # Weighted gap metric\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment inversion\n        k = min(4, n // 2)\n        start = np.random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        # Multi-objective edge exchange\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, 2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel adaptive hybrid local search operator combines a dynamic segment inversion strategy with a multi-objective-aware edge exchange mechanism, prioritizing regions with high Pareto front potential and adaptively balancing objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = obj[0] * 0.3 + obj[1] * 0.7  # Weighted gap metric\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment inversion\n        k = min(4, n // 2)\n        start = np.random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        # Multi-objective edge exchange\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, 2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9438454160461098,
            0.44376444816589355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = obj[0] * 0.3 + obj[1] * 0.7  # Weighted gap metric\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment inversion\n        k = min(4, n // 2)\n        start = np.random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        # Multi-objective edge exchange\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, 2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel adaptive hybrid local search operator combines a dynamic segment inversion strategy with a multi-objective-aware edge exchange mechanism, prioritizing regions with high Pareto front potential and adaptively balancing objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = obj[0] * 0.3 + obj[1] * 0.7  # Weighted gap metric\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment inversion\n        k = min(4, n // 2)\n        start = np.random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        # Multi-objective edge exchange\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, 2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9438454160461098,
            0.44376444816589355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = obj[0] * 0.3 + obj[1] * 0.7  # Weighted gap metric\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment inversion\n        k = min(4, n // 2)\n        start = np.random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        # Multi-objective edge exchange\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, 2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining a novel segment-reversal operator with a greedy edge insertion step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: segment reversal + greedy edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment reversal (novel operator)\n    if n >= 4:\n        # Randomly select two distinct segments\n        seg1_start = random.randint(0, n-2)\n        seg1_end = random.randint(seg1_start+1, n-1)\n        seg2_start = random.randint(0, n-2)\n        seg2_end = random.randint(seg2_start+1, n-1)\n\n        # Reverse segments\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n        new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Step 2: Greedy edge insertion\n    for _ in range(2):  # Perform 2 random insertions\n        if n >= 3:\n            # Choose a random node to move\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n\n            # Remove the node\n            new_solution = np.delete(new_solution, i)\n\n            # Find insertion position that minimizes combined distance\n            min_cost = float('inf')\n            best_pos = -1\n            for j in range(len(new_solution)):\n                # Insert after position j\n                temp = np.insert(new_solution, j, node)\n                cost1 = distance_matrix_1[temp[:-1], temp[1:]].sum() + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = distance_matrix_2[temp[:-1], temp[1:]].sum() + distance_matrix_2[temp[-1], temp[0]]\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = j\n\n            # Insert at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7983843419311749,
            2.114775598049164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: segment reversal + greedy edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment reversal (novel operator)\n    if n >= 4:\n        # Randomly select two distinct segments\n        seg1_start = random.randint(0, n-2)\n        seg1_end = random.randint(seg1_start+1, n-1)\n        seg2_start = random.randint(0, n-2)\n        seg2_end = random.randint(seg2_start+1, n-1)\n\n        # Reverse segments\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n        new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Step 2: Greedy edge insertion\n    for _ in range(2):  # Perform 2 random insertions\n        if n >= 3:\n            # Choose a random node to move\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n\n            # Remove the node\n            new_solution = np.delete(new_solution, i)\n\n            # Find insertion position that minimizes combined distance\n            min_cost = float('inf')\n            best_pos = -1\n            for j in range(len(new_solution)):\n                # Insert after position j\n                temp = np.insert(new_solution, j, node)\n                cost1 = distance_matrix_1[temp[:-1], temp[1:]].sum() + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = distance_matrix_2[temp[:-1], temp[1:]].sum() + distance_matrix_2[temp[-1], temp[0]]\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = j\n\n            # Insert at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel local search heuristic that combines adaptive edge swapping with Pareto-ranked segment reversal to explore diverse neighborhoods while preserving feasibility, ensuring high-quality solutions across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined score (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower combined cost\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with edge swapping\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select a random segment to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the change in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve or randomly with probability\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or np.random.random() < 0.3:\n            new_solution[i:j+1] = reversed_segment\n\n        # Edge swap with a random neighbor\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7652752535230875,
            0.6857210993766785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined score (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower combined cost\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with edge swapping\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select a random segment to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the change in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve or randomly with probability\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or np.random.random() < 0.3:\n            new_solution[i:j+1] = reversed_segment\n\n        # Edge swap with a random neighbor\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This function implements a hybrid local search strategy that combines a randomized selection of promising solutions from the archive with a novel 3-opt-inspired operator, ensuring feasibility by carefully validating and repairing any invalid segments generated during the local search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by the sum of their objectives (can be replaced with other selection criteria)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(1, len(sorted_archive) // 2)])[0].copy()\n\n    # Step 2: Apply a hybrid local search operator (3-opt-inspired with randomness)\n    N = len(selected_solution)\n    i = random.randint(0, N - 1)\n    j = random.randint(0, N - 1)\n    k = random.randint(0, N - 1)\n\n    # Ensure i < j < k\n    indices = sorted([i, j, k])\n    i, j, k = indices[0], indices[1], indices[2]\n\n    # Apply 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n    new_solution[i:k+1] = np.flip(new_solution[i:k+1])\n\n    # Step 3: Validate and repair the solution if necessary\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        # Repair by adding missing nodes in order\n        missing_nodes = np.setdiff1d(np.arange(N), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.8865191659985822,
            0.45917290449142456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by the sum of their objectives (can be replaced with other selection criteria)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(1, len(sorted_archive) // 2)])[0].copy()\n\n    # Step 2: Apply a hybrid local search operator (3-opt-inspired with randomness)\n    N = len(selected_solution)\n    i = random.randint(0, N - 1)\n    j = random.randint(0, N - 1)\n    k = random.randint(0, N - 1)\n\n    # Ensure i < j < k\n    indices = sorted([i, j, k])\n    i, j, k = indices[0], indices[1], indices[2]\n\n    # Apply 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n    new_solution[i:k+1] = np.flip(new_solution[i:k+1])\n\n    # Step 3: Validate and repair the solution if necessary\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        # Repair by adding missing nodes in order\n        missing_nodes = np.setdiff1d(np.arange(N), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified approximation)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Novel edge-swapping strategy\n    if j - i > 1:  # Ensure segment length > 1\n        # Reverse segment [i+1:j]\n        new_solution[i+1:j] = base_solution[j-1:i:-1]\n    else:\n        # Swap nodes at i and k if they are not adjacent\n        if abs(base_solution[i] - base_solution[k]) > 1:\n            new_solution[i], new_solution[k] = base_solution[k], base_solution[i]\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.40464031731280875,
            0.697605311870575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified approximation)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Novel edge-swapping strategy\n    if j - i > 1:  # Ensure segment length > 1\n        # Reverse segment [i+1:j]\n        new_solution[i+1:j] = base_solution[j-1:i:-1]\n    else:\n        # Swap nodes at i and k if they are not adjacent\n        if abs(base_solution[i] - base_solution[k]) > 1:\n            new_solution[i], new_solution[k] = base_solution[k], base_solution[i]\n\n    # Ensure validity\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm selects a promising solution from the archive using a diversity-aware selection mechanism, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Select from top 5 or fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly select two edges to insert elsewhere\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            # Remove edges (i) and (j)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            # Insert node_i after position j and node_j after position i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                np.array([node_j]),\n                new_solution[i+1:j+1],\n                np.array([node_i]),\n                new_solution[j+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.89045278482763,
            0.10113084316253662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Select from top 5 or fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly select two edges to insert elsewhere\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            # Remove edges (i) and (j)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            # Insert node_i after position j and node_j after position i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                np.array([node_j]),\n                new_solution[i+1:j+1],\n                np.array([node_i]),\n                new_solution[j+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm selects a promising solution from the archive using a diversity-aware selection mechanism, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Select from top 5 or fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly select two edges to insert elsewhere\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            # Remove edges (i) and (j)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            # Insert node_i after position j and node_j after position i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                np.array([node_j]),\n                new_solution[i+1:j+1],\n                np.array([node_i]),\n                new_solution[j+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.89045278482763,
            0.10113084316253662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Select from top 5 or fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly select two edges to insert elsewhere\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            # Remove edges (i) and (j)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            # Insert node_i after position j and node_j after position i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                np.array([node_j]),\n                new_solution[i+1:j+1],\n                np.array([node_i]),\n                new_solution[j+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search strategy combines 3-opt with a dynamic edge selection heuristic, prioritizing edges with high potential for improvement in both objectives, while ensuring feasibility through a constrained swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives (prioritize solutions with higher potential)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(x[1]) + 1e-10))\n        base_solution = archive_sorted[random.randint(0, min(2, len(archive)-1))][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with dynamic edge selection\n    for _ in range(3):  # Perform multiple attempts\n        # Select 3 distinct edges (non-adjacent)\n        edges = []\n        while len(edges) < 3:\n            i = random.randint(0, n-1)\n            j = (i + 1) % n\n            if (i, j) not in edges and (j, i) not in edges:\n                edges.append((i, j))\n\n        # Sort edges by combined potential improvement\n        edges.sort(key=lambda e: distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]])\n\n        # Attempt to perform a 3-opt move\n        a, b = edges[0]\n        c, d = edges[1]\n        e, f = edges[2]\n\n        # Check if the move is feasible\n        if a != c and a != e and b != d and b != f and c != e:\n            # Perform the move (reverse segments between selected edges)\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            new_solution[c+1:d+1] = new_solution[c+1:d+1][::-1]\n            new_solution[e+1:f+1] = new_solution[e+1:f+1][::-1]\n\n            # Ensure the solution remains valid (no duplicates, all nodes visited)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7936514669635648,
            3.879929542541504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives (prioritize solutions with higher potential)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(x[1]) + 1e-10))\n        base_solution = archive_sorted[random.randint(0, min(2, len(archive)-1))][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with dynamic edge selection\n    for _ in range(3):  # Perform multiple attempts\n        # Select 3 distinct edges (non-adjacent)\n        edges = []\n        while len(edges) < 3:\n            i = random.randint(0, n-1)\n            j = (i + 1) % n\n            if (i, j) not in edges and (j, i) not in edges:\n                edges.append((i, j))\n\n        # Sort edges by combined potential improvement\n        edges.sort(key=lambda e: distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]])\n\n        # Attempt to perform a 3-opt move\n        a, b = edges[0]\n        c, d = edges[1]\n        e, f = edges[2]\n\n        # Check if the move is feasible\n        if a != c and a != e and b != d and b != f and c != e:\n            # Perform the move (reverse segments between selected edges)\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            new_solution[c+1:d+1] = new_solution[c+1:d+1][::-1]\n            new_solution[e+1:f+1] = new_solution[e+1:f+1][::-1]\n\n            # Ensure the solution remains valid (no duplicates, all nodes visited)\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A hybrid local search operator that combines edge insertion with a dynamic segment reversal mechanism, guided by a weighted objective function to balance improvements in both spaces, while intelligently selecting solutions with high potential for further improvement based on dominance and diversity in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here we use a simple heuristic: select a solution with the highest sum of objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Insertion + Dynamic Segment Reversal\n    n = len(base_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge Insertion: Move a random edge to a different position\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        edge = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, edge)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        extra = np.setdiff1d(new_solution, np.arange(n))\n        for m, e in zip(missing, extra):\n            idx = np.where(new_solution == e)[0][0]\n            new_solution[idx] = m\n\n    return new_solution\n\n",
        "score": [
            -0.8580976988357368,
            0.48761987686157227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here we use a simple heuristic: select a solution with the highest sum of objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Insertion + Dynamic Segment Reversal\n    n = len(base_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge Insertion: Move a random edge to a different position\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        edge = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, edge)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        extra = np.setdiff1d(new_solution, np.arange(n))\n        for m, e in zip(missing, extra):\n            idx = np.where(new_solution == e)[0][0]\n            new_solution[idx] = m\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This heuristic selects a promising solution from the archive based on a weighted combination of the two objectives, then applies a hybrid local search operator that combines edge exchange with a novel segment relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a weighted sum of objectives (0.5 weight for each)\n        archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n        # Select top 30% of solutions\n        candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the candidates\n        selected_idx = random.randint(0, len(candidate_solutions) - 1)\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid operator: segment relocation with edge exchange\n        # Select a random segment of length between 2 and min(5, n//2)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Find the best insertion point considering both objectives\n        best_cost = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution) + 1):\n            # Insert segment at position i\n            temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply edge exchange with probability 0.5\n        if random.random() < 0.5:\n            # Select two random edges\n            i, j = sorted(random.sample(range(n), 2))\n            # Exchange the edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.810840286808156,
            3.110912322998047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a weighted sum of objectives (0.5 weight for each)\n        archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n        # Select top 30% of solutions\n        candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the candidates\n        selected_idx = random.randint(0, len(candidate_solutions) - 1)\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid operator: segment relocation with edge exchange\n        # Select a random segment of length between 2 and min(5, n//2)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Find the best insertion point considering both objectives\n        best_cost = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution) + 1):\n            # Insert segment at position i\n            temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply edge exchange with probability 0.5\n        if random.random() < 0.5:\n            # Select two random edges\n            i, j = sorted(random.sample(range(n), 2))\n            # Exchange the edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomly choose between edge insertion and segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it elsewhere\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to a simple swap as fallback\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7090824252312184,
            0.46866369247436523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomly choose between edge insertion and segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it elsewhere\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to a simple swap as fallback\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel hybrid local search operator that intelligently selects segments from promising solutions in the archive, combines them via a multi-objective-aware crossover, and refines them using a dynamic edge-swapping heuristic to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj):\n        # Prefer solutions with lower cost in either objective\n        return -(obj[0] + obj[1])\n\n    scores = [potential_score(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segments from top solutions and refine\n    def get_random_segment(solution):\n        n = len(solution)\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n // 2))\n        end = (start + length) % n\n        if start < end:\n            return solution[start:end]\n        else:\n            return np.concatenate([solution[start:], solution[:end]])\n\n    # Select segments from top 3 solutions in the archive\n    top_solutions = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))[:3]\n    segments = []\n    for sol, _ in top_solutions:\n        segments.extend([get_random_segment(sol) for _ in range(2)])\n\n    # Build new solution by combining segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in segments:\n        for node in seg:\n            if node in remaining_nodes:\n                new_solution.append(node)\n                remaining_nodes.remove(node)\n                if not remaining_nodes:\n                    break\n        if not remaining_nodes:\n            break\n\n    # Add remaining nodes randomly\n    new_solution.extend(list(remaining_nodes))\n\n    # Refine with dynamic edge swapping\n    def calculate_cost(solution, dist_matrix):\n        total = 0\n        for i in range(len(solution)):\n            total += dist_matrix[solution[i-1], solution[i]]\n        return total\n\n    def dynamic_swap(solution, dist_matrix1, dist_matrix2, iterations=10):\n        n = len(solution)\n        for _ in range(iterations):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate cost before swap\n            old_cost1 = calculate_cost(solution[i:j+1], dist_matrix1)\n            old_cost2 = calculate_cost(solution[i:j+1], dist_matrix2)\n            # Reverse segment\n            reversed_seg = solution[i:j+1][::-1]\n            solution[i:j+1] = reversed_seg\n            # Calculate cost after swap\n            new_cost1 = calculate_cost(solution[i:j+1], dist_matrix1)\n            new_cost2 = calculate_cost(solution[i:j+1], dist_matrix2)\n            # Accept if improvement in either objective\n            if not ((new_cost1 <= old_cost1) or (new_cost2 <= old_cost2)):\n                solution[i:j+1] = reversed_seg  # revert\n        return solution\n\n    new_solution = dynamic_swap(new_solution, distance_matrix_1, distance_matrix_2)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6994131412393041,
            0.7856945991516113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj):\n        # Prefer solutions with lower cost in either objective\n        return -(obj[0] + obj[1])\n\n    scores = [potential_score(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segments from top solutions and refine\n    def get_random_segment(solution):\n        n = len(solution)\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n // 2))\n        end = (start + length) % n\n        if start < end:\n            return solution[start:end]\n        else:\n            return np.concatenate([solution[start:], solution[:end]])\n\n    # Select segments from top 3 solutions in the archive\n    top_solutions = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))[:3]\n    segments = []\n    for sol, _ in top_solutions:\n        segments.extend([get_random_segment(sol) for _ in range(2)])\n\n    # Build new solution by combining segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in segments:\n        for node in seg:\n            if node in remaining_nodes:\n                new_solution.append(node)\n                remaining_nodes.remove(node)\n                if not remaining_nodes:\n                    break\n        if not remaining_nodes:\n            break\n\n    # Add remaining nodes randomly\n    new_solution.extend(list(remaining_nodes))\n\n    # Refine with dynamic edge swapping\n    def calculate_cost(solution, dist_matrix):\n        total = 0\n        for i in range(len(solution)):\n            total += dist_matrix[solution[i-1], solution[i]]\n        return total\n\n    def dynamic_swap(solution, dist_matrix1, dist_matrix2, iterations=10):\n        n = len(solution)\n        for _ in range(iterations):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Calculate cost before swap\n            old_cost1 = calculate_cost(solution[i:j+1], dist_matrix1)\n            old_cost2 = calculate_cost(solution[i:j+1], dist_matrix2)\n            # Reverse segment\n            reversed_seg = solution[i:j+1][::-1]\n            solution[i:j+1] = reversed_seg\n            # Calculate cost after swap\n            new_cost1 = calculate_cost(solution[i:j+1], dist_matrix1)\n            new_cost2 = calculate_cost(solution[i:j+1], dist_matrix2)\n            # Accept if improvement in either objective\n            if not ((new_cost1 <= old_cost1) or (new_cost2 <= old_cost2)):\n                solution[i:j+1] = reversed_seg  # revert\n        return solution\n\n    new_solution = dynamic_swap(new_solution, distance_matrix_1, distance_matrix_2)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines edge swapping with a novel segment relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its combined objective score\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    min_obj = np.min(objectives)\n    max_obj = np.max(objectives)\n    if max_obj == min_obj:\n        weights = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (max_obj - objectives) / (max_obj - min_obj)\n        weights = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: segment relocation with edge swapping\n    n = len(new_solution)\n    if n < 4:\n        # Simple edge swap for small instances\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment relocation\n        seg_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Find insertion point that minimizes combined distance\n        min_cost = float('inf')\n        best_insert = 0\n        for pos in range(n - seg_length + 1):\n            if pos == start:\n                continue\n\n            # Create temporary solution\n            temp = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+seg_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert = pos\n\n        # Apply best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_insert],\n            segment,\n            new_solution[best_insert:start],\n            new_solution[start+seg_length:]\n        ])\n\n        # Optional edge swap for further improvement\n        if random.random() < 0.5 and n > 3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7147505407823433,
            2.2123727202415466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its combined objective score\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    min_obj = np.min(objectives)\n    max_obj = np.max(objectives)\n    if max_obj == min_obj:\n        weights = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (max_obj - objectives) / (max_obj - min_obj)\n        weights = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: segment relocation with edge swapping\n    n = len(new_solution)\n    if n < 4:\n        # Simple edge swap for small instances\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment relocation\n        seg_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Find insertion point that minimizes combined distance\n        min_cost = float('inf')\n        best_insert = 0\n        for pos in range(n - seg_length + 1):\n            if pos == start:\n                continue\n\n            # Create temporary solution\n            temp = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+seg_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert = pos\n\n        # Apply best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_insert],\n            segment,\n            new_solution[best_insert:start],\n            new_solution[start+seg_length:]\n        ])\n\n        # Optional edge swap for further improvement\n        if random.random() < 0.5 and n > 3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement, then applies a hybrid local search operator that combines edge-swapping with a novel segment-reversal mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution):\n        # Calculate the sum of ranks in both objectives\n        cost1, cost2 = solution[1]\n        rank1 = sum(1 for s in archive if s[1][0] < cost1)\n        rank2 = sum(1 for s in archive if s[1][1] < cost2)\n        return rank1 + rank2\n\n    selected = min(archive, key=dominance_score)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Check if reversing improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    new_solution[a:b+1] = reversed_segment\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # If not better in both, try edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8623684901347859,
            0.5577571988105774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution):\n        # Calculate the sum of ranks in both objectives\n        cost1, cost2 = solution[1]\n        rank1 = sum(1 for s in archive if s[1][0] < cost1)\n        rank2 = sum(1 for s in archive if s[1][1] < cost2)\n        return rank1 + rank2\n\n    selected = min(archive, key=dominance_score)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Check if reversing improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    new_solution[a:b+1] = reversed_segment\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # If not better in both, try edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement, then applies a hybrid local search operator that combines edge-swapping with a novel segment-reversal mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution):\n        # Calculate the sum of ranks in both objectives\n        cost1, cost2 = solution[1]\n        rank1 = sum(1 for s in archive if s[1][0] < cost1)\n        rank2 = sum(1 for s in archive if s[1][1] < cost2)\n        return rank1 + rank2\n\n    selected = min(archive, key=dominance_score)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Check if reversing improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    new_solution[a:b+1] = reversed_segment\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # If not better in both, try edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8623684901347859,
            0.5577571988105774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution):\n        # Calculate the sum of ranks in both objectives\n        cost1, cost2 = solution[1]\n        rank1 = sum(1 for s in archive if s[1][0] < cost1)\n        rank2 = sum(1 for s in archive if s[1][1] < cost2)\n        return rank1 + rank2\n\n    selected = min(archive, key=dominance_score)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Check if reversing improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    new_solution[a:b+1] = reversed_segment\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # If not better in both, try edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement, then applies a hybrid local search operator that combines edge-swapping with a novel segment-reversal mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution):\n        # Calculate the sum of ranks in both objectives\n        cost1, cost2 = solution[1]\n        rank1 = sum(1 for s in archive if s[1][0] < cost1)\n        rank2 = sum(1 for s in archive if s[1][1] < cost2)\n        return rank1 + rank2\n\n    selected = min(archive, key=dominance_score)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Check if reversing improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    new_solution[a:b+1] = reversed_segment\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # If not better in both, try edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8623684901347859,
            0.5577571988105774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution):\n        # Calculate the sum of ranks in both objectives\n        cost1, cost2 = solution[1]\n        rank1 = sum(1 for s in archive if s[1][0] < cost1)\n        rank2 = sum(1 for s in archive if s[1][1] < cost2)\n        return rank1 + rank2\n\n    selected = min(archive, key=dominance_score)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Check if reversing improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(new_solution)\n    new_solution[a:b+1] = reversed_segment\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # If not better in both, try edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment relocation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Identify a promising segment to relocate\n    segment_length = random.randint(2, min(4, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Step 2: Remove the segment\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Step 3: Find the best insertion point for the segment\n    best_insert_pos = 0\n    best_improvement = 0\n    for i in range(len(new_solution)):\n        # Calculate the cost of inserting the segment at position i\n        prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < len(new_solution) else new_solution[0]\n        segment_start = segment[0]\n        segment_end = segment[-1]\n\n        # Calculate the change in both objectives\n        delta_cost1 = (distance_matrix_1[prev_node, segment_start] +\n                       distance_matrix_1[segment_end, next_node] -\n                       distance_matrix_1[prev_node, next_node])\n        delta_cost2 = (distance_matrix_2[prev_node, segment_start] +\n                       distance_matrix_2[segment_end, next_node] -\n                       distance_matrix_2[prev_node, next_node])\n\n        # Use a weighted sum of improvements for selection\n        improvement = -delta_cost1 - delta_cost2  # Negative because we want to minimize\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = i\n\n    # Step 4: Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8293946287991834,
            0.6240003108978271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment relocation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Identify a promising segment to relocate\n    segment_length = random.randint(2, min(4, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Step 2: Remove the segment\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Step 3: Find the best insertion point for the segment\n    best_insert_pos = 0\n    best_improvement = 0\n    for i in range(len(new_solution)):\n        # Calculate the cost of inserting the segment at position i\n        prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i] if i < len(new_solution) else new_solution[0]\n        segment_start = segment[0]\n        segment_end = segment[-1]\n\n        # Calculate the change in both objectives\n        delta_cost1 = (distance_matrix_1[prev_node, segment_start] +\n                       distance_matrix_1[segment_end, next_node] -\n                       distance_matrix_1[prev_node, next_node])\n        delta_cost2 = (distance_matrix_2[prev_node, segment_start] +\n                       distance_matrix_2[segment_end, next_node] -\n                       distance_matrix_2[prev_node, next_node])\n\n        # Use a weighted sum of improvements for selection\n        improvement = -delta_cost1 - delta_cost2  # Negative because we want to minimize\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = i\n\n    # Step 4: Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Novel edge insertion: Reinsert a random node at a position that minimizes the sum of both objectives\n    node_to_move = np.random.choice(new_solution)\n    candidate_positions = [i for i in range(n) if new_solution[i] != node_to_move]\n\n    best_pos = -1\n    best_cost = float('inf')\n\n    for pos in candidate_positions:\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        temp_solution = np.insert(temp_solution, pos, node_to_move)\n\n        # Calculate tour costs\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.9267236583595557,
            3.70659738779068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Novel edge insertion: Reinsert a random node at a position that minimizes the sum of both objectives\n    node_to_move = np.random.choice(new_solution)\n    candidate_positions = [i for i in range(n) if new_solution[i] != node_to_move]\n\n    best_pos = -1\n    best_cost = float('inf')\n\n    for pos in candidate_positions:\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        temp_solution = np.insert(temp_solution, pos, node_to_move)\n\n        # Calculate tour costs\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Novel edge insertion: Reinsert a random node at a position that minimizes the sum of both objectives\n    node_to_move = np.random.choice(new_solution)\n    candidate_positions = [i for i in range(n) if new_solution[i] != node_to_move]\n\n    best_pos = -1\n    best_cost = float('inf')\n\n    for pos in candidate_positions:\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        temp_solution = np.insert(temp_solution, pos, node_to_move)\n\n        # Calculate tour costs\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.9267236583595557,
            3.70659738779068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Novel edge insertion: Reinsert a random node at a position that minimizes the sum of both objectives\n    node_to_move = np.random.choice(new_solution)\n    candidate_positions = [i for i in range(n) if new_solution[i] != node_to_move]\n\n    best_pos = -1\n    best_cost = float('inf')\n\n    for pos in candidate_positions:\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        temp_solution = np.insert(temp_solution, pos, node_to_move)\n\n        # Calculate tour costs\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: edge exchange with path relinking\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path relinking: explore intermediate solutions between selected and new solution\n    if random.random() < 0.5:\n        # Randomly select a segment from the selected solution\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        segment = selected_solution[start:end]\n\n        # Insert the segment into the new solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    # Ensure validity (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Fill missing nodes (if any) with remaining nodes\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], missing_nodes, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7357937957784871,
            0.48428618907928467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: edge exchange with path relinking\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path relinking: explore intermediate solutions between selected and new solution\n    if random.random() < 0.5:\n        # Randomly select a segment from the selected solution\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        segment = selected_solution[start:end]\n\n        # Insert the segment into the new solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    # Ensure validity (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Fill missing nodes (if any) with remaining nodes\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], missing_nodes, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: edge exchange with path relinking\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path relinking: explore intermediate solutions between selected and new solution\n    if random.random() < 0.5:\n        # Randomly select a segment from the selected solution\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        segment = selected_solution[start:end]\n\n        # Insert the segment into the new solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    # Ensure validity (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Fill missing nodes (if any) with remaining nodes\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], missing_nodes, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7357937957784871,
            0.48428618907928467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: edge exchange with path relinking\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path relinking: explore intermediate solutions between selected and new solution\n    if random.random() < 0.5:\n        # Randomly select a segment from the selected solution\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        segment = selected_solution[start:end]\n\n        # Insert the segment into the new solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    # Ensure validity (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Fill missing nodes (if any) with remaining nodes\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], missing_nodes, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A hybrid local search algorithm that combines adaptive edge selection with a multi-objective-aware perturbation strategy to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -(x[1][0] + x[1][1]))[0].copy()\n\n    # Adaptive edge selection: identify edges contributing to high cost in either objective\n    n = len(selected_solution)\n    high_cost_edges = set()\n\n    for i in range(n):\n        u, v = selected_solution[i], selected_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_edges.add((u, v))\n\n    # Multi-objective-aware perturbation\n    new_solution = selected_solution.copy()\n    if high_cost_edges:\n        # Randomly select an edge to perturb\n        edge_to_perturb = random.choice(list(high_cost_edges))\n        u, v = edge_to_perturb\n\n        # Find positions of u and v in the tour\n        u_pos = np.where(new_solution == u)[0][0]\n        v_pos = np.where(new_solution == v)[0][0]\n\n        # Ensure we don't break the tour\n        if abs(u_pos - v_pos) > 1:\n            # Reverse the segment between u and v\n            if u_pos < v_pos:\n                new_solution[u_pos:v_pos+1] = new_solution[u_pos:v_pos+1][::-1]\n            else:\n                new_solution[v_pos:u_pos+1] = new_solution[v_pos:u_pos+1][::-1]\n    else:\n        # If no high-cost edges, perform a random 3-opt\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution[a:b+1] = new_solution[b:a-1:-1]\n        new_solution[b:c+1] = new_solution[c:b-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7028437453966871,
            4.062913179397583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -(x[1][0] + x[1][1]))[0].copy()\n\n    # Adaptive edge selection: identify edges contributing to high cost in either objective\n    n = len(selected_solution)\n    high_cost_edges = set()\n\n    for i in range(n):\n        u, v = selected_solution[i], selected_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_edges.add((u, v))\n\n    # Multi-objective-aware perturbation\n    new_solution = selected_solution.copy()\n    if high_cost_edges:\n        # Randomly select an edge to perturb\n        edge_to_perturb = random.choice(list(high_cost_edges))\n        u, v = edge_to_perturb\n\n        # Find positions of u and v in the tour\n        u_pos = np.where(new_solution == u)[0][0]\n        v_pos = np.where(new_solution == v)[0][0]\n\n        # Ensure we don't break the tour\n        if abs(u_pos - v_pos) > 1:\n            # Reverse the segment between u and v\n            if u_pos < v_pos:\n                new_solution[u_pos:v_pos+1] = new_solution[u_pos:v_pos+1][::-1]\n            else:\n                new_solution[v_pos:u_pos+1] = new_solution[v_pos:u_pos+1][::-1]\n    else:\n        # If no high-cost edges, perform a random 3-opt\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution[a:b+1] = new_solution[b:a-1:-1]\n        new_solution[b:c+1] = new_solution[c:b-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on non-dominated or diverse objectives, then applies a hybrid local search combining edge insertion and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse or non-dominated objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and insert it in a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_pos += 1\n    new_solution = np.insert(new_solution, new_pos, new_solution[node_to_move])\n    new_solution = np.delete(new_solution, node_to_move if node_to_move < new_pos else node_to_move + 1)\n\n    # Segment relocation: move a random segment to a new position\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_start + segment_length])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.928056390661672,
            0.4751770496368408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse or non-dominated objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and insert it in a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_pos += 1\n    new_solution = np.insert(new_solution, new_pos, new_solution[node_to_move])\n    new_solution = np.delete(new_solution, node_to_move if node_to_move < new_pos else node_to_move + 1)\n\n    # Segment relocation: move a random segment to a new position\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_start + segment_length])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on non-dominated or diverse objectives, then applies a hybrid local search combining edge insertion and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse or non-dominated objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and insert it in a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_pos += 1\n    new_solution = np.insert(new_solution, new_pos, new_solution[node_to_move])\n    new_solution = np.delete(new_solution, node_to_move if node_to_move < new_pos else node_to_move + 1)\n\n    # Segment relocation: move a random segment to a new position\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_start + segment_length])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.928056390661672,
            0.4751770496368408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse or non-dominated objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and insert it in a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_pos += 1\n    new_solution = np.insert(new_solution, new_pos, new_solution[node_to_move])\n    new_solution = np.delete(new_solution, node_to_move if node_to_move < new_pos else node_to_move + 1)\n\n    # Segment relocation: move a random segment to a new position\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_start + segment_length])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on non-dominated or diverse objectives, then applies a hybrid local search combining edge insertion and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse or non-dominated objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and insert it in a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_pos += 1\n    new_solution = np.insert(new_solution, new_pos, new_solution[node_to_move])\n    new_solution = np.delete(new_solution, node_to_move if node_to_move < new_pos else node_to_move + 1)\n\n    # Segment relocation: move a random segment to a new position\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_start + segment_length])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.928056390661672,
            0.4751770496368408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse or non-dominated objectives\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and insert it in a new position\n    node_to_move = random.randint(0, n-1)\n    new_pos = random.randint(0, n-1)\n    if new_pos > node_to_move:\n        new_pos += 1\n    new_solution = np.insert(new_solution, new_pos, new_solution[node_to_move])\n    new_solution = np.delete(new_solution, node_to_move if node_to_move < new_pos else node_to_move + 1)\n\n    # Segment relocation: move a random segment to a new position\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_start + segment_length])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (descending)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select a node and reinsert it elsewhere\n    node_to_move = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure validity (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8916188402803602,
            0.5338243246078491
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (descending)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select a node and reinsert it elsewhere\n    node_to_move = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure validity (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic edge exchange mechanism to explore high-quality solutions by probabilistically selecting and swapping segments of the tour while maintaining feasibility, guided by both objective spaces' distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic segment exchange with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to exchange\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are of reasonable size\n    a, b = max(0, a - 1), min(n - 1, b + 1)\n    c, d = max(0, c - 1), min(n - 1, d + 1)\n\n    # Calculate the cost change for both objectives\n    def calculate_cost_change(solution, a, b, c, d):\n        # Original edges\n        orig_edges = [\n            (solution[a-1], solution[a]),\n            (solution[b], solution[(b+1)%n]),\n            (solution[c-1], solution[c]),\n            (solution[d], solution[(d+1)%n])\n        ]\n\n        # New edges if segments are swapped\n        new_edges = [\n            (solution[a-1], solution[c]),\n            (solution[d], solution[(b+1)%n]),\n            (solution[c-1], solution[a]),\n            (solution[b], solution[(d+1)%n])\n        ]\n\n        cost1_change = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in orig_edges)\n        cost2_change = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in orig_edges)\n\n        return cost1_change, cost2_change\n\n    cost1_change, cost2_change = calculate_cost_change(new_solution, a, b, c, d)\n\n    # Apply the exchange if it improves at least one objective\n    if cost1_change < 0 or cost2_change < 0:\n        # Perform the segment exchange\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Create new solution by swapping segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure the tour is valid (no duplicates, all nodes present)\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n\n    # If no improvement, perform a biased random walk\n    # Randomly select a node and insert it in a better position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Find the best insertion point for the node\n    best_pos = -1\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for i in range(n):\n        if i == node_idx or i == (node_idx + 1) % n:\n            continue\n\n        # Create a temporary solution with node moved to position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            np.array([node]),\n            new_solution[i:node_idx] if node_idx > i else new_solution[i:node_idx + 1],\n            new_solution[node_idx + 1:] if node_idx > i else new_solution[node_idx:]\n        ])\n\n        # Calculate the cost change\n        cost1 = sum(distance_matrix_1[temp_solution[j]][temp_solution[(j+1)%n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[j]][temp_solution[(j+1)%n]] for j in range(n))\n\n        # Select the position that improves both objectives\n        if cost1 < best_cost1 and cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = i\n\n    if best_pos != -1:\n        # Perform the insertion\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            np.array([node]),\n            new_solution[best_pos:node_idx] if node_idx > best_pos else new_solution[best_pos:node_idx + 1],\n            new_solution[node_idx + 1:] if node_idx > best_pos else new_solution[node_idx:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7636022685659766,
            2.0425907373428345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic segment exchange with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to exchange\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are of reasonable size\n    a, b = max(0, a - 1), min(n - 1, b + 1)\n    c, d = max(0, c - 1), min(n - 1, d + 1)\n\n    # Calculate the cost change for both objectives\n    def calculate_cost_change(solution, a, b, c, d):\n        # Original edges\n        orig_edges = [\n            (solution[a-1], solution[a]),\n            (solution[b], solution[(b+1)%n]),\n            (solution[c-1], solution[c]),\n            (solution[d], solution[(d+1)%n])\n        ]\n\n        # New edges if segments are swapped\n        new_edges = [\n            (solution[a-1], solution[c]),\n            (solution[d], solution[(b+1)%n]),\n            (solution[c-1], solution[a]),\n            (solution[b], solution[(d+1)%n])\n        ]\n\n        cost1_change = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in orig_edges)\n        cost2_change = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in orig_edges)\n\n        return cost1_change, cost2_change\n\n    cost1_change, cost2_change = calculate_cost_change(new_solution, a, b, c, d)\n\n    # Apply the exchange if it improves at least one objective\n    if cost1_change < 0 or cost2_change < 0:\n        # Perform the segment exchange\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Create new solution by swapping segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure the tour is valid (no duplicates, all nodes present)\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n\n    # If no improvement, perform a biased random walk\n    # Randomly select a node and insert it in a better position\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Find the best insertion point for the node\n    best_pos = -1\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for i in range(n):\n        if i == node_idx or i == (node_idx + 1) % n:\n            continue\n\n        # Create a temporary solution with node moved to position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            np.array([node]),\n            new_solution[i:node_idx] if node_idx > i else new_solution[i:node_idx + 1],\n            new_solution[node_idx + 1:] if node_idx > i else new_solution[node_idx:]\n        ])\n\n        # Calculate the cost change\n        cost1 = sum(distance_matrix_1[temp_solution[j]][temp_solution[(j+1)%n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[j]][temp_solution[(j+1)%n]] for j in range(n))\n\n        # Select the position that improves both objectives\n        if cost1 < best_cost1 and cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = i\n\n    if best_pos != -1:\n        # Perform the insertion\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            np.array([node]),\n            new_solution[best_pos:node_idx] if node_idx > best_pos else new_solution[best_pos:node_idx + 1],\n            new_solution[node_idx + 1:] if node_idx > best_pos else new_solution[node_idx:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its non-dominated status and diversity, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[(edge_start + 1) % n]\n\n    # Remove the edge\n    new_solution = np.delete(new_solution, edge_start)\n    if edge_start < len(new_solution):\n        new_solution = np.delete(new_solution, edge_start)\n    else:\n        new_solution = np.delete(new_solution, 0)\n\n    # Insert the edge at a new position\n    insert_pos = np.random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, [edge_node1, edge_node2])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8921417850829612,
            0.4699147343635559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[(edge_start + 1) % n]\n\n    # Remove the edge\n    new_solution = np.delete(new_solution, edge_start)\n    if edge_start < len(new_solution):\n        new_solution = np.delete(new_solution, edge_start)\n    else:\n        new_solution = np.delete(new_solution, 0)\n\n    # Insert the edge at a new position\n    insert_pos = np.random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, [edge_node1, edge_node2])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its non-dominated status and diversity, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[(edge_start + 1) % n]\n\n    # Remove the edge\n    new_solution = np.delete(new_solution, edge_start)\n    if edge_start < len(new_solution):\n        new_solution = np.delete(new_solution, edge_start)\n    else:\n        new_solution = np.delete(new_solution, 0)\n\n    # Insert the edge at a new position\n    insert_pos = np.random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, [edge_node1, edge_node2])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8921417850829612,
            0.4699147343635559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[(edge_start + 1) % n]\n\n    # Remove the edge\n    new_solution = np.delete(new_solution, edge_start)\n    if edge_start < len(new_solution):\n        new_solution = np.delete(new_solution, edge_start)\n    else:\n        new_solution = np.delete(new_solution, 0)\n\n    # Insert the edge at a new position\n    insert_pos = np.random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, [edge_node1, edge_node2])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: np.std(x[1]))[0].copy()\n    new_solution = selected.copy()\n\n    # Apply a hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Compute objective-aware edge weights\n        edge_weights = (\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[k]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[k]]\n        )\n        # Perform 3-opt move if it improves both objectives\n        if edge_weights > 0:  # Placeholder for actual improvement check\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5445012001371615,
            0.6972509622573853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: np.std(x[1]))[0].copy()\n    new_solution = selected.copy()\n\n    # Apply a hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Compute objective-aware edge weights\n        edge_weights = (\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[k]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[k]]\n        )\n        # Perform 3-opt move if it improves both objectives\n        if edge_weights > 0:  # Placeholder for actual improvement check\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform segment reversal and swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility by repairing the tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.3609621865108253,
            0.46580904722213745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform segment reversal and swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility by repairing the tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform segment reversal and swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility by repairing the tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.3609621865108253,
            0.46580904722213745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform segment reversal and swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility by repairing the tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator that combines adaptive edge exchange with objective-aware segment reversal to explore promising regions in the solution space while maintaining feasibility, ensuring diverse high-quality neighbors are generated from intelligently selected archive solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: Adaptive Edge Exchange + Objective-Aware Segment Reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Adaptive Edge Exchange (select edges with high potential for improvement)\n    for _ in range(3):  # Perform multiple exchanges\n        # Randomly select two edges to disconnect\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Check if exchange is feasible and improves objectives\n        if (i != k and j != l and i != l and j != k):\n            # Create new edges by reconnecting\n            new_edges = [(i, k), (j, l)]\n            # Evaluate potential improvement\n            old_cost = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                        distance_matrix_1[selected_solution[k], selected_solution[l]] +\n                        distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                        distance_matrix_2[selected_solution[k], selected_solution[l]])\n            new_cost = (distance_matrix_1[selected_solution[i], selected_solution[k]] +\n                        distance_matrix_1[selected_solution[j], selected_solution[l]] +\n                        distance_matrix_2[selected_solution[i], selected_solution[k]] +\n                        distance_matrix_2[selected_solution[j], selected_solution[l]])\n            if new_cost < old_cost:\n                # Perform the exchange\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 2: Objective-Aware Segment Reversal (reverse segments to improve objectives)\n    for _ in range(2):  # Perform multiple reversals\n        # Select a segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Evaluate potential improvement\n        old_segment_cost = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + \\\n                          sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        reversed_segment = segment[::-1]\n        new_segment_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1)) + \\\n                          sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        if new_segment_cost < old_segment_cost:\n            # Perform the reversal\n            new_solution[start:end+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8058533189396112,
            0.5140795111656189
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: Adaptive Edge Exchange + Objective-Aware Segment Reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Adaptive Edge Exchange (select edges with high potential for improvement)\n    for _ in range(3):  # Perform multiple exchanges\n        # Randomly select two edges to disconnect\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Check if exchange is feasible and improves objectives\n        if (i != k and j != l and i != l and j != k):\n            # Create new edges by reconnecting\n            new_edges = [(i, k), (j, l)]\n            # Evaluate potential improvement\n            old_cost = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                        distance_matrix_1[selected_solution[k], selected_solution[l]] +\n                        distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                        distance_matrix_2[selected_solution[k], selected_solution[l]])\n            new_cost = (distance_matrix_1[selected_solution[i], selected_solution[k]] +\n                        distance_matrix_1[selected_solution[j], selected_solution[l]] +\n                        distance_matrix_2[selected_solution[i], selected_solution[k]] +\n                        distance_matrix_2[selected_solution[j], selected_solution[l]])\n            if new_cost < old_cost:\n                # Perform the exchange\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 2: Objective-Aware Segment Reversal (reverse segments to improve objectives)\n    for _ in range(2):  # Perform multiple reversals\n        # Select a segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Evaluate potential improvement\n        old_segment_cost = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + \\\n                          sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        reversed_segment = segment[::-1]\n        new_segment_cost = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1)) + \\\n                          sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        if new_segment_cost < old_segment_cost:\n            # Perform the reversal\n            new_solution[start:end+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A hybrid local search algorithm that combines a novel edge-swap strategy with adaptive perturbation to explore high-quality regions in the solution space while maintaining feasibility, prioritizing solutions with balanced trade-offs between objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.linalg.norm(normalized - 0.5, axis=1)\n        selected_idx = np.argmin(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge-swap with perturbation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(1, n-1)\n\n    # Perform a novel edge-swap operation\n    if np.random.rand() < 0.7:\n        # Reverse a segment and insert it elsewhere\n        segment = base_solution[i:j]\n        new_solution = np.concatenate([base_solution[:i], segment[::-1], base_solution[j:]])\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:insert_pos], [new_solution[i]], new_solution[insert_pos:]])\n    else:\n        # Rotate a segment\n        segment = base_solution[i:i+k]\n        new_solution = np.concatenate([base_solution[:i], segment[k:], segment[:k], base_solution[i+k:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            replace_pos = np.where(new_solution == dup)[0][1]\n            new_solution[replace_pos] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9346401705990361,
            0.4867127537727356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.linalg.norm(normalized - 0.5, axis=1)\n        selected_idx = np.argmin(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge-swap with perturbation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(1, n-1)\n\n    # Perform a novel edge-swap operation\n    if np.random.rand() < 0.7:\n        # Reverse a segment and insert it elsewhere\n        segment = base_solution[i:j]\n        new_solution = np.concatenate([base_solution[:i], segment[::-1], base_solution[j:]])\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:insert_pos], [new_solution[i]], new_solution[insert_pos:]])\n    else:\n        # Rotate a segment\n        segment = base_solution[i:i+k]\n        new_solution = np.concatenate([base_solution[:i], segment[k:], segment[:k], base_solution[i+k:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            replace_pos = np.where(new_solution == dup)[0][1]\n            new_solution[replace_pos] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A hybrid local search algorithm that combines a novel edge-swap strategy with adaptive perturbation to explore high-quality regions in the solution space while maintaining feasibility, prioritizing solutions with balanced trade-offs between objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.linalg.norm(normalized - 0.5, axis=1)\n        selected_idx = np.argmin(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge-swap with perturbation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(1, n-1)\n\n    # Perform a novel edge-swap operation\n    if np.random.rand() < 0.7:\n        # Reverse a segment and insert it elsewhere\n        segment = base_solution[i:j]\n        new_solution = np.concatenate([base_solution[:i], segment[::-1], base_solution[j:]])\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:insert_pos], [new_solution[i]], new_solution[insert_pos:]])\n    else:\n        # Rotate a segment\n        segment = base_solution[i:i+k]\n        new_solution = np.concatenate([base_solution[:i], segment[k:], segment[:k], base_solution[i+k:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            replace_pos = np.where(new_solution == dup)[0][1]\n            new_solution[replace_pos] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9346401705990361,
            0.4867127537727356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        distances = np.linalg.norm(normalized - 0.5, axis=1)\n        selected_idx = np.argmin(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge-swap with perturbation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(1, n-1)\n\n    # Perform a novel edge-swap operation\n    if np.random.rand() < 0.7:\n        # Reverse a segment and insert it elsewhere\n        segment = base_solution[i:j]\n        new_solution = np.concatenate([base_solution[:i], segment[::-1], base_solution[j:]])\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:insert_pos], [new_solution[i]], new_solution[insert_pos:]])\n    else:\n        # Rotate a segment\n        segment = base_solution[i:i+k]\n        new_solution = np.concatenate([base_solution[:i], segment[k:], segment[:k], base_solution[i+k:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            replace_pos = np.where(new_solution == dup)[0][1]\n            new_solution[replace_pos] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined normalized improvement potential in both objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized improvement potential\n    def improvement_potential(solution, obj):\n        total_cost = obj[0] + obj[1]\n        if total_cost == 0:\n            return 0\n        # Estimate potential improvement by considering edge diversity\n        unique_edges = len(np.unique(solution))\n        return (unique_edges / len(solution)) * (1 - min(obj[0], obj[1]) / total_cost)\n\n    archive_with_potential = [(sol, obj, improvement_potential(sol, obj)) for sol, obj in archive]\n    archive_with_potential.sort(key=lambda x: -x[2])\n    base_solution = archive_with_potential[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to reverse or swap\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        # With 50% probability, reverse the segment\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Otherwise, perform a random edge swap\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above causes duplicates\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.39882667855306214,
            0.5777454972267151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized improvement potential\n    def improvement_potential(solution, obj):\n        total_cost = obj[0] + obj[1]\n        if total_cost == 0:\n            return 0\n        # Estimate potential improvement by considering edge diversity\n        unique_edges = len(np.unique(solution))\n        return (unique_edges / len(solution)) * (1 - min(obj[0], obj[1]) / total_cost)\n\n    archive_with_potential = [(sol, obj, improvement_potential(sol, obj)) for sol, obj in archive]\n    archive_with_potential.sort(key=lambda x: -x[2])\n    base_solution = archive_with_potential[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to reverse or swap\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        # With 50% probability, reverse the segment\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Otherwise, perform a random edge swap\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above causes duplicates\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined normalized improvement potential in both objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized improvement potential\n    def improvement_potential(solution, obj):\n        total_cost = obj[0] + obj[1]\n        if total_cost == 0:\n            return 0\n        # Estimate potential improvement by considering edge diversity\n        unique_edges = len(np.unique(solution))\n        return (unique_edges / len(solution)) * (1 - min(obj[0], obj[1]) / total_cost)\n\n    archive_with_potential = [(sol, obj, improvement_potential(sol, obj)) for sol, obj in archive]\n    archive_with_potential.sort(key=lambda x: -x[2])\n    base_solution = archive_with_potential[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to reverse or swap\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        # With 50% probability, reverse the segment\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Otherwise, perform a random edge swap\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above causes duplicates\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.39882667855306214,
            0.5777454972267151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized improvement potential\n    def improvement_potential(solution, obj):\n        total_cost = obj[0] + obj[1]\n        if total_cost == 0:\n            return 0\n        # Estimate potential improvement by considering edge diversity\n        unique_edges = len(np.unique(solution))\n        return (unique_edges / len(solution)) * (1 - min(obj[0], obj[1]) / total_cost)\n\n    archive_with_potential = [(sol, obj, improvement_potential(sol, obj)) for sol, obj in archive]\n    archive_with_potential.sort(key=lambda x: -x[2])\n    base_solution = archive_with_potential[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to reverse or swap\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        # With 50% probability, reverse the segment\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Otherwise, perform a random edge swap\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above causes duplicates\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined normalized improvement potential in both objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized improvement potential\n    def improvement_potential(solution, obj):\n        total_cost = obj[0] + obj[1]\n        if total_cost == 0:\n            return 0\n        # Estimate potential improvement by considering edge diversity\n        unique_edges = len(np.unique(solution))\n        return (unique_edges / len(solution)) * (1 - min(obj[0], obj[1]) / total_cost)\n\n    archive_with_potential = [(sol, obj, improvement_potential(sol, obj)) for sol, obj in archive]\n    archive_with_potential.sort(key=lambda x: -x[2])\n    base_solution = archive_with_potential[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to reverse or swap\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        # With 50% probability, reverse the segment\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Otherwise, perform a random edge swap\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above causes duplicates\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.39882667855306214,
            0.5777454972267151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized improvement potential\n    def improvement_potential(solution, obj):\n        total_cost = obj[0] + obj[1]\n        if total_cost == 0:\n            return 0\n        # Estimate potential improvement by considering edge diversity\n        unique_edges = len(np.unique(solution))\n        return (unique_edges / len(solution)) * (1 - min(obj[0], obj[1]) / total_cost)\n\n    archive_with_potential = [(sol, obj, improvement_potential(sol, obj)) for sol, obj in archive]\n    archive_with_potential.sort(key=lambda x: -x[2])\n    base_solution = archive_with_potential[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to reverse or swap\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        # With 50% probability, reverse the segment\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Otherwise, perform a random edge swap\n            k, l = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above causes duplicates\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment inversion with multi-objective edge swapping to intelligently explore the solution space while ensuring feasibility and diversity, prioritizing solutions with high potential for improvement by evaluating their edge diversity and objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by edge diversity)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + np.sum(np.abs(np.diff(sol[0])))) for sol in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion + multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment inversion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate potential swap in both objectives\n        orig_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_1[base_solution[j-1], base_solution[j]])\n        new_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_1[base_solution[j-1], base_solution[i]])\n\n        orig_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_2[base_solution[j-1], base_solution[j]])\n        new_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_2[base_solution[j-1], base_solution[i]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8819857314108759,
            0.6064570546150208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by edge diversity)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + np.sum(np.abs(np.diff(sol[0])))) for sol in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion + multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment inversion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate potential swap in both objectives\n        orig_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_1[base_solution[j-1], base_solution[j]])\n        new_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_1[base_solution[j-1], base_solution[i]])\n\n        orig_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_2[base_solution[j-1], base_solution[j]])\n        new_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_2[base_solution[j-1], base_solution[i]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment inversion with multi-objective edge swapping to intelligently explore the solution space while ensuring feasibility and diversity, prioritizing solutions with high potential for improvement by evaluating their edge diversity and objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by edge diversity)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + np.sum(np.abs(np.diff(sol[0])))) for sol in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion + multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment inversion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate potential swap in both objectives\n        orig_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_1[base_solution[j-1], base_solution[j]])\n        new_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_1[base_solution[j-1], base_solution[i]])\n\n        orig_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_2[base_solution[j-1], base_solution[j]])\n        new_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_2[base_solution[j-1], base_solution[i]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8819857314108759,
            0.6064570546150208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by edge diversity)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + np.sum(np.abs(np.diff(sol[0])))) for sol in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion + multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment inversion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Evaluate potential swap in both objectives\n        orig_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_1[base_solution[j-1], base_solution[j]])\n        new_cost1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_1[base_solution[j-1], base_solution[i]])\n\n        orig_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                      distance_matrix_2[base_solution[j-1], base_solution[j]])\n        new_cost2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                     distance_matrix_2[base_solution[j-1], base_solution[i]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A hybrid local search strategy combines a dynamic edge exchange mechanism with a multi-objective-aware perturbation to explore high-quality solutions by iteratively selecting and modifying critical edges while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge exchange with multi-objective perturbation\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Step 1: Identify critical edges (high cost in either space)\n    critical_edges = []\n    for i in range(n):\n        u, v = selected[i], selected[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Step 2: Exchange a critical edge with a random edge\n        idx = np.random.choice(critical_edges)\n        new_idx = np.random.choice([i for i in range(n) if i not in critical_edges])\n        new_solution[idx], new_solution[new_idx] = new_solution[new_idx], new_solution[idx]\n\n    # Step 3: Apply multi-objective perturbation (swap nodes based on combined cost)\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        u, v = new_solution[i], new_solution[j]\n        cost1 = distance_matrix_1[u, v] + distance_matrix_1[new_solution[(i-1)%n], v] + distance_matrix_1[u, new_solution[(j+1)%n]]\n        cost2 = distance_matrix_2[u, v] + distance_matrix_2[new_solution[(i-1)%n], v] + distance_matrix_2[u, new_solution[(j+1)%n]]\n        if cost1 + cost2 < distance_matrix_1[u, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(j-1)%n], u] + \\\n                         distance_matrix_2[u, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(j-1)%n], u]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8788557538084627,
            1.0845212936401367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge exchange with multi-objective perturbation\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Step 1: Identify critical edges (high cost in either space)\n    critical_edges = []\n    for i in range(n):\n        u, v = selected[i], selected[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Step 2: Exchange a critical edge with a random edge\n        idx = np.random.choice(critical_edges)\n        new_idx = np.random.choice([i for i in range(n) if i not in critical_edges])\n        new_solution[idx], new_solution[new_idx] = new_solution[new_idx], new_solution[idx]\n\n    # Step 3: Apply multi-objective perturbation (swap nodes based on combined cost)\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        u, v = new_solution[i], new_solution[j]\n        cost1 = distance_matrix_1[u, v] + distance_matrix_1[new_solution[(i-1)%n], v] + distance_matrix_1[u, new_solution[(j+1)%n]]\n        cost2 = distance_matrix_2[u, v] + distance_matrix_2[new_solution[(i-1)%n], v] + distance_matrix_2[u, new_solution[(j+1)%n]]\n        if cost1 + cost2 < distance_matrix_1[u, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(j-1)%n], u] + \\\n                         distance_matrix_2[u, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(j-1)%n], u]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with low objective values and applies a hybrid local search operator that combines edge insertion with a novel segment reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (novel segment reversal)\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert (edge insertion)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8678261815377508,
            0.7384258508682251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (novel segment reversal)\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert (edge insertion)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Randomly select from top 30% of solutions\n        top_k = max(1, int(0.3 * len(archive_sorted)))\n        selected = archive_sorted[np.random.randint(top_k)]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure distinct indices\n    while j == i or k == i or k == j:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    # 3-opt move\n    if i > j:\n        i, j = j, i\n    if j > k:\n        j, k = k, j\n    if i > j:\n        i, j = j, i\n\n    # Create three segments and reverse the middle one\n    segment1 = base_solution[:i]\n    segment2 = base_solution[i:j][::-1]\n    segment3 = base_solution[j:k][::-1]\n    segment4 = base_solution[k:]\n\n    new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n\n    # Novel edge-swap: swap edges based on distance improvement in both objectives\n    for _ in range(3):  # Limited attempts to find improving swaps\n        a, b = np.random.randint(0, n, size=2)\n        while b == a or (a + 1) % n == b or (b + 1) % n == a:\n            a, b = np.random.randint(0, n, size=2)\n\n        # Get current and potential edges\n        current_edges = [\n            (base_solution[a], base_solution[(a + 1) % n]),\n            (base_solution[b], base_solution[(b + 1) % n])\n        ]\n        new_edges = [\n            (base_solution[a], base_solution[b]),\n            (base_solution[(a + 1) % n], base_solution[(b + 1) % n])\n        ]\n\n        # Calculate cost difference in both objectives\n        cost_diff1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_1[current_edges[0][0], current_edges[0][1]] -\n                      distance_matrix_1[current_edges[1][0], current_edges[1][1]])\n\n        cost_diff2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_2[current_edges[0][0], current_edges[0][1]] -\n                      distance_matrix_2[current_edges[1][0], current_edges[1][1]])\n\n        # If both objectives improve, perform the swap\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8728162568473947,
            0.7490065693855286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Randomly select from top 30% of solutions\n        top_k = max(1, int(0.3 * len(archive_sorted)))\n        selected = archive_sorted[np.random.randint(top_k)]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure distinct indices\n    while j == i or k == i or k == j:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    # 3-opt move\n    if i > j:\n        i, j = j, i\n    if j > k:\n        j, k = k, j\n    if i > j:\n        i, j = j, i\n\n    # Create three segments and reverse the middle one\n    segment1 = base_solution[:i]\n    segment2 = base_solution[i:j][::-1]\n    segment3 = base_solution[j:k][::-1]\n    segment4 = base_solution[k:]\n\n    new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n\n    # Novel edge-swap: swap edges based on distance improvement in both objectives\n    for _ in range(3):  # Limited attempts to find improving swaps\n        a, b = np.random.randint(0, n, size=2)\n        while b == a or (a + 1) % n == b or (b + 1) % n == a:\n            a, b = np.random.randint(0, n, size=2)\n\n        # Get current and potential edges\n        current_edges = [\n            (base_solution[a], base_solution[(a + 1) % n]),\n            (base_solution[b], base_solution[(b + 1) % n])\n        ]\n        new_edges = [\n            (base_solution[a], base_solution[b]),\n            (base_solution[(a + 1) % n], base_solution[(b + 1) % n])\n        ]\n\n        # Calculate cost difference in both objectives\n        cost_diff1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_1[current_edges[0][0], current_edges[0][1]] -\n                      distance_matrix_1[current_edges[1][0], current_edges[1][1]])\n\n        cost_diff2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_2[current_edges[0][0], current_edges[0][1]] -\n                      distance_matrix_2[current_edges[1][0], current_edges[1][1]])\n\n        # If both objectives improve, perform the swap\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining edge insertion and segment reversal to explore the solution space while ensuring feasibility and diversity in generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random positions\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: remove segment [i:j] and reinsert at a random position\n    removed_segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, removed_segment)\n\n    # Segment reversal: reverse a random segment\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to base solution and apply a simpler operator\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7991291739852817,
            0.49971073865890503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random positions\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: remove segment [i:j] and reinsert at a random position\n    removed_segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, removed_segment)\n\n    # Segment reversal: reverse a random segment\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to base solution and apply a simpler operator\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining edge insertion and segment reversal to explore the solution space while ensuring feasibility and diversity in generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random positions\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: remove segment [i:j] and reinsert at a random position\n    removed_segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, removed_segment)\n\n    # Segment reversal: reverse a random segment\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to base solution and apply a simpler operator\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7991291739852817,
            0.49971073865890503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Select two random positions\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: remove segment [i:j] and reinsert at a random position\n    removed_segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, removed_segment)\n\n    # Segment reversal: reverse a random segment\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to base solution and apply a simpler operator\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Randomly select a segment to reverse (3-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to reconnect (insertion-like move)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != 0 and b != n-1:\n        new_solution[a:b] = np.roll(new_solution[a:b], shift=1)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5405141063279955,
            0.49754059314727783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Randomly select a segment to reverse (3-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to reconnect (insertion-like move)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != 0 and b != n-1:\n        new_solution[a:b] = np.roll(new_solution[a:b], shift=1)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Randomly select a segment to reverse (3-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to reconnect (insertion-like move)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != 0 and b != n-1:\n        new_solution[a:b] = np.roll(new_solution[a:b], shift=1)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5405141063279955,
            0.49754059314727783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search combining edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Randomly select a segment to reverse (3-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to reconnect (insertion-like move)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != 0 and b != n-1:\n        new_solution[a:b] = np.roll(new_solution[a:b], shift=1)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for local improvement, then applies a hybrid local search operator that combines edge insertion with a novel segment reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: Edge Insertion + Segment Reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (segment reversal)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (edge insertion)\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6944960162465303,
            0.5101391673088074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: Edge Insertion + Segment Reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (segment reversal)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert (edge insertion)\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    if a != b:\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high crowding distance (indicating under-explored regions) and applies a hybrid local search combining edge insertion and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(obj1, obj2):\n        return np.linalg.norm(np.array(obj1) - np.array(obj2))\n\n    # Calculate crowding distances for all solutions\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        total_dist = 0.0\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j:\n                total_dist += crowding_distance(obj, other_obj)\n        crowding_distances.append(total_dist)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion + node relocation\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n        # Edge insertion: insert node j between i and k\n        if i != j and j != k and i != k:\n            temp = new_solution.copy()\n            temp[i] = new_solution[j]\n            temp[j] = new_solution[i]\n\n            # Check feasibility (no duplicates)\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n        # Node relocation: move node j to position k\n        if i != j and i != k:\n            temp = new_solution.copy()\n            node = temp[j]\n            temp = np.delete(temp, j)\n            temp = np.insert(temp, k, node)\n\n            # Check feasibility\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7328153713133692,
            1.6664029955863953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(obj1, obj2):\n        return np.linalg.norm(np.array(obj1) - np.array(obj2))\n\n    # Calculate crowding distances for all solutions\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        total_dist = 0.0\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j:\n                total_dist += crowding_distance(obj, other_obj)\n        crowding_distances.append(total_dist)\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion + node relocation\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n        # Edge insertion: insert node j between i and k\n        if i != j and j != k and i != k:\n            temp = new_solution.copy()\n            temp[i] = new_solution[j]\n            temp[j] = new_solution[i]\n\n            # Check feasibility (no duplicates)\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n        # Node relocation: move node j to position k\n        if i != j and i != k:\n            temp = new_solution.copy()\n            node = temp[j]\n            temp = np.delete(temp, j)\n            temp = np.insert(temp, k, node)\n\n            # Check feasibility\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a guided edge recombination strategy to explore diverse neighborhoods while preserving feasibility, ensuring high-quality solutions across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity\n    objectives = np.array([obj for (sol, obj) in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: Multi-segment relocation with guided edge recombination\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Identify critical segments (high cost edges)\n    def get_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(N):\n            cost += dist_matrix[sol[i], sol[(i+1)%N]]\n        return cost\n\n    cost1 = get_cost(new_solution, distance_matrix_1)\n    cost2 = get_cost(new_solution, distance_matrix_2)\n\n    # Find edges with high combined cost\n    edge_costs = []\n    for i in range(N):\n        cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n        edge_costs.append(cost)\n    edge_costs = np.array(edge_costs)\n    critical_edges = np.argsort(edge_costs)[-2:]  # Top 2 critical edges\n\n    # Step 2: Relocate segments between critical edges\n    for edge in critical_edges:\n        start = edge\n        end = (start + np.random.randint(2, 5)) % N  # Relocate segment of random size (2-4 nodes)\n        segment = new_solution[start:end]\n        remaining = np.setdiff1d(new_solution, segment)\n\n        # Find insertion point with minimal combined cost\n        min_cost = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            candidate = np.insert(remaining, i, segment)\n            new_cost1 = get_cost(candidate, distance_matrix_1)\n            new_cost2 = get_cost(candidate, distance_matrix_2)\n            combined_cost = new_cost1 + new_cost2\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        new_solution = np.insert(remaining, best_pos, segment)\n\n    # Step 3: Guided edge recombination (swap edges that improve both objectives)\n    for _ in range(3):  # Limit to 3 swaps\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate solution by swapping edges i->i+1 and j->j+1\n        candidate = new_solution.copy()\n        candidate[i+1:j+1] = np.flip(candidate[i+1:j+1])\n\n        # Check if both objectives improve\n        new_cost1 = get_cost(candidate, distance_matrix_1)\n        new_cost2 = get_cost(candidate, distance_matrix_2)\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            new_solution = candidate\n            cost1, cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.942680010381084,
            6.8121660351753235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity\n    objectives = np.array([obj for (sol, obj) in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: Multi-segment relocation with guided edge recombination\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Identify critical segments (high cost edges)\n    def get_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(N):\n            cost += dist_matrix[sol[i], sol[(i+1)%N]]\n        return cost\n\n    cost1 = get_cost(new_solution, distance_matrix_1)\n    cost2 = get_cost(new_solution, distance_matrix_2)\n\n    # Find edges with high combined cost\n    edge_costs = []\n    for i in range(N):\n        cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n        edge_costs.append(cost)\n    edge_costs = np.array(edge_costs)\n    critical_edges = np.argsort(edge_costs)[-2:]  # Top 2 critical edges\n\n    # Step 2: Relocate segments between critical edges\n    for edge in critical_edges:\n        start = edge\n        end = (start + np.random.randint(2, 5)) % N  # Relocate segment of random size (2-4 nodes)\n        segment = new_solution[start:end]\n        remaining = np.setdiff1d(new_solution, segment)\n\n        # Find insertion point with minimal combined cost\n        min_cost = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            candidate = np.insert(remaining, i, segment)\n            new_cost1 = get_cost(candidate, distance_matrix_1)\n            new_cost2 = get_cost(candidate, distance_matrix_2)\n            combined_cost = new_cost1 + new_cost2\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        new_solution = np.insert(remaining, best_pos, segment)\n\n    # Step 3: Guided edge recombination (swap edges that improve both objectives)\n    for _ in range(3):  # Limit to 3 swaps\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate solution by swapping edges i->i+1 and j->j+1\n        candidate = new_solution.copy()\n        candidate[i+1:j+1] = np.flip(candidate[i+1:j+1])\n\n        # Check if both objectives improve\n        new_cost1 = get_cost(candidate, distance_matrix_1)\n        new_cost2 = get_cost(candidate, distance_matrix_2)\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            new_solution = candidate\n            cost1, cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a guided edge recombination strategy to explore diverse neighborhoods while preserving feasibility, ensuring high-quality solutions across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity\n    objectives = np.array([obj for (sol, obj) in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: Multi-segment relocation with guided edge recombination\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Identify critical segments (high cost edges)\n    def get_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(N):\n            cost += dist_matrix[sol[i], sol[(i+1)%N]]\n        return cost\n\n    cost1 = get_cost(new_solution, distance_matrix_1)\n    cost2 = get_cost(new_solution, distance_matrix_2)\n\n    # Find edges with high combined cost\n    edge_costs = []\n    for i in range(N):\n        cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n        edge_costs.append(cost)\n    edge_costs = np.array(edge_costs)\n    critical_edges = np.argsort(edge_costs)[-2:]  # Top 2 critical edges\n\n    # Step 2: Relocate segments between critical edges\n    for edge in critical_edges:\n        start = edge\n        end = (start + np.random.randint(2, 5)) % N  # Relocate segment of random size (2-4 nodes)\n        segment = new_solution[start:end]\n        remaining = np.setdiff1d(new_solution, segment)\n\n        # Find insertion point with minimal combined cost\n        min_cost = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            candidate = np.insert(remaining, i, segment)\n            new_cost1 = get_cost(candidate, distance_matrix_1)\n            new_cost2 = get_cost(candidate, distance_matrix_2)\n            combined_cost = new_cost1 + new_cost2\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        new_solution = np.insert(remaining, best_pos, segment)\n\n    # Step 3: Guided edge recombination (swap edges that improve both objectives)\n    for _ in range(3):  # Limit to 3 swaps\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate solution by swapping edges i->i+1 and j->j+1\n        candidate = new_solution.copy()\n        candidate[i+1:j+1] = np.flip(candidate[i+1:j+1])\n\n        # Check if both objectives improve\n        new_cost1 = get_cost(candidate, distance_matrix_1)\n        new_cost2 = get_cost(candidate, distance_matrix_2)\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            new_solution = candidate\n            cost1, cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.942680010381084,
            6.8121660351753235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity\n    objectives = np.array([obj for (sol, obj) in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: Multi-segment relocation with guided edge recombination\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Identify critical segments (high cost edges)\n    def get_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(N):\n            cost += dist_matrix[sol[i], sol[(i+1)%N]]\n        return cost\n\n    cost1 = get_cost(new_solution, distance_matrix_1)\n    cost2 = get_cost(new_solution, distance_matrix_2)\n\n    # Find edges with high combined cost\n    edge_costs = []\n    for i in range(N):\n        cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n        edge_costs.append(cost)\n    edge_costs = np.array(edge_costs)\n    critical_edges = np.argsort(edge_costs)[-2:]  # Top 2 critical edges\n\n    # Step 2: Relocate segments between critical edges\n    for edge in critical_edges:\n        start = edge\n        end = (start + np.random.randint(2, 5)) % N  # Relocate segment of random size (2-4 nodes)\n        segment = new_solution[start:end]\n        remaining = np.setdiff1d(new_solution, segment)\n\n        # Find insertion point with minimal combined cost\n        min_cost = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            candidate = np.insert(remaining, i, segment)\n            new_cost1 = get_cost(candidate, distance_matrix_1)\n            new_cost2 = get_cost(candidate, distance_matrix_2)\n            combined_cost = new_cost1 + new_cost2\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        new_solution = np.insert(remaining, best_pos, segment)\n\n    # Step 3: Guided edge recombination (swap edges that improve both objectives)\n    for _ in range(3):  # Limit to 3 swaps\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate solution by swapping edges i->i+1 and j->j+1\n        candidate = new_solution.copy()\n        candidate[i+1:j+1] = np.flip(candidate[i+1:j+1])\n\n        # Check if both objectives improve\n        new_cost1 = get_cost(candidate, distance_matrix_1)\n        new_cost2 = get_cost(candidate, distance_matrix_2)\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            new_solution = candidate\n            cost1, cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a novel edge-swapping strategy based on distance matrices\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        i, j = random.sample(range(n), 2)\n        # Swap edges if it reduces the total distance in at least one objective\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.903544190453119,
            0.46719497442245483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a novel edge-swapping strategy based on distance matrices\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        i, j = random.sample(range(n), 2)\n        # Swap edges if it reduces the total distance in at least one objective\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a novel edge-swapping strategy based on distance matrices\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        i, j = random.sample(range(n), 2)\n        # Swap edges if it reduces the total distance in at least one objective\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.903544190453119,
            0.46719497442245483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a novel edge-swapping strategy based on distance matrices\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        i, j = random.sample(range(n), 2)\n        # Swap edges if it reduces the total distance in at least one objective\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator combines a multi-objective edge-selection mechanism with a biased random walk, dynamically balancing exploration and exploitation by prioritizing edges with high potential for reducing both objectives, while ensuring feasibility through a constrained swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores (simple ranking for this example)\n        dominance_scores = [sum(1 for other in archive if other[1][0] <= obj[0] and other[1][1] <= obj[1] and (other[1][0] < obj[0] or other[1][1] < obj[1])) for _, obj in archive]\n        total = sum(dominance_scores)\n        if total > 0:\n            probabilities = [score / total for score in dominance_scores]\n            selected_idx = np.random.choice(len(archive), p=probabilities)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operator\n\n    # Step 1: Identify critical edges (high potential for improvement)\n    critical_edges = []\n    for i in range(n):\n        u = base_solution[i]\n        v = base_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        # Edge is critical if it's among the top 30% worst edges in either objective\n        if (cost1 > np.percentile(distance_matrix_1, 70)) or (cost2 > np.percentile(distance_matrix_2, 70)):\n            critical_edges.append((i, (i + 1) % n))\n\n    if not critical_edges:\n        # If no critical edges, randomly select two edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n    else:\n        # Select two critical edges\n        edge1, edge2 = random.sample(critical_edges, 2)\n        a, b = edge1\n        c, d = edge2\n\n    # Ensure a < b and c < d for proper segment handling\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Step 2: Perform constrained swap to maintain feasibility\n    if a < c < b < d:\n        # Case 1: Non-overlapping segments\n        new_solution[a:b+1] = base_solution[c:d+1][::-1]\n    elif c < a < d < b:\n        # Case 2: Overlapping segments\n        new_solution[a:d+1] = base_solution[c:b+1][::-1]\n    else:\n        # Case 3: Simple swap of two edges\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8074912931483461,
            10.310427725315094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores (simple ranking for this example)\n        dominance_scores = [sum(1 for other in archive if other[1][0] <= obj[0] and other[1][1] <= obj[1] and (other[1][0] < obj[0] or other[1][1] < obj[1])) for _, obj in archive]\n        total = sum(dominance_scores)\n        if total > 0:\n            probabilities = [score / total for score in dominance_scores]\n            selected_idx = np.random.choice(len(archive), p=probabilities)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operator\n\n    # Step 1: Identify critical edges (high potential for improvement)\n    critical_edges = []\n    for i in range(n):\n        u = base_solution[i]\n        v = base_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        # Edge is critical if it's among the top 30% worst edges in either objective\n        if (cost1 > np.percentile(distance_matrix_1, 70)) or (cost2 > np.percentile(distance_matrix_2, 70)):\n            critical_edges.append((i, (i + 1) % n))\n\n    if not critical_edges:\n        # If no critical edges, randomly select two edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n    else:\n        # Select two critical edges\n        edge1, edge2 = random.sample(critical_edges, 2)\n        a, b = edge1\n        c, d = edge2\n\n    # Ensure a < b and c < d for proper segment handling\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Step 2: Perform constrained swap to maintain feasibility\n    if a < c < b < d:\n        # Case 1: Non-overlapping segments\n        new_solution[a:b+1] = base_solution[c:d+1][::-1]\n    elif c < a < d < b:\n        # Case 2: Overlapping segments\n        new_solution[a:d+1] = base_solution[c:b+1][::-1]\n    else:\n        # Case 3: Simple swap of two edges\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic segment inversion strategy, guided by a weighted combination of the two objectives, to explore the solution space while maintaining feasibility and promoting high-quality improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8359818864743235,
            0.6165406107902527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic segment inversion strategy, guided by a weighted combination of the two objectives, to explore the solution space while maintaining feasibility and promoting high-quality improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8359818864743235,
            0.6165406107902527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic segment inversion strategy, guided by a weighted combination of the two objectives, to explore the solution space while maintaining feasibility and promoting high-quality improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8359818864743235,
            0.6165406107902527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search operator combines a multi-criteria selection of promising solutions from the archive, followed by a dynamic edge-swap strategy that balances improvements in both objective spaces while ensuring feasibility through a feasibility-preserving edge-swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge-swap with feasibility check\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure the swap is feasible (no duplicates or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (optional, but ensures correctness)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8762176715657244,
            0.7538501620292664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge-swap with feasibility check\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure the swap is feasible (no duplicates or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (optional, but ensures correctness)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search operator combines a multi-criteria selection of promising solutions from the archive, followed by a dynamic edge-swap strategy that balances improvements in both objective spaces while ensuring feasibility through a feasibility-preserving edge-swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge-swap with feasibility check\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure the swap is feasible (no duplicates or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (optional, but ensures correctness)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8762176715657244,
            0.7538501620292664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge-swap with feasibility check\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure the swap is feasible (no duplicates or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (optional, but ensures correctness)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment relocation with multi-objective edge swapping to intelligently explore the solution space while balancing both objectives, ensuring feasibility through constraint-aware perturbation and guided selection of promising regions in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1+i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment relocation with multi-objective edge swapping\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n//2))  # Random segment length\n    start = random.randint(0, n - segment_length)     # Random start position\n    end = start + segment_length\n\n    # Relocate segment to a new position\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Multi-objective edge swapping\n    for _ in range(3):  # Perform a few swaps\n        i, j = random.sample(range(n), 2)\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.1:  # Allow some non-improving swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7450545479002306,
            0.7508071064949036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1+i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment relocation with multi-objective edge swapping\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n//2))  # Random segment length\n    start = random.randint(0, n - segment_length)     # Random start position\n    end = start + segment_length\n\n    # Relocate segment to a new position\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Multi-objective edge swapping\n    for _ in range(3):  # Perform a few swaps\n        i, j = random.sample(range(n), 2)\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.1:  # Allow some non-improving swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A hybrid local search heuristic that intelligently selects a solution from the archive based on non-dominated solutions and their potential for improvement, then applies a customized edge-swap and node-reinsertion hybrid operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., high cost or diversity)\n        base_solution = max(non_dominated, key=lambda sol: np.sum(distance_matrix_1[sol[:-1], sol[1:]]) + np.sum(distance_matrix_2[sol[:-1], sol[1:]])).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid operator: Edge-swap followed by node reinsertion\n    # Edge-swap: Select two non-adjacent edges and swap their endpoints\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    if new_solution[a] == new_solution[c] or new_solution[b] == new_solution[d]:\n        return new_solution  # Avoid invalid swap\n\n    # Perform edge-swap\n    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Node reinsertion: Remove a node and reinsert it at a better position\n    node_to_remove = random.choice(new_solution[1:-1])\n    idx = np.where(new_solution == node_to_remove)[0][0]\n    new_solution = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n    # Find the best insertion position for the removed node\n    best_cost = float('inf')\n    best_pos = 0\n    for i in range(1, len(new_solution)):\n        # Insert node_to_remove between new_solution[i-1] and new_solution[i]\n        cost = (distance_matrix_1[new_solution[i-1], node_to_remove] + distance_matrix_1[node_to_remove, new_solution[i]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n               (distance_matrix_2[new_solution[i-1], node_to_remove] + distance_matrix_2[node_to_remove, new_solution[i]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]])\n        if cost < best_cost:\n            best_cost = cost\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, node_to_remove)\n\n    return new_solution\n\n",
        "score": [
            -0.7282095870887813,
            0.8123635649681091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., high cost or diversity)\n        base_solution = max(non_dominated, key=lambda sol: np.sum(distance_matrix_1[sol[:-1], sol[1:]]) + np.sum(distance_matrix_2[sol[:-1], sol[1:]])).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid operator: Edge-swap followed by node reinsertion\n    # Edge-swap: Select two non-adjacent edges and swap their endpoints\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    if new_solution[a] == new_solution[c] or new_solution[b] == new_solution[d]:\n        return new_solution  # Avoid invalid swap\n\n    # Perform edge-swap\n    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Node reinsertion: Remove a node and reinsert it at a better position\n    node_to_remove = random.choice(new_solution[1:-1])\n    idx = np.where(new_solution == node_to_remove)[0][0]\n    new_solution = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n    # Find the best insertion position for the removed node\n    best_cost = float('inf')\n    best_pos = 0\n    for i in range(1, len(new_solution)):\n        # Insert node_to_remove between new_solution[i-1] and new_solution[i]\n        cost = (distance_matrix_1[new_solution[i-1], node_to_remove] + distance_matrix_1[node_to_remove, new_solution[i]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n               (distance_matrix_2[new_solution[i-1], node_to_remove] + distance_matrix_2[node_to_remove, new_solution[i]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]])\n        if cost < best_cost:\n            best_cost = cost\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, node_to_remove)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive based on dominance and diversity, then applies a novel hybrid local search combining edge-swapping and segment inversion to efficiently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by dominance (Pareto front) and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))  # Select from top 30% solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping for both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment inversion based on objective differences\n    if np.random.rand() < 0.5:  # 50% chance to apply segment inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert if it improves at least one objective\n        if cost1 > 0 or cost2 > 0:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7701032656864056,
            0.4679875373840332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by dominance (Pareto front) and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))  # Select from top 30% solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping for both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment inversion based on objective differences\n    if np.random.rand() < 0.5:  # 50% chance to apply segment inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert if it improves at least one objective\n        if cost1 > 0 or cost2 > 0:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive based on dominance and diversity, then applies a novel hybrid local search combining edge-swapping and segment inversion to efficiently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by dominance (Pareto front) and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))  # Select from top 30% solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping for both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment inversion based on objective differences\n    if np.random.rand() < 0.5:  # 50% chance to apply segment inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert if it improves at least one objective\n        if cost1 > 0 or cost2 > 0:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7701032656864056,
            0.4679875373840332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by dominance (Pareto front) and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))  # Select from top 30% solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping for both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment inversion based on objective differences\n    if np.random.rand() < 0.5:  # 50% chance to apply segment inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert if it improves at least one objective\n        if cost1 > 0 or cost2 > 0:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search strategy that combines a probabilistic edge selection mechanism with a multi-objective-aware edge insertion heuristic to generate high-quality neighbor solutions by intelligently reconfiguring the tour while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: probabilistic edge selection + multi-objective edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic edge selection (select edges to remove)\n    edge_prob = np.zeros(n)\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        # Compute edge importance based on both objectives\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        edge_prob[i] = (cost1 + cost2) / (np.sum(distance_matrix_1[u]) + np.sum(distance_matrix_2[u]))\n    edge_prob = edge_prob / np.sum(edge_prob)\n\n    # Select an edge to remove based on probability\n    selected_edge = np.random.choice(n, p=edge_prob)\n    u, v = new_solution[selected_edge], new_solution[(selected_edge + 1) % n]\n\n    # Step 2: Multi-objective edge insertion (find best insertion point)\n    best_insertion = -1\n    best_cost = np.inf\n    for i in range(n):\n        if i == selected_edge or i == (selected_edge - 1) % n:\n            continue  # Skip adjacent edges\n        # Try inserting (u, v) between i and i+1\n        temp_solution = np.insert(new_solution, i + 1, [u, v])\n        # Remove the original edge\n        mask = np.ones(len(temp_solution), dtype=bool)\n        mask[selected_edge] = False\n        mask[(selected_edge + 1) % n] = False\n        temp_solution = temp_solution[mask]\n        # Compute cost\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % len(temp_solution)]] for k in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % len(temp_solution)]] for k in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insertion = i\n\n    # Apply the best insertion\n    if best_insertion != -1:\n        new_solution = np.insert(new_solution, best_insertion + 1, [u, v])\n        mask = np.ones(len(new_solution), dtype=bool)\n        mask[selected_edge] = False\n        mask[(selected_edge + 1) % n] = False\n        new_solution = new_solution[mask]\n\n    return new_solution\n\n",
        "score": [
            -0.5151989065758777,
            3.7618812322616577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Hybrid local search: probabilistic edge selection + multi-objective edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic edge selection (select edges to remove)\n    edge_prob = np.zeros(n)\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        # Compute edge importance based on both objectives\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        edge_prob[i] = (cost1 + cost2) / (np.sum(distance_matrix_1[u]) + np.sum(distance_matrix_2[u]))\n    edge_prob = edge_prob / np.sum(edge_prob)\n\n    # Select an edge to remove based on probability\n    selected_edge = np.random.choice(n, p=edge_prob)\n    u, v = new_solution[selected_edge], new_solution[(selected_edge + 1) % n]\n\n    # Step 2: Multi-objective edge insertion (find best insertion point)\n    best_insertion = -1\n    best_cost = np.inf\n    for i in range(n):\n        if i == selected_edge or i == (selected_edge - 1) % n:\n            continue  # Skip adjacent edges\n        # Try inserting (u, v) between i and i+1\n        temp_solution = np.insert(new_solution, i + 1, [u, v])\n        # Remove the original edge\n        mask = np.ones(len(temp_solution), dtype=bool)\n        mask[selected_edge] = False\n        mask[(selected_edge + 1) % n] = False\n        temp_solution = temp_solution[mask]\n        # Compute cost\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % len(temp_solution)]] for k in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % len(temp_solution)]] for k in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insertion = i\n\n    # Apply the best insertion\n    if best_insertion != -1:\n        new_solution = np.insert(new_solution, best_insertion + 1, [u, v])\n        mask = np.ones(len(new_solution), dtype=bool)\n        mask[selected_edge] = False\n        mask[(selected_edge + 1) % n] = False\n        new_solution = new_solution[mask]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective dominance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    weights = np.sum(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swapping and segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Edge swapping: randomly select two edges and swap their positions\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment inversion: randomly select a segment and reverse it\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: if invalid, perform a simple 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7936356089132802,
            0.7914842963218689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective dominance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    weights = np.sum(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swapping and segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Edge swapping: randomly select two edges and swap their positions\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment inversion: randomly select a segment and reverse it\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: if invalid, perform a simple 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal with a probability of 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a random feasible solution if invalid\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9207241637015102,
            0.6840910911560059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal with a probability of 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a random feasible solution if invalid\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal with a probability of 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a random feasible solution if invalid\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9207241637015102,
            0.6840910911560059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal with a probability of 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a random feasible solution if invalid\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and crowding distance, then applies a novel 3-opt* local search operator that combines edge swaps with path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and crowding distance\n    selected_idx = 0\n    min_dominance = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        dominance = sum(obj)\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt* local search with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Create a new path by rearranging segments\n    new_path = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k][::-1],\n        new_solution[i:j],\n        new_solution[k:]\n    ])\n\n    # Ensure the path is a valid tour\n    if len(np.unique(new_path)) == n:\n        new_solution = new_path\n\n    return new_solution\n\n",
        "score": [
            -0.6933243741420154,
            0.4461817741394043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and crowding distance\n    selected_idx = 0\n    min_dominance = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        dominance = sum(obj)\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt* local search with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Create a new path by rearranging segments\n    new_path = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k][::-1],\n        new_solution[i:j],\n        new_solution[k:]\n    ])\n\n    # Ensure the path is a valid tour\n    if len(np.unique(new_path)) == n:\n        new_solution = new_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and crowding distance, then applies a novel 3-opt* local search operator that combines edge swaps with path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and crowding distance\n    selected_idx = 0\n    min_dominance = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        dominance = sum(obj)\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt* local search with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Create a new path by rearranging segments\n    new_path = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k][::-1],\n        new_solution[i:j],\n        new_solution[k:]\n    ])\n\n    # Ensure the path is a valid tour\n    if len(np.unique(new_path)) == n:\n        new_solution = new_path\n\n    return new_solution\n\n",
        "score": [
            -0.6933243741420154,
            0.4461817741394043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and crowding distance\n    selected_idx = 0\n    min_dominance = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        dominance = sum(obj)\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt* local search with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Create a new path by rearranging segments\n    new_path = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k][::-1],\n        new_solution[i:j],\n        new_solution[k:]\n    ])\n\n    # Ensure the path is a valid tour\n    if len(np.unique(new_path)) == n:\n        new_solution = new_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search operator that combines edge exchange with a guided segment relocation strategy to intelligently explore the solution space while ensuring feasibility, prioritizing solutions with promising objective trade-offs for further improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment relocation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a segment between k and i to after j\n    if k < i and j < n - 1:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j+1], segment, new_solution[j+1:]])\n\n    # Ensure validity (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8806722851689966,
            0.42970335483551025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment relocation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a segment between k and i to after j\n    if k < i and j < n - 1:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j+1], segment, new_solution[j+1:]])\n\n    # Ensure validity (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search operator that combines edge exchange with a guided segment relocation strategy to intelligently explore the solution space while ensuring feasibility, prioritizing solutions with promising objective trade-offs for further improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment relocation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a segment between k and i to after j\n    if k < i and j < n - 1:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j+1], segment, new_solution[j+1:]])\n\n    # Ensure validity (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8806722851689966,
            0.42970335483551025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment relocation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a segment between k and i to after j\n    if k < i and j < n - 1:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j+1], segment, new_solution[j+1:]])\n\n    # Ensure validity (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel heuristic selects a solution from the archive based on objective diversity and applies a hybrid local search combining edge insertion with a biased random walk to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity * (objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk with edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limited iterations for efficiency\n        # Select a random segment to modify\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, min(start + 5, n))\n\n        # Extract and reverse the segment (with probability 0.5)\n        if np.random.rand() < 0.5:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n        # Insert a random node elsewhere\n        node_to_move = new_solution[start]\n        new_solution = np.roll(new_solution, -start)\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8894929445747322,
            0.3893139958381653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity * (objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk with edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limited iterations for efficiency\n        # Select a random segment to modify\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, min(start + 5, n))\n\n        # Extract and reverse the segment (with probability 0.5)\n        if np.random.rand() < 0.5:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n        # Insert a random node elsewhere\n        node_to_move = new_solution[start]\n        new_solution = np.roll(new_solution, -start)\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel heuristic selects a solution from the archive based on objective diversity and applies a hybrid local search combining edge insertion with a biased random walk to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity * (objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk with edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limited iterations for efficiency\n        # Select a random segment to modify\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, min(start + 5, n))\n\n        # Extract and reverse the segment (with probability 0.5)\n        if np.random.rand() < 0.5:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n        # Insert a random node elsewhere\n        node_to_move = new_solution[start]\n        new_solution = np.roll(new_solution, -start)\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8894929445747322,
            0.3893139958381653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity * (objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk with edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limited iterations for efficiency\n        # Select a random segment to modify\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, min(start + 5, n))\n\n        # Extract and reverse the segment (with probability 0.5)\n        if np.random.rand() < 0.5:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n        # Insert a random node elsewhere\n        node_to_move = new_solution[start]\n        new_solution = np.roll(new_solution, -start)\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a multi-objective segment reversal strategy to explore non-dominated regions, iteratively selecting and reversing segments that improve Pareto dominance while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (can be replaced with other criteria)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle to avoid extremes\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment reversal with biased randomness\n    for _ in range(3):  # Number of segment reversals\n        # Select two distinct random segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure segments are distinct and valid\n        if i == k and j == l:\n            continue\n\n        # Reverse segments with probability based on potential improvement\n        if np.random.rand() < 0.7:  # Higher probability for segment reversal\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if np.random.rand() < 0.5:  # Lower probability for second segment\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to nearest valid solution\n        new_solution = base_solution.copy()\n        # Apply a simpler but guaranteed valid operation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6527532322585752,
            0.5544461607933044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (can be replaced with other criteria)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle to avoid extremes\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment reversal with biased randomness\n    for _ in range(3):  # Number of segment reversals\n        # Select two distinct random segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure segments are distinct and valid\n        if i == k and j == l:\n            continue\n\n        # Reverse segments with probability based on potential improvement\n        if np.random.rand() < 0.7:  # Higher probability for segment reversal\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if np.random.rand() < 0.5:  # Lower probability for second segment\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to nearest valid solution\n        new_solution = base_solution.copy()\n        # Apply a simpler but guaranteed valid operation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a novel hybrid local search combining edge-swapping and segment-reversal to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with edge swapping\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Reverse segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Edge swap if beneficial\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7607932659367119,
            0.4403787851333618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))  # Select from top 30%\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with edge swapping\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Reverse segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Edge swap if beneficial\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted Pareto dominance criterion, then applies a hybrid local search combining edge insertion and variable-length segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with weighted Pareto dominance\n    scores = []\n    for sol, obj in archive:\n        # Score based on normalized objectives and diversity\n        norm_obj1 = obj[0] / (max(o[0] for _, o in archive) + 1e-6)\n        norm_obj2 = obj[1] / (max(o[1] for _, o in archive) + 1e-6)\n        score = 0.7 * (1 - norm_obj1) + 0.3 * (1 - norm_obj2)  # Weighted Pareto\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + variable-length segment relocation\n    num_nodes = len(new_solution)\n    if num_nodes < 2:\n        return new_solution\n\n    # Edge insertion\n    i, j = sorted(random.sample(range(num_nodes), 2))\n    if j - i > 1:\n        segment = new_solution[i+1:j].copy()\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Variable-length segment relocation\n    if num_nodes > 3:\n        seg_length = random.randint(2, min(5, num_nodes // 2))\n        start = random.randint(0, num_nodes - seg_length)\n        segment = new_solution[start:start+seg_length].copy()\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        insert_pos = random.randint(0, num_nodes - seg_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6684335074044505,
            0.45943284034729004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with weighted Pareto dominance\n    scores = []\n    for sol, obj in archive:\n        # Score based on normalized objectives and diversity\n        norm_obj1 = obj[0] / (max(o[0] for _, o in archive) + 1e-6)\n        norm_obj2 = obj[1] / (max(o[1] for _, o in archive) + 1e-6)\n        score = 0.7 * (1 - norm_obj1) + 0.3 * (1 - norm_obj2)  # Weighted Pareto\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + variable-length segment relocation\n    num_nodes = len(new_solution)\n    if num_nodes < 2:\n        return new_solution\n\n    # Edge insertion\n    i, j = sorted(random.sample(range(num_nodes), 2))\n    if j - i > 1:\n        segment = new_solution[i+1:j].copy()\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Variable-length segment relocation\n    if num_nodes > 3:\n        seg_length = random.randint(2, min(5, num_nodes // 2))\n        start = random.randint(0, num_nodes - seg_length)\n        segment = new_solution[start:start+seg_length].copy()\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        insert_pos = random.randint(0, num_nodes - seg_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on Pareto dominance and diversity, then applies a combination of edge-swap and segment-reversal operations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) and not np.array_equal(sol, other_sol):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select a solution with high diversity (far from others in objective space)\n        selected_sol, _ = max(non_dominated, key=lambda x: min(np.linalg.norm(np.array(x[1]) - np.array(other[1])) for other in non_dominated if not np.array_equal(x[0], other[0])))\n    else:\n        # If no non-dominated solutions, select a random one\n        selected_sol, _ = random.choice(archive)\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid of edge-swap and segment-reversal with adaptive selection\n    n = len(base_solution)\n    if n >= 4:\n        # Choose between edge-swap or segment-reversal based on current solution quality\n        if random.random() < 0.7:  # Higher chance for edge-swap\n            # Edge-swap: select two random edges and swap their connections\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([base_solution[:i+1], base_solution[j:i:-1], base_solution[j+1:]])\n        else:\n            # Segment-reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([base_solution[:i], base_solution[i:j+1][::-1], base_solution[j+1:]])\n\n    # Ensure feasibility: verify no node is revisited or skipped\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.8733178755262562,
            4.666945993900299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) and not np.array_equal(sol, other_sol):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select a solution with high diversity (far from others in objective space)\n        selected_sol, _ = max(non_dominated, key=lambda x: min(np.linalg.norm(np.array(x[1]) - np.array(other[1])) for other in non_dominated if not np.array_equal(x[0], other[0])))\n    else:\n        # If no non-dominated solutions, select a random one\n        selected_sol, _ = random.choice(archive)\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid of edge-swap and segment-reversal with adaptive selection\n    n = len(base_solution)\n    if n >= 4:\n        # Choose between edge-swap or segment-reversal based on current solution quality\n        if random.random() < 0.7:  # Higher chance for edge-swap\n            # Edge-swap: select two random edges and swap their connections\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([base_solution[:i+1], base_solution[j:i:-1], base_solution[j+1:]])\n        else:\n            # Segment-reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([base_solution[:i], base_solution[i:j+1][::-1], base_solution[j+1:]])\n\n    # Ensure feasibility: verify no node is revisited or skipped\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with node reinsertion\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion: select a random node and reinsert it at a different position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    while new_pos == current_pos:\n        new_pos = np.random.randint(0, n)\n\n    # Remove and reinsert\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8057684912900058,
            0.4745286703109741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with node reinsertion\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion: select a random node and reinsert it at a different position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    while new_pos == current_pos:\n        new_pos = np.random.randint(0, n)\n\n    # Remove and reinsert\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with node reinsertion\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion: select a random node and reinsert it at a different position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    while new_pos == current_pos:\n        new_pos = np.random.randint(0, n)\n\n    # Remove and reinsert\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8057684912900058,
            0.4745286703109741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with node reinsertion\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion: select a random node and reinsert it at a different position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    while new_pos == current_pos:\n        new_pos = np.random.randint(0, n)\n\n    # Remove and reinsert\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with node reinsertion\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion: select a random node and reinsert it at a different position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    while new_pos == current_pos:\n        new_pos = np.random.randint(0, n)\n\n    # Remove and reinsert\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8057684912900058,
            0.4745286703109741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with node reinsertion\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion: select a random node and reinsert it at a different position\n    node_to_move = np.random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    while new_pos == current_pos:\n        new_pos = np.random.randint(0, n)\n\n    # Remove and reinsert\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This function intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining edge exchange and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Ensure indices are distinct\n    while i == j or i == k or j == k:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a segment between two random points\n    start = min(i, j)\n    end = max(i, j)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation is invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8648721881974687,
            0.44946354627609253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Ensure indices are distinct\n    while i == j or i == k or j == k:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a segment between two random points\n    start = min(i, j)\n    end = max(i, j)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation is invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This function intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining edge exchange and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Ensure indices are distinct\n    while i == j or i == k or j == k:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a segment between two random points\n    start = min(i, j)\n    end = max(i, j)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation is invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8648721881974687,
            0.44946354627609253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Ensure indices are distinct\n    while i == j or i == k or j == k:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a segment between two random points\n    start = min(i, j)\n    end = max(i, j)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation is invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This function intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining edge exchange and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Ensure indices are distinct\n    while i == j or i == k or j == k:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a segment between two random points\n    start = min(i, j)\n    end = max(i, j)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation is invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8648721881974687,
            0.44946354627609253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Ensure indices are distinct\n    while i == j or i == k or j == k:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a segment between two random points\n    start = min(i, j)\n    end = max(i, j)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation is invalid\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm that combines a dynamic segment reversal with adaptive edge exchange to explore diverse neighborhoods while maintaining feasibility, prioritizing solutions with high potential for improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on problem size\n    n = len(base_solution)\n    segment_length = max(3, min(10, n // 5))\n\n    # Perform dynamic segment reversal\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(2):  # Perform multiple exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if exchange improves both objectives\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.878688758580696,
            0.43245673179626465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on problem size\n    n = len(base_solution)\n    segment_length = max(3, min(10, n // 5))\n\n    # Perform dynamic segment reversal\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(2):  # Perform multiple exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if exchange improves both objectives\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm that combines a dynamic segment reversal with adaptive edge exchange to explore diverse neighborhoods while maintaining feasibility, prioritizing solutions with high potential for improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on problem size\n    n = len(base_solution)\n    segment_length = max(3, min(10, n // 5))\n\n    # Perform dynamic segment reversal\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(2):  # Perform multiple exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if exchange improves both objectives\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.878688758580696,
            0.43245673179626465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on problem size\n    n = len(base_solution)\n    segment_length = max(3, min(10, n // 5))\n\n    # Perform dynamic segment reversal\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(2):  # Perform multiple exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if exchange improves both objectives\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm that combines a dynamic segment reversal with adaptive edge exchange to explore diverse neighborhoods while maintaining feasibility, prioritizing solutions with high potential for improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on problem size\n    n = len(base_solution)\n    segment_length = max(3, min(10, n // 5))\n\n    # Perform dynamic segment reversal\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(2):  # Perform multiple exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if exchange improves both objectives\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.878688758580696,
            0.43245673179626465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on problem size\n    n = len(base_solution)\n    segment_length = max(3, min(10, n // 5))\n\n    # Perform dynamic segment reversal\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(2):  # Perform multiple exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if exchange improves both objectives\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining edge reinsertion and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance ranks and crowding distances (simplified)\n        objectives = np.array([obj for _, obj in archive])\n        ranks = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if (objectives[i][0] > objectives[j][0] and objectives[i][1] >= objectives[j][1]) or \\\n                   (objectives[i][0] >= objectives[j][0] and objectives[i][1] > objectives[j][1]):\n                    ranks[i] += 1\n        # Select a solution with low rank (better) and randomness\n        candidates = [i for i in range(len(archive)) if ranks[i] == 0]\n        if not candidates:\n            candidates = [i for i in range(len(archive)) if ranks[i] == min(ranks)]\n        selected_idx = random.choice(candidates)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge reinsertion with path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reinsertion (remove and reinsert a random edge)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) <= 1:\n        j = random.randint(0, n-1)\n    # Remove edge between i and (i+1)%n\n    node_a = new_solution[i]\n    node_b = new_solution[(i+1)%n]\n    # Remove edge between j and (j+1)%n\n    node_c = new_solution[j]\n    node_d = new_solution[(j+1)%n]\n\n    # Reinsert edges in a different configuration\n    new_solution[(i+1)%n] = node_c\n    new_solution[j] = node_b\n\n    # Step 2: Path relinking (swap edges to improve objectives)\n    for _ in range(2):  # Limited iterations for efficiency\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n\n        # Calculate cost before and after swap\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Accept if improves at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7755603887355547,
            0.8855657577514648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance ranks and crowding distances (simplified)\n        objectives = np.array([obj for _, obj in archive])\n        ranks = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if (objectives[i][0] > objectives[j][0] and objectives[i][1] >= objectives[j][1]) or \\\n                   (objectives[i][0] >= objectives[j][0] and objectives[i][1] > objectives[j][1]):\n                    ranks[i] += 1\n        # Select a solution with low rank (better) and randomness\n        candidates = [i for i in range(len(archive)) if ranks[i] == 0]\n        if not candidates:\n            candidates = [i for i in range(len(archive)) if ranks[i] == min(ranks)]\n        selected_idx = random.choice(candidates)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge reinsertion with path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reinsertion (remove and reinsert a random edge)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) <= 1:\n        j = random.randint(0, n-1)\n    # Remove edge between i and (i+1)%n\n    node_a = new_solution[i]\n    node_b = new_solution[(i+1)%n]\n    # Remove edge between j and (j+1)%n\n    node_c = new_solution[j]\n    node_d = new_solution[(j+1)%n]\n\n    # Reinsert edges in a different configuration\n    new_solution[(i+1)%n] = node_c\n    new_solution[j] = node_b\n\n    # Step 2: Path relinking (swap edges to improve objectives)\n    for _ in range(2):  # Limited iterations for efficiency\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n\n        # Calculate cost before and after swap\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Accept if improves at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of Pareto dominance and dominance resistance, then applies a hybrid local search combining edge exchange with a novel segment relocation operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance resistance\n    def dominance_resistance(sol):\n        count = 0\n        for other_sol, _ in archive:\n            if np.all(sol == other_sol):\n                continue\n            if (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_1[sol[0], sol[1]] >\n                distance_matrix_1[other_sol[-1], other_sol[0]] + distance_matrix_1[other_sol[0], other_sol[1]]) and \\\n               (distance_matrix_2[sol[-1], sol[0]] + distance_matrix_2[sol[0], sol[1]] >\n                distance_matrix_2[other_sol[-1], other_sol[0]] + distance_matrix_2[other_sol[0], other_sol[1]]):\n                count += 1\n        return count\n\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        candidates.sort(key=lambda x: dominance_resistance(x))\n        selected = random.choice(candidates[:max(1, len(candidates)//2)])\n    else:\n        selected = candidates[0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange + segment relocation\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Segment relocation\n    segment = base_solution[a:b+1]\n    remaining = np.concatenate([base_solution[:a], base_solution[b+1:]])\n    new_solution = np.concatenate([remaining[:c], segment, remaining[c:]])\n\n    # Edge exchange\n    if random.random() < 0.5 and len(new_solution) > 3:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7862119694166643,
            3.5353084802627563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance resistance\n    def dominance_resistance(sol):\n        count = 0\n        for other_sol, _ in archive:\n            if np.all(sol == other_sol):\n                continue\n            if (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_1[sol[0], sol[1]] >\n                distance_matrix_1[other_sol[-1], other_sol[0]] + distance_matrix_1[other_sol[0], other_sol[1]]) and \\\n               (distance_matrix_2[sol[-1], sol[0]] + distance_matrix_2[sol[0], sol[1]] >\n                distance_matrix_2[other_sol[-1], other_sol[0]] + distance_matrix_2[other_sol[0], other_sol[1]]):\n                count += 1\n        return count\n\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        candidates.sort(key=lambda x: dominance_resistance(x))\n        selected = random.choice(candidates[:max(1, len(candidates)//2)])\n    else:\n        selected = candidates[0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange + segment relocation\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Segment relocation\n    segment = base_solution[a:b+1]\n    remaining = np.concatenate([base_solution[:a], base_solution[b+1:]])\n    new_solution = np.concatenate([remaining[:c], segment, remaining[c:]])\n\n    # Edge exchange\n    if random.random() < 0.5 and len(new_solution) > 3:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid of diversity and dominance metrics, then applies a novel 3-opt* local search operator that combines edge swaps with segment reversals to escape local optima while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(solution, objective):\n        # Combine diversity and non-dominance metrics\n        diversity = np.std([distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))])\n        dominance = sum(objective)  # Simple sum for selection, more sophisticated in practice\n        return diversity * (1 / (1 + dominance))\n\n    scored_solutions = [(selection_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator: 3-opt* with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Perform the 3-opt* operation\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Try different combinations to find the best improvement\n    candidates = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate all candidates and select the best\n    best_candidate = candidates[0]\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    return best_candidate\n\n",
        "score": [
            -0.8033138245279381,
            1.4790474772453308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(solution, objective):\n        # Combine diversity and non-dominance metrics\n        diversity = np.std([distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))])\n        dominance = sum(objective)  # Simple sum for selection, more sophisticated in practice\n        return diversity * (1 / (1 + dominance))\n\n    scored_solutions = [(selection_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator: 3-opt* with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Perform the 3-opt* operation\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Try different combinations to find the best improvement\n    candidates = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate all candidates and select the best\n    best_candidate = candidates[0]\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search strategy combining edge exchange and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (prioritize those with higher cost)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions with highest cost\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        # Randomly select one from the top\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly select a segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Randomly select two edges to exchange\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.835844740274736,
            0.4667966365814209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (prioritize those with higher cost)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions with highest cost\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        # Randomly select one from the top\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly select a segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Step 2: Randomly select two edges to exchange\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The heuristic selects a solution from the archive by prioritizing those with high variance in edge costs between objectives, then applies a novel hybrid local search combining edge swaps and segment reversals to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of edge costs for each solution\n    variances = []\n    for sol, _ in archive:\n        edge_costs_1 = []\n        edge_costs_2 = []\n        for i in range(len(sol) - 1):\n            a, b = sol[i], sol[i+1]\n            edge_costs_1.append(distance_matrix_1[a, b])\n            edge_costs_2.append(distance_matrix_2[a, b])\n        # Add the last edge (return to start)\n        a, b = sol[-1], sol[0]\n        edge_costs_1.append(distance_matrix_1[a, b])\n        edge_costs_2.append(distance_matrix_2[a, b])\n\n        # Calculate the variance of the differences between edge costs\n        diffs = np.array(edge_costs_1) - np.array(edge_costs_2)\n        variance = np.var(diffs)\n        variances.append(variance)\n\n    # Select the solution with the highest variance (promising for improvement)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to reverse or swap\n    if random.random() < 0.5:  # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6209935215866154,
            4.5836261510849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of edge costs for each solution\n    variances = []\n    for sol, _ in archive:\n        edge_costs_1 = []\n        edge_costs_2 = []\n        for i in range(len(sol) - 1):\n            a, b = sol[i], sol[i+1]\n            edge_costs_1.append(distance_matrix_1[a, b])\n            edge_costs_2.append(distance_matrix_2[a, b])\n        # Add the last edge (return to start)\n        a, b = sol[-1], sol[0]\n        edge_costs_1.append(distance_matrix_1[a, b])\n        edge_costs_2.append(distance_matrix_2[a, b])\n\n        # Calculate the variance of the differences between edge costs\n        diffs = np.array(edge_costs_1) - np.array(edge_costs_2)\n        variance = np.var(diffs)\n        variances.append(variance)\n\n    # Select the solution with the highest variance (promising for improvement)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to reverse or swap\n    if random.random() < 0.5:  # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment inversion with objective-aware node swaps to intelligently explore the solution space, balancing between diversity and convergence in multi-objective TSP.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_obj.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive segment inversion + objective-aware node swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment inversion (like 2-opt but with variable segment length)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node swap: swap nodes that are distant in both objectives\n    if n > 2:\n        k, l = np.random.choice(n, size=2, replace=False)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate cost difference in both objectives\n        cost_diff1 = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[node_l, new_solution[(k+1)%n]] +\n                     distance_matrix_1[node_l, new_solution[(l-1)%n]] + distance_matrix_1[node_k, new_solution[(l+1)%n]]) - \\\n                    (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[node_k, new_solution[(k+1)%n]] +\n                     distance_matrix_1[node_l, new_solution[(l-1)%n]] + distance_matrix_1[node_l, new_solution[(l+1)%n]])\n\n        cost_diff2 = (distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[node_l, new_solution[(k+1)%n]] +\n                     distance_matrix_2[node_l, new_solution[(l-1)%n]] + distance_matrix_2[node_k, new_solution[(l+1)%n]]) - \\\n                    (distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[node_k, new_solution[(k+1)%n]] +\n                     distance_matrix_2[node_l, new_solution[(l-1)%n]] + distance_matrix_2[node_l, new_solution[(l+1)%n]])\n\n        # Only swap if it improves at least one objective\n        if cost_diff1 < 0 or cost_diff2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6668045293130659,
            0.4874776005744934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_obj.sum(axis=1)\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive segment inversion + objective-aware node swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment inversion (like 2-opt but with variable segment length)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node swap: swap nodes that are distant in both objectives\n    if n > 2:\n        k, l = np.random.choice(n, size=2, replace=False)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate cost difference in both objectives\n        cost_diff1 = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[node_l, new_solution[(k+1)%n]] +\n                     distance_matrix_1[node_l, new_solution[(l-1)%n]] + distance_matrix_1[node_k, new_solution[(l+1)%n]]) - \\\n                    (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[node_k, new_solution[(k+1)%n]] +\n                     distance_matrix_1[node_l, new_solution[(l-1)%n]] + distance_matrix_1[node_l, new_solution[(l+1)%n]])\n\n        cost_diff2 = (distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[node_l, new_solution[(k+1)%n]] +\n                     distance_matrix_2[node_l, new_solution[(l-1)%n]] + distance_matrix_2[node_k, new_solution[(l+1)%n]]) - \\\n                    (distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[node_k, new_solution[(k+1)%n]] +\n                     distance_matrix_2[node_l, new_solution[(l-1)%n]] + distance_matrix_2[node_l, new_solution[(l+1)%n]])\n\n        # Only swap if it improves at least one objective\n        if cost_diff1 < 0 or cost_diff2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on non-dominated fronts and applies a hybrid local search combining 3-opt with a novel edge-swapping strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their non-dominated front (simplified approach)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a random solution from top 30% of the archive\n        selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 3))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search (3-opt + edge-swapping)\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Generate random indices for 3-opt\n    a, b, c = sorted(np.random.choice(N, 3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge-swapping: swap two edges if it improves both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        if j - i > 1:\n            # Calculate cost change\n            old_edges = [(new_solution[i], new_solution[(i+1)%N]),\n                         (new_solution[j], new_solution[(j+1)%N])]\n            new_edges = [(new_solution[i], new_solution[j]),\n                         (new_solution[(i+1)%N], new_solution[(j+1)%N])]\n\n            old_cost1 = sum(distance_matrix_1[a][b] for a, b in old_edges)\n            new_cost1 = sum(distance_matrix_1[a][b] for a, b in new_edges)\n            old_cost2 = sum(distance_matrix_2[a][b] for a, b in old_edges)\n            new_cost2 = sum(distance_matrix_2[a][b] for a, b in new_edges)\n\n            # Accept if both objectives improve\n            if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6803725474067501,
            0.5227134823799133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their non-dominated front (simplified approach)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a random solution from top 30% of the archive\n        selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 3))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search (3-opt + edge-swapping)\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Generate random indices for 3-opt\n    a, b, c = sorted(np.random.choice(N, 3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Edge-swapping: swap two edges if it improves both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        if j - i > 1:\n            # Calculate cost change\n            old_edges = [(new_solution[i], new_solution[(i+1)%N]),\n                         (new_solution[j], new_solution[(j+1)%N])]\n            new_edges = [(new_solution[i], new_solution[j]),\n                         (new_solution[(i+1)%N], new_solution[(j+1)%N])]\n\n            old_cost1 = sum(distance_matrix_1[a][b] for a, b in old_edges)\n            new_cost1 = sum(distance_matrix_1[a][b] for a, b in new_edges)\n            old_cost2 = sum(distance_matrix_2[a][b] for a, b in old_edges)\n            new_cost2 = sum(distance_matrix_2[a][b] for a, b in new_edges)\n\n            # Accept if both objectives improve\n            if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by identifying non-dominated solutions and iteratively applies a hybrid local search combining node relinking and adaptive segment inversion to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relinking + adaptive segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Node relinking: select a random segment and relink it to another position\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Find the best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for pos in range(n - len(segment) + 1):\n        if pos >= a and pos <= b:\n            continue\n        temp_solution = np.concatenate([base_solution[:pos], segment, base_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.concatenate([base_solution[:best_pos], segment, base_solution[best_pos:]])\n\n    # Adaptive segment inversion: invert a segment if it improves the solution\n    for _ in range(2):  # Limit the number of inversions\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        new_cost = cost1 + cost2\n        if new_cost < best_cost:\n            new_solution = temp_solution\n            best_cost = new_cost\n\n    return new_solution\n\n",
        "score": [
            -0.9405947138586979,
            1.408148467540741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relinking + adaptive segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Node relinking: select a random segment and relink it to another position\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Find the best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for pos in range(n - len(segment) + 1):\n        if pos >= a and pos <= b:\n            continue\n        temp_solution = np.concatenate([base_solution[:pos], segment, base_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.concatenate([base_solution[:best_pos], segment, base_solution[best_pos:]])\n\n    # Adaptive segment inversion: invert a segment if it improves the solution\n    for _ in range(2):  # Limit the number of inversions\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        new_cost = cost1 + cost2\n        if new_cost < best_cost:\n            new_solution = temp_solution\n            best_cost = new_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by identifying non-dominated solutions and iteratively applies a hybrid local search combining node relinking and adaptive segment inversion to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relinking + adaptive segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Node relinking: select a random segment and relink it to another position\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Find the best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for pos in range(n - len(segment) + 1):\n        if pos >= a and pos <= b:\n            continue\n        temp_solution = np.concatenate([base_solution[:pos], segment, base_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.concatenate([base_solution[:best_pos], segment, base_solution[best_pos:]])\n\n    # Adaptive segment inversion: invert a segment if it improves the solution\n    for _ in range(2):  # Limit the number of inversions\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        new_cost = cost1 + cost2\n        if new_cost < best_cost:\n            new_solution = temp_solution\n            best_cost = new_cost\n\n    return new_solution\n\n",
        "score": [
            -0.9405947138586979,
            1.408148467540741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relinking + adaptive segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Node relinking: select a random segment and relink it to another position\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Find the best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for pos in range(n - len(segment) + 1):\n        if pos >= a and pos <= b:\n            continue\n        temp_solution = np.concatenate([base_solution[:pos], segment, base_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.concatenate([base_solution[:best_pos], segment, base_solution[best_pos:]])\n\n    # Adaptive segment inversion: invert a segment if it improves the solution\n    for _ in range(2):  # Limit the number of inversions\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        new_cost = cost1 + cost2\n        if new_cost < best_cost:\n            new_solution = temp_solution\n            best_cost = new_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator combines edge swaps with a dynamic neighborhood exploration strategy, prioritizing regions of the solution space with high objective divergence and low local optima density to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (abs(x[1][0] - x[1][1]), sum(x[1])))  # Prioritize diversity and cost\n    selected = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Dynamic neighborhood exploration: reverse or shift the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse\n    else:\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n        segment = np.roll(segment, shift)  # Shift\n\n    new_solution[a:b+1] = segment\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        available = np.setdiff1d(np.arange(n), new_solution)\n        if len(available) > 0:\n            for i in np.where(new_solution == dup)[0][1:]:\n                new_solution[i] = np.random.choice(available)\n                available = np.setdiff1d(available, new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.9510808840147252,
            0.49268007278442383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (abs(x[1][0] - x[1][1]), sum(x[1])))  # Prioritize diversity and cost\n    selected = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Dynamic neighborhood exploration: reverse or shift the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse\n    else:\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n        segment = np.roll(segment, shift)  # Shift\n\n    new_solution[a:b+1] = segment\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        available = np.setdiff1d(np.arange(n), new_solution)\n        if len(available) > 0:\n            for i in np.where(new_solution == dup)[0][1:]:\n                new_solution[i] = np.random.choice(available)\n                available = np.setdiff1d(available, new_solution[i])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator combines edge swaps with a dynamic neighborhood exploration strategy, prioritizing regions of the solution space with high objective divergence and low local optima density to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (abs(x[1][0] - x[1][1]), sum(x[1])))  # Prioritize diversity and cost\n    selected = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Dynamic neighborhood exploration: reverse or shift the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse\n    else:\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n        segment = np.roll(segment, shift)  # Shift\n\n    new_solution[a:b+1] = segment\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        available = np.setdiff1d(np.arange(n), new_solution)\n        if len(available) > 0:\n            for i in np.where(new_solution == dup)[0][1:]:\n                new_solution[i] = np.random.choice(available)\n                available = np.setdiff1d(available, new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.9510808840147252,
            0.49268007278442383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (abs(x[1][0] - x[1][1]), sum(x[1])))  # Prioritize diversity and cost\n    selected = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Dynamic neighborhood exploration: reverse or shift the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse\n    else:\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n        segment = np.roll(segment, shift)  # Shift\n\n    new_solution[a:b+1] = segment\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        available = np.setdiff1d(np.arange(n), new_solution)\n        if len(available) > 0:\n            for i in np.where(new_solution == dup)[0][1:]:\n                new_solution[i] = np.random.choice(available)\n                available = np.setdiff1d(available, new_solution[i])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel edge-swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform 2-opt on the first objective\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n - 1):\n            for j in range(i + 2, n - 1):\n                a, b = new_solution[i], new_solution[i + 1]\n                c, d = new_solution[j], new_solution[j + 1]\n                if distance_matrix_1[a][b] + distance_matrix_1[c][d] > distance_matrix_1[a][c] + distance_matrix_1[b][d]:\n                    new_solution[i + 1:j + 1] = new_solution[i + 1:j + 1][::-1]\n                    improved = True\n\n    # Step 2: Novel edge-swap operator focusing on the second objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = new_solution[i], new_solution[j]\n        # Check if swapping edges reduces the second objective\n        if (distance_matrix_2[a][b] + distance_matrix_2[new_solution[i - 1]][new_solution[(i + 1) % n]] +\n            distance_matrix_2[new_solution[j - 1]][new_solution[(j + 1) % n]]) > \\\n           (distance_matrix_2[new_solution[i - 1]][b] + distance_matrix_2[a][new_solution[(i + 1) % n]] +\n            distance_matrix_2[new_solution[j - 1]][a] + distance_matrix_2[b][new_solution[(j + 1) % n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8528501076957962,
            6.217487215995789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel edge-swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform 2-opt on the first objective\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n - 1):\n            for j in range(i + 2, n - 1):\n                a, b = new_solution[i], new_solution[i + 1]\n                c, d = new_solution[j], new_solution[j + 1]\n                if distance_matrix_1[a][b] + distance_matrix_1[c][d] > distance_matrix_1[a][c] + distance_matrix_1[b][d]:\n                    new_solution[i + 1:j + 1] = new_solution[i + 1:j + 1][::-1]\n                    improved = True\n\n    # Step 2: Novel edge-swap operator focusing on the second objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = new_solution[i], new_solution[j]\n        # Check if swapping edges reduces the second objective\n        if (distance_matrix_2[a][b] + distance_matrix_2[new_solution[i - 1]][new_solution[(i + 1) % n]] +\n            distance_matrix_2[new_solution[j - 1]][new_solution[(j + 1) % n]]) > \\\n           (distance_matrix_2[new_solution[i - 1]][b] + distance_matrix_2[a][new_solution[(i + 1) % n]] +\n            distance_matrix_2[new_solution[j - 1]][a] + distance_matrix_2[b][new_solution[(j + 1) % n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective aware selection of solutions with a dynamic edge exchange operator that balances improvements in both objective spaces, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(x[1][0] for _, obj in archive) + sum(x[1][1] for _, obj in archive)))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic edge exchange: randomly select two segments and exchange them\n    if n > 3:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        k, l = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n        # Ensure the exchange maintains feasibility\n        if i < j and k < l and not (i <= k <= j and j <= l):\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n\n            # Exchange the segments\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt move if the exchange fails\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6960062601917208,
            1.590690791606903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(x[1][0] for _, obj in archive) + sum(x[1][1] for _, obj in archive)))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic edge exchange: randomly select two segments and exchange them\n    if n > 3:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        k, l = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n        # Ensure the exchange maintains feasibility\n        if i < j and k < l and not (i <= k <= j and j <= l):\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n\n            # Exchange the segments\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt move if the exchange fails\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        candidate_size = max(1, len(sorted_archive) // 5)\n        candidates = sorted_archive[:candidate_size]\n        selected = random.choice(candidates)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion\n    if k < i or k > j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8054238704787116,
            0.47761017084121704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        candidate_size = max(1, len(sorted_archive) // 5)\n        candidates = sorted_archive[:candidate_size]\n        selected = random.choice(candidates)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion\n    if k < i or k > j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on the trade-off between the two objectives, then applies a hybrid local search operator that combines edge insertion and variable-length segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives to avoid bias\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        # Select solution with best trade-off (e.g., smallest sum of normalized objectives)\n        selected_idx = np.argmin(normalized.sum(axis=1))\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: variable-length segment relocation with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of variable length\n        seg_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes the sum of distances in both spaces\n        best_pos = 0\n        best_cost = np.inf\n        for pos in range(len(new_solution) - seg_length + 1):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost in both spaces\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6198896925224088,
            4.349136650562286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives to avoid bias\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        # Select solution with best trade-off (e.g., smallest sum of normalized objectives)\n        selected_idx = np.argmin(normalized.sum(axis=1))\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: variable-length segment relocation with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of variable length\n        seg_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes the sum of distances in both spaces\n        best_pos = 0\n        best_cost = np.inf\n        for pos in range(len(new_solution) - seg_length + 1):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost in both spaces\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: probabilistic 3-opt with edge-based diversification\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a probabilistic 3-opt-like move with edge-based diversification\n    if random.random() < 0.7:  # Higher probability for 3-opt-like moves\n        # Create three possible permutations and select the best one\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[c+1:], new_solution[a:b], new_solution[b:c+1]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        best_candidate = min(candidates, key=evaluate)\n        new_solution = best_candidate.copy()\n    else:\n        # Edge-based diversification: swap edges with high cross-objective potential\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            # Swap edges with high potential for improvement in both objectives\n            if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n               distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Reverse a segment with high cross-objective potential\n            segment = new_solution[i:j+1]\n            if sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) > \\\n               sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]):\n                new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9625348823282736,
            0.5551475286483765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: probabilistic 3-opt with edge-based diversification\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a probabilistic 3-opt-like move with edge-based diversification\n    if random.random() < 0.7:  # Higher probability for 3-opt-like moves\n        # Create three possible permutations and select the best one\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[c+1:], new_solution[a:b], new_solution[b:c+1]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        best_candidate = min(candidates, key=evaluate)\n        new_solution = best_candidate.copy()\n    else:\n        # Edge-based diversification: swap edges with high cross-objective potential\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            # Swap edges with high potential for improvement in both objectives\n            if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n               distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Reverse a segment with high cross-objective potential\n            segment = new_solution[i:j+1]\n            if sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) > \\\n               sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]):\n                new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: probabilistic 3-opt with edge-based diversification\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a probabilistic 3-opt-like move with edge-based diversification\n    if random.random() < 0.7:  # Higher probability for 3-opt-like moves\n        # Create three possible permutations and select the best one\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[c+1:], new_solution[a:b], new_solution[b:c+1]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        best_candidate = min(candidates, key=evaluate)\n        new_solution = best_candidate.copy()\n    else:\n        # Edge-based diversification: swap edges with high cross-objective potential\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            # Swap edges with high potential for improvement in both objectives\n            if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n               distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Reverse a segment with high cross-objective potential\n            segment = new_solution[i:j+1]\n            if sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) > \\\n               sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]):\n                new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9625348823282736,
            0.5551475286483765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: probabilistic 3-opt with edge-based diversification\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a probabilistic 3-opt-like move with edge-based diversification\n    if random.random() < 0.7:  # Higher probability for 3-opt-like moves\n        # Create three possible permutations and select the best one\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[c+1:], new_solution[a:b], new_solution[b:c+1]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        best_candidate = min(candidates, key=evaluate)\n        new_solution = best_candidate.copy()\n    else:\n        # Edge-based diversification: swap edges with high cross-objective potential\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            # Swap edges with high potential for improvement in both objectives\n            if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] > \\\n               distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Reverse a segment with high cross-objective potential\n            segment = new_solution[i:j+1]\n            if sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) > \\\n               sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]) + \\\n               sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)[::-1]):\n                new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt to the first objective space\n    for i in range(n - 2):\n        for j in range(i + 2, n):\n            if j + 1 < n:\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1) % n]\n                if (distance_matrix_1[a, b] + distance_matrix_1[c, d]) > (distance_matrix_1[a, c] + distance_matrix_1[b, d]):\n                    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Apply a novel edge-swap strategy to the second objective space\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a, b, c, d = new_solution[i], new_solution[(i+1) % n], new_solution[j], new_solution[(j+1) % n]\n            if (distance_matrix_2[a, b] + distance_matrix_2[c, d]) > (distance_matrix_2[a, c] + distance_matrix_2[b, d]):\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 3: Randomly perturb the solution to escape local optima\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8630816530166566,
            4.061498403549194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt to the first objective space\n    for i in range(n - 2):\n        for j in range(i + 2, n):\n            if j + 1 < n:\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1) % n]\n                if (distance_matrix_1[a, b] + distance_matrix_1[c, d]) > (distance_matrix_1[a, c] + distance_matrix_1[b, d]):\n                    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Apply a novel edge-swap strategy to the second objective space\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a, b, c, d = new_solution[i], new_solution[(i+1) % n], new_solution[j], new_solution[(j+1) % n]\n            if (distance_matrix_2[a, b] + distance_matrix_2[c, d]) > (distance_matrix_2[a, c] + distance_matrix_2[b, d]):\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 3: Randomly perturb the solution to escape local optima\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break and reconnect\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect with a novel edge-based swap\n    if np.random.rand() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Invalid solution: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.798002988442631,
            0.4642765522003174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break and reconnect\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect with a novel edge-based swap\n    if np.random.rand() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Invalid solution: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm intelligently selects a high-performing solution from the archive based on Pareto dominance or non-dominated sorting, then applies a hybrid local search combining edge exchange and path relinking to generate a neighbor solution, ensuring feasibility and diverse improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Exchange + Path Relinking\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: Edge Exchange (swap two non-adjacent edges)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j or (i + 1) % n == j or (j + 1) % n == i:\n        # Ensure edges are not adjacent\n        i = (i + 2) % n\n        j = (j + 2) % n\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Path Relinking (shorten the path between two nodes)\n    a, b = sorted(random.sample(range(n), 2))\n    if a == b:\n        b = (b + 1) % n\n\n    # Reverse the segment between a and b to potentially improve both objectives\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility: no duplicates or missing nodes\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Revert if invalid\n        new_solution = base_solution.copy()\n        # Fallback: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9380962633122842,
            0.4717927575111389
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Exchange + Path Relinking\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: Edge Exchange (swap two non-adjacent edges)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j or (i + 1) % n == j or (j + 1) % n == i:\n        # Ensure edges are not adjacent\n        i = (i + 2) % n\n        j = (j + 2) % n\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Path Relinking (shorten the path between two nodes)\n    a, b = sorted(random.sample(range(n), 2))\n    if a == b:\n        b = (b + 1) % n\n\n    # Reverse the segment between a and b to potentially improve both objectives\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility: no duplicates or missing nodes\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Revert if invalid\n        new_solution = base_solution.copy()\n        # Fallback: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel hybrid local search operator that combines edge exchange with a dynamic path segment reordering strategy, guided by Pareto-dominance and cost diversity, to generate high-quality neighbors by intelligently selecting and perturbing promising segments of the tour while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the lowest sum of objectives)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour to perturb\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Reverse the segment to create a new neighbor\n    reversed_segment = segment[::-1]\n\n    if start < end:\n        new_solution[start:end] = reversed_segment\n    else:\n        new_solution[start:] = reversed_segment[:n-start]\n        new_solution[:end] = reversed_segment[n-start:]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6999326608135076,
            0.46268367767333984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the lowest sum of objectives)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour to perturb\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Reverse the segment to create a new neighbor\n    reversed_segment = segment[::-1]\n\n    if start < end:\n        new_solution[start:end] = reversed_segment\n    else:\n        new_solution[start:] = reversed_segment[:n-start]\n        new_solution[:end] = reversed_segment[n-start:]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{A hybrid local search algorithm that combines a novel adaptive edge insertion strategy with a multi-objective-aware segment relocation to intelligently explore the solution space while ensuring feasibility and promoting diverse high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + random.uniform(-0.1, 0.1)))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Adaptive edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive edge insertion\n    for _ in range(2):  # Perform 2 adaptive insertions\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Evaluate insertion points based on both objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for k in range(len(remaining)):\n            candidate = np.concatenate([remaining[:k], segment, remaining[k:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = (cost1 + cost2) * (1 + random.uniform(-0.2, 0.2))  # Add randomness for diversity\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = k\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Step 2: Multi-objective-aware segment relocation\n    for _ in range(2):  # Perform 2 relocations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Find best relocation point considering both objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for k in range(len(remaining)):\n            candidate = np.concatenate([remaining[:k], segment, remaining[k:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            # Weighted sum with randomness to balance both objectives\n            total_cost = 0.7 * cost1 + 0.3 * cost2 + random.uniform(-0.1, 0.1) * (cost1 + cost2)\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = k\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5876212562168015,
            6.923942983150482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + random.uniform(-0.1, 0.1)))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Adaptive edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive edge insertion\n    for _ in range(2):  # Perform 2 adaptive insertions\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Evaluate insertion points based on both objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for k in range(len(remaining)):\n            candidate = np.concatenate([remaining[:k], segment, remaining[k:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = (cost1 + cost2) * (1 + random.uniform(-0.2, 0.2))  # Add randomness for diversity\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = k\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Step 2: Multi-objective-aware segment relocation\n    for _ in range(2):  # Perform 2 relocations\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Find best relocation point considering both objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for k in range(len(remaining)):\n            candidate = np.concatenate([remaining[:k], segment, remaining[k:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            # Weighted sum with randomness to balance both objectives\n            total_cost = 0.7 * cost1 + 0.3 * cost2 + random.uniform(-0.1, 0.1) * (cost1 + cost2)\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = k\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution, ensuring feasibility and exploring diverse improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + node insertion\n    if n > 3:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion\n        if n > 4:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9007586490018937,
            0.46562081575393677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + node insertion\n    if n > 3:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion\n        if n > 4:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution, ensuring feasibility and exploring diverse improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + node insertion\n    if n > 3:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion\n        if n > 4:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9007586490018937,
            0.46562081575393677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + node insertion\n    if n > 3:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion\n        if n > 4:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution, ensuring feasibility and exploring diverse improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + node insertion\n    if n > 3:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion\n        if n > 4:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9007586490018937,
            0.46562081575393677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + node insertion\n    if n > 3:\n        # Segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion\n        if n > 4:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high objective values (indicating potential for improvement), then applies a hybrid local search that combines edge swaps and segment reversals to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 or available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine segment reversal and edge swap\n    if n > 3:\n        # Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge swap (swap two non-adjacent edges)\n        if n > 4:\n            i, j = random.sample(range(1, n-1), 2)\n            if abs(i - j) > 1:  # Ensure edges are not adjacent\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8873110014102064,
            0.47888123989105225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(2, len(archive_sorted) - 1)  # Select from top 3 or available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine segment reversal and edge swap\n    if n > 3:\n        # Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge swap (swap two non-adjacent edges)\n        if n > 4:\n            i, j = random.sample(range(1, n-1), 2)\n            if abs(i - j) > 1:  # Ensure edges are not adjacent\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A hybrid local search algorithm that combines a node insertion heuristic with a variable-length segment relocation strategy to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: variable-length segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment length (2 to n//2)\n        segment_length = np.random.randint(2, min(n//2, 10))\n\n        # Select a random starting position for the segment\n        start = np.random.randint(0, n - segment_length)\n\n        # Extract the segment\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert the segment at a new random position\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8777911324805716,
            0.5061088800430298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: variable-length segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment length (2 to n//2)\n        segment_length = np.random.randint(2, min(n//2, 10))\n\n        # Select a random starting position for the segment\n        start = np.random.randint(0, n - segment_length)\n\n        # Extract the segment\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert the segment at a new random position\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines a randomized edge insertion with a multi-objective-aware segment reversal, prioritizing solutions with high potential for improvement based on non-dominated ranks and crowding distances, while ensuring feasibility through strict validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection based on the sum of objectives (can be replaced with more sophisticated multi-objective selection)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.6, 0.3, 0.1] if len(archive_sorted) >= 3 else None)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select a segment to reverse (multi-objective-aware)\n    start = np.random.randint(0, n - 3)\n    end = np.random.randint(start + 2, n - 1)\n\n    # Segment reversal (similar to 3-opt but with multi-objective consideration)\n    segment = new_solution[start:end+1]\n    if np.random.rand() < 0.5:\n        segment = np.flip(segment)\n    else:\n        # Insertion-based move\n        insert_pos = np.random.randint(0, n)\n        if insert_pos < start:\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end+1:]])\n        elif insert_pos > end:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end+1:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Validate the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7355868522061849,
            0.6371167302131653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection based on the sum of objectives (can be replaced with more sophisticated multi-objective selection)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.6, 0.3, 0.1] if len(archive_sorted) >= 3 else None)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select a segment to reverse (multi-objective-aware)\n    start = np.random.randint(0, n - 3)\n    end = np.random.randint(start + 2, n - 1)\n\n    # Segment reversal (similar to 3-opt but with multi-objective consideration)\n    segment = new_solution[start:end+1]\n    if np.random.rand() < 0.5:\n        segment = np.flip(segment)\n    else:\n        # Insertion-based move\n        insert_pos = np.random.randint(0, n)\n        if insert_pos < start:\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end+1:]])\n        elif insert_pos > end:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end+1:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n    # Validate the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with segment inversion and objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select three distinct segments\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Apply 3-opt style move (partial segment reversal)\n        segment = new_solution[a:b+1]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]  # Reverse segment\n        new_solution[a:b+1] = segment\n\n        # Objective-aware swap: swap nodes that improve both objectives\n        for i in range(a, b+1):\n            for j in range(b+1, min(b+5, n)):\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[j+1 if j+1 < n else 0]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[j+1 if j+1 < n else 0]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n                if delta1 < 0 and delta2 < 0:  # Both objectives improve\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7996139895807548,
            4.171752691268921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with segment inversion and objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select three distinct segments\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Apply 3-opt style move (partial segment reversal)\n        segment = new_solution[a:b+1]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]  # Reverse segment\n        new_solution[a:b+1] = segment\n\n        # Objective-aware swap: swap nodes that improve both objectives\n        for i in range(a, b+1):\n            for j in range(b+1, min(b+5, n)):\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[j+1 if j+1 < n else 0]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[j+1 if j+1 < n else 0]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]])\n\n                if delta1 < 0 and delta2 < 0:  # Both objectives improve\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This heuristic selects a solution from the archive with the lowest combined objective value, then applies a hybrid local search combining edge exchange and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to rotate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Rotate the segment\n    segment = new_solution[seg_start:seg_end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end] = rotated_segment\n\n    # Randomly select two edges to exchange\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Ensure the exchange maintains feasibility\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7100384588082875,
            0.45315372943878174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to rotate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Rotate the segment\n    segment = new_solution[seg_start:seg_end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end] = rotated_segment\n\n    # Randomly select two edges to exchange\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Ensure the exchange maintains feasibility\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This heuristic selects a solution from the archive with the lowest combined objective value, then applies a hybrid local search combining edge exchange and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to rotate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Rotate the segment\n    segment = new_solution[seg_start:seg_end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end] = rotated_segment\n\n    # Randomly select two edges to exchange\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Ensure the exchange maintains feasibility\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7100384588082875,
            0.45315372943878174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to rotate\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Rotate the segment\n    segment = new_solution[seg_start:seg_end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end] = rotated_segment\n\n    # Randomly select two edges to exchange\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Ensure the exchange maintains feasibility\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion with edge insertion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Select a random segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    if a == b:\n        b = (b + 1) % n\n\n    # Invert the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        c = random.randint(0, n - 1)\n        d = random.randint(0, n - 1)\n        if c != d and abs(c - d) > 1:\n            # Ensure we don't create invalid segments\n            if c > d:\n                c, d = d, c\n            temp = new_solution[d]\n            new_solution[c+1:d+1] = np.roll(new_solution[c+1:d+1], -1)\n            new_solution[c+1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8695636272950745,
            0.11882543563842773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion with edge insertion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Select a random segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    if a == b:\n        b = (b + 1) % n\n\n    # Invert the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        c = random.randint(0, n - 1)\n        d = random.randint(0, n - 1)\n        if c != d and abs(c - d) > 1:\n            # Ensure we don't create invalid segments\n            if c > d:\n                c, d = d, c\n            temp = new_solution[d]\n            new_solution[c+1:d+1] = np.roll(new_solution[c+1:d+1], -1)\n            new_solution[c+1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion with edge insertion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Select a random segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    if a == b:\n        b = (b + 1) % n\n\n    # Invert the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        c = random.randint(0, n - 1)\n        d = random.randint(0, n - 1)\n        if c != d and abs(c - d) > 1:\n            # Ensure we don't create invalid segments\n            if c > d:\n                c, d = d, c\n            temp = new_solution[d]\n            new_solution[c+1:d+1] = np.roll(new_solution[c+1:d+1], -1)\n            new_solution[c+1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8695636272950745,
            0.11882543563842773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment inversion with edge insertion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Select a random segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    if a == b:\n        b = (b + 1) % n\n\n    # Invert the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        c = random.randint(0, n - 1)\n        d = random.randint(0, n - 1)\n        if c != d and abs(c - d) > 1:\n            # Ensure we don't create invalid segments\n            if c > d:\n                c, d = d, c\n            temp = new_solution[d]\n            new_solution[c+1:d+1] = np.roll(new_solution[c+1:d+1], -1)\n            new_solution[c+1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a combination of edge insertion and partial route reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best combined objective)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_objectives[:, 0] + normalized_objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    num_nodes = len(new_solution)\n\n    # Hybrid local search: edge insertion + partial route reversal\n    # Step 1: Select a random segment to remove\n    a, b = sorted(np.random.choice(num_nodes, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and reverse it\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    reversed_segment = segment[::-1]\n\n    # Step 3: Insert the reversed segment at a new position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, reversed_segment)\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes included)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != num_nodes or np.any(counts != 1):\n        # Fallback to a simple swap if the hybrid operator fails\n        i, j = np.random.choice(num_nodes, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7108527337465116,
            0.513068437576294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the best combined objective)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_objectives[:, 0] + normalized_objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    num_nodes = len(new_solution)\n\n    # Hybrid local search: edge insertion + partial route reversal\n    # Step 1: Select a random segment to remove\n    a, b = sorted(np.random.choice(num_nodes, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and reverse it\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    reversed_segment = segment[::-1]\n\n    # Step 3: Insert the reversed segment at a new position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, reversed_segment)\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes included)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != num_nodes or np.any(counts != 1):\n        # Fallback to a simple swap if the hybrid operator fails\n        i, j = np.random.choice(num_nodes, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion heuristic\n    n = len(base_solution)\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    # Perform a 3-opt-like move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    # Insert a randomly selected edge at a different position\n    insert_pos = np.random.randint(0, n)\n    if insert_pos != a and insert_pos != b and insert_pos != c:\n        new_solution = np.insert(new_solution, insert_pos, new_solution[a])\n        new_solution = np.delete(new_solution, a + (1 if insert_pos < a else 0))\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9536927108052775,
            0.48174160718917847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion heuristic\n    n = len(base_solution)\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    # Perform a 3-opt-like move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    # Insert a randomly selected edge at a different position\n    insert_pos = np.random.randint(0, n)\n    if insert_pos != a and insert_pos != b and insert_pos != c:\n        new_solution = np.insert(new_solution, insert_pos, new_solution[a])\n        new_solution = np.delete(new_solution, a + (1 if insert_pos < a else 0))\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion heuristic\n    n = len(base_solution)\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    # Perform a 3-opt-like move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    # Insert a randomly selected edge at a different position\n    insert_pos = np.random.randint(0, n)\n    if insert_pos != a and insert_pos != b and insert_pos != c:\n        new_solution = np.insert(new_solution, insert_pos, new_solution[a])\n        new_solution = np.delete(new_solution, a + (1 if insert_pos < a else 0))\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9536927108052775,
            0.48174160718917847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion heuristic\n    n = len(base_solution)\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    # Perform a 3-opt-like move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    # Insert a randomly selected edge at a different position\n    insert_pos = np.random.randint(0, n)\n    if insert_pos != a and insert_pos != b and insert_pos != c:\n        new_solution = np.insert(new_solution, insert_pos, new_solution[a])\n        new_solution = np.delete(new_solution, a + (1 if insert_pos < a else 0))\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The heuristic function selects a solution from the archive by prioritizing those with the best trade-off between the two objectives, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off (using hypervolume-based selection)\n    selected_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it (node reordering)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Perform edge insertion (move a random node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7939189791914194,
            0.46225404739379883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off (using hypervolume-based selection)\n    selected_idx = np.argmin([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it (node reordering)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Perform edge insertion (move a random node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A hybrid local search algorithm that combines edge swapping with adaptive segment relocation, prioritizing solutions with diverse edge contributions across both objective spaces to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def edge_diversity(solution, dm1, dm2):\n        total = 0.0\n        n = len(solution)\n        for i in range(n):\n            u, v = solution[i], solution[(i+1)%n]\n            total += abs(dm1[u, v] - dm2[u, v])\n        return total\n\n    # Sort solutions by edge diversity (higher is better)\n    archive.sort(key=lambda x: -edge_diversity(x[0], distance_matrix_1, distance_matrix_2))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: adaptive segment relocation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (3 to n//3)\n    seg_len = random.randint(3, n // 3)\n    start = random.randint(0, n - seg_len)\n\n    # Extract and reverse the segment\n    segment = new_solution[start:start+seg_len]\n    reversed_segment = segment[::-1]\n\n    # Adaptive insertion: find best position to reinsert\n    best_pos = start\n    best_cost = float('inf')\n\n    for pos in range(n - seg_len + 1):\n        if pos == start:\n            continue  # Skip original position\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            reversed_segment,\n            new_solution[pos+seg_len:]\n        ])\n        # Evaluate cost (weighted sum of both objectives)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Apply the best found insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        reversed_segment,\n        new_solution[best_pos+seg_len:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.9831665299114941,
            6.804068624973297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def edge_diversity(solution, dm1, dm2):\n        total = 0.0\n        n = len(solution)\n        for i in range(n):\n            u, v = solution[i], solution[(i+1)%n]\n            total += abs(dm1[u, v] - dm2[u, v])\n        return total\n\n    # Sort solutions by edge diversity (higher is better)\n    archive.sort(key=lambda x: -edge_diversity(x[0], distance_matrix_1, distance_matrix_2))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: adaptive segment relocation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (3 to n//3)\n    seg_len = random.randint(3, n // 3)\n    start = random.randint(0, n - seg_len)\n\n    # Extract and reverse the segment\n    segment = new_solution[start:start+seg_len]\n    reversed_segment = segment[::-1]\n\n    # Adaptive insertion: find best position to reinsert\n    best_pos = start\n    best_cost = float('inf')\n\n    for pos in range(n - seg_len + 1):\n        if pos == start:\n            continue  # Skip original position\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            reversed_segment,\n            new_solution[pos+seg_len:]\n        ])\n        # Evaluate cost (weighted sum of both objectives)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Apply the best found insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        reversed_segment,\n        new_solution[best_pos+seg_len:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A hybrid local search algorithm that combines edge swapping with adaptive segment relocation, prioritizing solutions with diverse edge contributions across both objective spaces to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def edge_diversity(solution, dm1, dm2):\n        total = 0.0\n        n = len(solution)\n        for i in range(n):\n            u, v = solution[i], solution[(i+1)%n]\n            total += abs(dm1[u, v] - dm2[u, v])\n        return total\n\n    # Sort solutions by edge diversity (higher is better)\n    archive.sort(key=lambda x: -edge_diversity(x[0], distance_matrix_1, distance_matrix_2))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: adaptive segment relocation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (3 to n//3)\n    seg_len = random.randint(3, n // 3)\n    start = random.randint(0, n - seg_len)\n\n    # Extract and reverse the segment\n    segment = new_solution[start:start+seg_len]\n    reversed_segment = segment[::-1]\n\n    # Adaptive insertion: find best position to reinsert\n    best_pos = start\n    best_cost = float('inf')\n\n    for pos in range(n - seg_len + 1):\n        if pos == start:\n            continue  # Skip original position\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            reversed_segment,\n            new_solution[pos+seg_len:]\n        ])\n        # Evaluate cost (weighted sum of both objectives)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Apply the best found insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        reversed_segment,\n        new_solution[best_pos+seg_len:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.9831665299114941,
            6.804068624973297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def edge_diversity(solution, dm1, dm2):\n        total = 0.0\n        n = len(solution)\n        for i in range(n):\n            u, v = solution[i], solution[(i+1)%n]\n            total += abs(dm1[u, v] - dm2[u, v])\n        return total\n\n    # Sort solutions by edge diversity (higher is better)\n    archive.sort(key=lambda x: -edge_diversity(x[0], distance_matrix_1, distance_matrix_2))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: adaptive segment relocation\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (3 to n//3)\n    seg_len = random.randint(3, n // 3)\n    start = random.randint(0, n - seg_len)\n\n    # Extract and reverse the segment\n    segment = new_solution[start:start+seg_len]\n    reversed_segment = segment[::-1]\n\n    # Adaptive insertion: find best position to reinsert\n    best_pos = start\n    best_cost = float('inf')\n\n    for pos in range(n - seg_len + 1):\n        if pos == start:\n            continue  # Skip original position\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            reversed_segment,\n            new_solution[pos+seg_len:]\n        ])\n        # Evaluate cost (weighted sum of both objectives)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Apply the best found insertion\n    new_solution = np.concatenate([\n        new_solution[:best_pos],\n        reversed_segment,\n        new_solution[best_pos+seg_len:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge exchange and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with randomness)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a random node to a new position)\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.846793804621463,
            0.45416903495788574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge exchange and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with randomness)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion (move a random node to a new position)\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search algorithm that combines 3-opt with a multi-objective aware edge insertion heuristic to intelligently explore the solution space while ensuring feasibility and diversity in generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select a segment to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (3-opt)\n    new_solution[a:b+1] = segment[::-1]\n\n    # Multi-objective edge insertion: find the best insertion point\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for i in range(n):\n        if i >= a and i <= b:  # Skip the modified segment\n            continue\n\n        # Calculate the change in both objectives\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        # Remove the current edge and add new edges\n        old_dist1 = distance_matrix_1[prev_node, next_node]\n        old_dist2 = distance_matrix_2[prev_node, next_node]\n\n        # Try inserting segment before i\n        new_dist1 = (distance_matrix_1[prev_node, segment[0]] +\n                     distance_matrix_1[segment[-1], next_node])\n        new_dist2 = (distance_matrix_2[prev_node, segment[0]] +\n                     distance_matrix_2[segment[-1], next_node])\n\n        improvement1 = old_dist1 - new_dist1\n        improvement2 = old_dist2 - new_dist2\n\n        # Use weighted sum of improvements (could be replaced with Pareto dominance)\n        total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_insert_pos = i\n\n    # Apply the best insertion if it improves at least one objective\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9354541907193288,
            0.2509480118751526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: 3-opt with multi-objective edge insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select a segment to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (3-opt)\n    new_solution[a:b+1] = segment[::-1]\n\n    # Multi-objective edge insertion: find the best insertion point\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for i in range(n):\n        if i >= a and i <= b:  # Skip the modified segment\n            continue\n\n        # Calculate the change in both objectives\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        # Remove the current edge and add new edges\n        old_dist1 = distance_matrix_1[prev_node, next_node]\n        old_dist2 = distance_matrix_2[prev_node, next_node]\n\n        # Try inserting segment before i\n        new_dist1 = (distance_matrix_1[prev_node, segment[0]] +\n                     distance_matrix_1[segment[-1], next_node])\n        new_dist2 = (distance_matrix_2[prev_node, segment[0]] +\n                     distance_matrix_2[segment[-1], next_node])\n\n        improvement1 = old_dist1 - new_dist1\n        improvement2 = old_dist2 - new_dist2\n\n        # Use weighted sum of improvements (could be replaced with Pareto dominance)\n        total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_insert_pos = i\n\n    # Apply the best insertion if it improves at least one objective\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_costs = np.array([(obj[0] + obj[1]) / (sum(obj) + 1e-10) for obj in objectives])\n    selected_idx = np.argmin(normalized_costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic segment reversal with edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (dynamic segment reversal)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge swapping between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to random swap if infeasible\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9192944959732523,
            0.4551934003829956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_costs = np.array([(obj[0] + obj[1]) / (sum(obj) + 1e-10) for obj in objectives])\n    selected_idx = np.argmin(normalized_costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic segment reversal with edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (dynamic segment reversal)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge swapping between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to random swap if infeasible\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive via Pareto-based selection, then applies a hybrid local search combining edge exchange and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n\n    # Step 2: Hybrid local search (edge exchange + path relinking)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path relinking\n    k = random.randint(1, n-2)\n    l = random.randint(k+1, n-1)\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7703901866162858,
            0.4973750114440918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n\n    # Step 2: Hybrid local search (edge exchange + path relinking)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path relinking\n    k = random.randint(1, n-2)\n    l = random.randint(k+1, n-1)\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for idx in range(n):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{A hybrid local search operator that combines adaptive edge exchange with probabilistic sub-tour reversal, guided by the Pareto front's non-dominated solutions, to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection: pick a random solution from the top 50% of the archive\n        selected_idx = random.randint(0, len(archive) // 2 - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive edge exchange + probabilistic sub-tour reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive edge exchange\n    # Select two random edges to exchange (avoid consecutive edges)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Exchange edges (i, i+1) and (j, j+1)\n    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Step 2: Probabilistic sub-tour reversal\n    # Reverse a random sub-tour with probability 0.5\n    if random.random() < 0.5:\n        sub_start = random.randint(0, n - 3)\n        sub_end = random.randint(sub_start + 2, n - 1)\n        new_solution[sub_start:sub_end+1] = new_solution[sub_start:sub_end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9163854872294783,
            0.671546220779419
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Simple selection: pick a random solution from the top 50% of the archive\n        selected_idx = random.randint(0, len(archive) // 2 - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive edge exchange + probabilistic sub-tour reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive edge exchange\n    # Select two random edges to exchange (avoid consecutive edges)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Exchange edges (i, i+1) and (j, j+1)\n    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Step 2: Probabilistic sub-tour reversal\n    # Reverse a random sub-tour with probability 0.5\n    if random.random() < 0.5:\n        sub_start = random.randint(0, n - 3)\n        sub_end = random.randint(sub_start + 2, n - 1)\n        new_solution[sub_start:sub_end+1] = new_solution[sub_start:sub_end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid of Pareto dominance and solution diversity, then applies a novel 3-opt-inspired local search with adaptive perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def selection_criteria(sol_obj):\n        sol, obj = sol_obj\n        # Combine objectives and add small randomness to break ties\n        combined = obj[0] + obj[1] + random.uniform(0, 0.01)\n        return combined\n\n    # Sort solutions by selection criteria (lower is better)\n    archive_sorted = sorted(archive, key=selection_criteria)\n\n    # Select top 20% of solutions\n    top_k = max(1, len(archive_sorted) // 5)\n    selected = random.choice(archive_sorted[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator (3-opt with adaptive perturbation)\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_sol = solution.copy()\n\n        # Randomly select 3 distinct edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_sol[a:b]\n        segment2 = new_sol[b:c]\n\n        # Create 3 possible new configurations\n        option1 = np.concatenate([new_sol[:a], segment2, segment1, new_sol[c:]])\n        option2 = np.concatenate([new_sol[:a], segment2[::-1], segment1, new_sol[c:]])\n        option3 = np.concatenate([new_sol[:a], segment1[::-1], segment2, new_sol[c:]])\n\n        # Evaluate all options\n        def evaluate(sol):\n            total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return total1 + total2\n\n        options = [option1, option2, option3]\n        evaluations = [evaluate(opt) for opt in options]\n\n        # Select best option\n        best_idx = np.argmin(evaluations)\n        new_sol = options[best_idx]\n\n        # Adaptive perturbation: sometimes reverse a random segment\n        if random.random() < 0.3:  # 30% chance\n            p1, p2 = sorted(random.sample(range(n), 2))\n            new_sol[p1:p2] = new_sol[p1:p2][::-1]\n\n        return new_sol\n\n    new_solution = hybrid_local_search(base_solution)\n\n    # Ensure solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.896410304880242,
            0.8134108185768127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def selection_criteria(sol_obj):\n        sol, obj = sol_obj\n        # Combine objectives and add small randomness to break ties\n        combined = obj[0] + obj[1] + random.uniform(0, 0.01)\n        return combined\n\n    # Sort solutions by selection criteria (lower is better)\n    archive_sorted = sorted(archive, key=selection_criteria)\n\n    # Select top 20% of solutions\n    top_k = max(1, len(archive_sorted) // 5)\n    selected = random.choice(archive_sorted[:top_k])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator (3-opt with adaptive perturbation)\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_sol = solution.copy()\n\n        # Randomly select 3 distinct edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_sol[a:b]\n        segment2 = new_sol[b:c]\n\n        # Create 3 possible new configurations\n        option1 = np.concatenate([new_sol[:a], segment2, segment1, new_sol[c:]])\n        option2 = np.concatenate([new_sol[:a], segment2[::-1], segment1, new_sol[c:]])\n        option3 = np.concatenate([new_sol[:a], segment1[::-1], segment2, new_sol[c:]])\n\n        # Evaluate all options\n        def evaluate(sol):\n            total1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return total1 + total2\n\n        options = [option1, option2, option3]\n        evaluations = [evaluate(opt) for opt in options]\n\n        # Select best option\n        best_idx = np.argmin(evaluations)\n        new_sol = options[best_idx]\n\n        # Adaptive perturbation: sometimes reverse a random segment\n        if random.random() < 0.3:  # 30% chance\n            p1, p2 = sorted(random.sample(range(n), 2))\n            new_sol[p1:p2] = new_sol[p1:p2][::-1]\n\n        return new_sol\n\n    new_solution = hybrid_local_search(base_solution)\n\n    # Ensure solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{A novel hybrid local search operator that combines a randomized edge-swapping strategy with a distance-based neighborhood exploration to generate high-quality neighbors by intelligently selecting segments of the tour for modification while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select the solution with the lowest combined objective value\n        archive.sort(key=lambda x: sum(x[1]))\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour to modify\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n // 2))\n    segment_end = (segment_start + segment_length) % n\n\n    # Extract the segment\n    if segment_start < segment_end:\n        segment = new_solution[segment_start:segment_end]\n    else:\n        segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n\n    # Reverse the segment to create a neighbor\n    reversed_segment = segment[::-1]\n\n    # Replace the segment in the solution\n    if segment_start < segment_end:\n        new_solution[segment_start:segment_end] = reversed_segment\n    else:\n        new_solution[segment_start:] = reversed_segment[:n - segment_start]\n        new_solution[:segment_end] = reversed_segment[n - segment_start:]\n\n    return new_solution\n\n",
        "score": [
            -0.6072421604574554,
            0.4527716636657715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select the solution with the lowest combined objective value\n        archive.sort(key=lambda x: sum(x[1]))\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour to modify\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n // 2))\n    segment_end = (segment_start + segment_length) % n\n\n    # Extract the segment\n    if segment_start < segment_end:\n        segment = new_solution[segment_start:segment_end]\n    else:\n        segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n\n    # Reverse the segment to create a neighbor\n    reversed_segment = segment[::-1]\n\n    # Replace the segment in the solution\n    if segment_start < segment_end:\n        new_solution[segment_start:segment_end] = reversed_segment\n    else:\n        new_solution[segment_start:] = reversed_segment[:n - segment_start]\n        new_solution[:segment_end] = reversed_segment[n - segment_start:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective edge exchange with a biased random walk to explore high-potential regions in the solution space, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.random.rand()))[0].copy()\n\n    # Hybrid local search: Multi-objective edge exchange with biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective edge exchange (select edges that improve both objectives)\n    for i in range(n):\n        for j in range(i + 1, n):\n            a, b = new_solution[i], new_solution[j]\n            # Check if swapping edges a-b and a-c improves both objectives\n            if j + 1 < n:\n                c = new_solution[j + 1]\n                delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, a]) - (distance_matrix_1[a, c] + distance_matrix_1[b, a])\n                delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, a]) - (distance_matrix_2[a, c] + distance_matrix_2[b, a])\n                if delta1 < 0 and delta2 < 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Biased random walk (explore with probability based on objective improvement)\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = new_solution[i], new_solution[j]\n        delta1 = (distance_matrix_1[new_solution[i-1], a] + distance_matrix_1[a, new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], b] + distance_matrix_1[b, new_solution[(i+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], a] + distance_matrix_2[a, new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], b] + distance_matrix_2[b, new_solution[(i+1)%n]])\n        if (delta1 < 0 and delta2 < 0) or np.random.rand() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7527265839439654,
            3.438077747821808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.random.rand()))[0].copy()\n\n    # Hybrid local search: Multi-objective edge exchange with biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective edge exchange (select edges that improve both objectives)\n    for i in range(n):\n        for j in range(i + 1, n):\n            a, b = new_solution[i], new_solution[j]\n            # Check if swapping edges a-b and a-c improves both objectives\n            if j + 1 < n:\n                c = new_solution[j + 1]\n                delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, a]) - (distance_matrix_1[a, c] + distance_matrix_1[b, a])\n                delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, a]) - (distance_matrix_2[a, c] + distance_matrix_2[b, a])\n                if delta1 < 0 and delta2 < 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Biased random walk (explore with probability based on objective improvement)\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = new_solution[i], new_solution[j]\n        delta1 = (distance_matrix_1[new_solution[i-1], a] + distance_matrix_1[a, new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], b] + distance_matrix_1[b, new_solution[(i+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], a] + distance_matrix_2[a, new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], b] + distance_matrix_2[b, new_solution[(i+1)%n]])\n        if (delta1 < 0 and delta2 < 0) or np.random.rand() < 0.3:  # Allow some non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.mean(normalized_obj, axis=1)\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to exchange\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.828007387391128,
            0.47494643926620483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.mean(normalized_obj, axis=1)\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to exchange\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search that combines edge swaps and node reinsertions to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swap + node reinsertion\n    if n > 3:\n        # Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node reinsertion\n        k = np.random.choice(n)\n        removed_node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Ensure the solution is a valid tour\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8214777418333757,
            0.495012104511261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swap + node reinsertion\n    if n > 3:\n        # Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node reinsertion\n        k = np.random.choice(n)\n        removed_node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Ensure the solution is a valid tour\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge insertion: insert a randomly selected node in a new position\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = random.randint(0, n-1)\n    if current_pos != new_pos:\n        new_solution = np.roll(new_solution, -current_pos)\n        new_solution = np.roll(new_solution, new_pos)\n        new_solution = np.roll(new_solution, current_pos)\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the move is invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9623562909244205,
            0.505473256111145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge insertion: insert a randomly selected node in a new position\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = random.randint(0, n-1)\n    if current_pos != new_pos:\n        new_solution = np.roll(new_solution, -current_pos)\n        new_solution = np.roll(new_solution, new_pos)\n        new_solution = np.roll(new_solution, current_pos)\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the move is invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A hybrid local search strategy combining adaptive edge swapping with a novel node insertion heuristic, prioritizing high-potential edges and dynamically adjusting search depth based on solution quality and diversity in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    N = len(selected_solution)\n\n    # Hybrid local search: adaptive edge swapping + novel node insertion\n    new_solution = selected_solution.copy()\n\n    # Adaptive edge swapping (focus on high-potential edges)\n    for _ in range(min(5, N // 2)):\n        i = random.randint(0, N-1)\n        j = random.randint(0, N-1)\n        if i != j and i != (j+1)%N and j != (i+1)%N:\n            # Calculate improvement potential\n            old_dist = (distance_matrix_1[selected_solution[i], selected_solution[(i+1)%N]] +\n                        distance_matrix_1[selected_solution[j], selected_solution[(j+1)%N]] +\n                        distance_matrix_2[selected_solution[i], selected_solution[(i+1)%N]] +\n                        distance_matrix_2[selected_solution[j], selected_solution[(j+1)%N]])\n            new_dist = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                       distance_matrix_1[selected_solution[(i+1)%N], selected_solution[(j+1)%N]] +\n                       distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                       distance_matrix_2[selected_solution[(i+1)%N], selected_solution[(j+1)%N]])\n            if new_dist < old_dist:\n                # Perform swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Novel node insertion heuristic (focus on critical nodes)\n    for _ in range(min(3, N // 3)):\n        # Select a node with high degree or long edges\n        candidates = []\n        for i in range(N):\n            node = selected_solution[i]\n            prev_node = selected_solution[i-1]\n            next_node = selected_solution[(i+1)%N]\n            degree = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                     distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            candidates.append((degree, i))\n        candidates.sort(reverse=True, key=lambda x: x[0])\n        selected_index = candidates[0][1]\n\n        # Try to reinsert the node in a better position\n        node = new_solution[selected_index]\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(N):\n            if pos == selected_index or pos == (selected_index-1)%N or pos == (selected_index+1)%N:\n                continue\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[selected_index-1], node] +\n                        distance_matrix_1[node, new_solution[(selected_index+1)%N]] +\n                        distance_matrix_2[new_solution[selected_index-1], node] +\n                        distance_matrix_2[node, new_solution[(selected_index+1)%N]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                       distance_matrix_1[node, new_solution[pos]] +\n                       distance_matrix_2[new_solution[pos-1], node] +\n                       distance_matrix_2[node, new_solution[pos]])\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            # Perform insertion\n            node = new_solution[selected_index]\n            new_solution = np.delete(new_solution, selected_index)\n            if selected_index > best_pos:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.48833783773170214,
            1.33619886636734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    N = len(selected_solution)\n\n    # Hybrid local search: adaptive edge swapping + novel node insertion\n    new_solution = selected_solution.copy()\n\n    # Adaptive edge swapping (focus on high-potential edges)\n    for _ in range(min(5, N // 2)):\n        i = random.randint(0, N-1)\n        j = random.randint(0, N-1)\n        if i != j and i != (j+1)%N and j != (i+1)%N:\n            # Calculate improvement potential\n            old_dist = (distance_matrix_1[selected_solution[i], selected_solution[(i+1)%N]] +\n                        distance_matrix_1[selected_solution[j], selected_solution[(j+1)%N]] +\n                        distance_matrix_2[selected_solution[i], selected_solution[(i+1)%N]] +\n                        distance_matrix_2[selected_solution[j], selected_solution[(j+1)%N]])\n            new_dist = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                       distance_matrix_1[selected_solution[(i+1)%N], selected_solution[(j+1)%N]] +\n                       distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                       distance_matrix_2[selected_solution[(i+1)%N], selected_solution[(j+1)%N]])\n            if new_dist < old_dist:\n                # Perform swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Novel node insertion heuristic (focus on critical nodes)\n    for _ in range(min(3, N // 3)):\n        # Select a node with high degree or long edges\n        candidates = []\n        for i in range(N):\n            node = selected_solution[i]\n            prev_node = selected_solution[i-1]\n            next_node = selected_solution[(i+1)%N]\n            degree = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                     distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            candidates.append((degree, i))\n        candidates.sort(reverse=True, key=lambda x: x[0])\n        selected_index = candidates[0][1]\n\n        # Try to reinsert the node in a better position\n        node = new_solution[selected_index]\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(N):\n            if pos == selected_index or pos == (selected_index-1)%N or pos == (selected_index+1)%N:\n                continue\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[selected_index-1], node] +\n                        distance_matrix_1[node, new_solution[(selected_index+1)%N]] +\n                        distance_matrix_2[new_solution[selected_index-1], node] +\n                        distance_matrix_2[node, new_solution[(selected_index+1)%N]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                       distance_matrix_1[node, new_solution[pos]] +\n                       distance_matrix_2[new_solution[pos-1], node] +\n                       distance_matrix_2[node, new_solution[pos]])\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            # Perform insertion\n            node = new_solution[selected_index]\n            new_solution = np.delete(new_solution, selected_index)\n            if selected_index > best_pos:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest combined normalized objective values, then applies a hybrid local search combining a novel segment inversion with a probabilistic 3-opt-like move to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with higher combined normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    combined_obj = np.sum(normalized_obj, axis=1)\n    probabilities = combined_obj / np.sum(combined_obj)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment inversion + probabilistic 3-opt-like move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic 3-opt-like move\n    if n > 4 and random.random() < 0.5:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move (reverse one of the three segments)\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.903524413629082,
            0.5798090696334839
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with higher combined normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    combined_obj = np.sum(normalized_obj, axis=1)\n    probabilities = combined_obj / np.sum(combined_obj)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment inversion + probabilistic 3-opt-like move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Probabilistic 3-opt-like move\n    if n > 4 and random.random() < 0.5:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move (reverse one of the three segments)\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This heuristic function selects a solution from the archive based on the sum of normalized objective values, then applies a hybrid local search combining 3-opt with a novel edge-swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple attempts\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i == j or j == k or i == k:\n            continue\n\n        # Try 3-opt move\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = np.flip(temp_solution[i:j+1])\n        temp_solution[j:k+1] = np.flip(temp_solution[j:k+1])\n\n        # Check feasibility and improvement\n        if np.all(np.unique(temp_solution) == np.arange(n)):\n            new_solution = temp_solution\n            break\n\n        # Try edge-swap if 3-opt didn't work\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        if np.all(np.unique(temp_solution) == np.arange(n)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7796862123820721,
            0.5152087807655334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple attempts\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if i == j or j == k or i == k:\n            continue\n\n        # Try 3-opt move\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = np.flip(temp_solution[i:j+1])\n        temp_solution[j:k+1] = np.flip(temp_solution[j:k+1])\n\n        # Check feasibility and improvement\n        if np.all(np.unique(temp_solution) == np.arange(n)):\n            new_solution = temp_solution\n            break\n\n        # Try edge-swap if 3-opt didn't work\n        temp_solution = new_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        if np.all(np.unique(temp_solution) == np.arange(n)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A novel hybrid local search operator that combines adaptive segment relinking with a multi-objective-aware edge insertion heuristic to intelligently explore the solution space while maintaining feasibility, focusing on high-potential solutions from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly pick from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment relinking + edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment relinking\n    segment_length = max(3, n // 5)  # Adaptive segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract and reverse a segment\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # Step 2: Multi-objective-aware edge insertion\n    for _ in range(3):  # Perform 3 random edge insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate insertion cost in both objectives\n        a, b = new_solution[i], new_solution[j]\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[(i-1)%n], a] - distance_matrix_1[a, new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[a, b] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[(i-1)%n], a] - distance_matrix_2[a, new_solution[(i+1)%n]]\n\n        # Accept if insertion improves at least one objective\n        if cost1 < 0 or cost2 < 0:\n            # Perform the insertion\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.47129434806878634,
            0.6013789772987366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly pick from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: Adaptive segment relinking + edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment relinking\n    segment_length = max(3, n // 5)  # Adaptive segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract and reverse a segment\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # Step 2: Multi-objective-aware edge insertion\n    for _ in range(3):  # Perform 3 random edge insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate insertion cost in both objectives\n        a, b = new_solution[i], new_solution[j]\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[(i-1)%n], a] - distance_matrix_1[a, new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[a, b] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[(i-1)%n], a] - distance_matrix_2[a, new_solution[(i+1)%n]]\n\n        # Accept if insertion improves at least one objective\n        if cost1 < 0 or cost2 < 0:\n            # Perform the insertion\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search approach that combines a randomized segment reversal with a cross-space edge insertion heuristic to explore diverse neighborhoods while maintaining feasibility, balancing exploration of both objective spaces through adaptive segment selection and insertion criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    # Determine which objective space to prioritize for improvement\n    if objectives[0] > objectives[1]:\n        distance_matrix = distance_matrix_1\n    else:\n        distance_matrix = distance_matrix_2\n\n    # Hybrid local search: segment reversal with cross-space edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    start = random.randint(0, n-1)\n    end = random.randint(start, min(start + n//3, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Cross-space edge insertion: try to insert an edge from the other space\n    if random.random() < 0.5:  # 50% chance to apply this operator\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Find the best insertion point in the other space\n            best_cost = float('inf')\n            best_pos = -1\n            for pos in range(n):\n                if pos != i and pos != i+1:\n                    # Calculate cost of inserting node i after pos\n                    cost = (distance_matrix[new_solution[pos], new_solution[i]] +\n                           distance_matrix[new_solution[i], new_solution[(pos+1)%n]] -\n                           distance_matrix[new_solution[pos], new_solution[(pos+1)%n]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            if best_pos != -1:\n                # Perform the insertion if it improves the tour\n                if best_cost < 0:\n                    # Remove node i from its current position\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                    # Insert node i after best_pos\n                    new_solution = np.concatenate([new_solution[:best_pos+1], [base_solution[i]], new_solution[best_pos+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8989421826954498,
            0.5332514047622681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    # Determine which objective space to prioritize for improvement\n    if objectives[0] > objectives[1]:\n        distance_matrix = distance_matrix_1\n    else:\n        distance_matrix = distance_matrix_2\n\n    # Hybrid local search: segment reversal with cross-space edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    start = random.randint(0, n-1)\n    end = random.randint(start, min(start + n//3, n-1))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Cross-space edge insertion: try to insert an edge from the other space\n    if random.random() < 0.5:  # 50% chance to apply this operator\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Find the best insertion point in the other space\n            best_cost = float('inf')\n            best_pos = -1\n            for pos in range(n):\n                if pos != i and pos != i+1:\n                    # Calculate cost of inserting node i after pos\n                    cost = (distance_matrix[new_solution[pos], new_solution[i]] +\n                           distance_matrix[new_solution[i], new_solution[(pos+1)%n]] -\n                           distance_matrix[new_solution[pos], new_solution[(pos+1)%n]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n            if best_pos != -1:\n                # Perform the insertion if it improves the tour\n                if best_cost < 0:\n                    # Remove node i from its current position\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                    # Insert node i after best_pos\n                    new_solution = np.concatenate([new_solution[:best_pos+1], [base_solution[i]], new_solution[best_pos+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search operator named \"Multi-Objective Edge Swap and Reinsertion\" (MOESR) intelligently selects a solution from the archive, then applies a combination of edge swaps and reinsertions guided by Pareto dominance and objective-space diversity to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Identify critical segments for local search\n    n = len(base_solution)\n    segment_size = max(3, n // 10)\n    start = random.randint(0, n - segment_size)\n    segment = base_solution[start:start + segment_size]\n\n    # Apply hybrid local search: edge swap and reinsertion\n    new_solution = base_solution.copy()\n\n    # Edge swap within the segment\n    if len(segment) >= 2:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        global_pos1 = start + swap_pos1\n        global_pos2 = start + swap_pos2\n        new_solution[global_pos1], new_solution[global_pos2] = new_solution[global_pos2], new_solution[global_pos1]\n\n    # Reinsertion of a random node to a new position\n    if n > 3:\n        node_to_move = random.choice(segment)\n        new_pos = random.randint(0, n - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reinsertion causes issues\n        new_solution = base_solution.copy()\n        swap_pos1, swap_pos2 = random.sample(range(n), 2)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.778420426354532,
            0.45700782537460327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Identify critical segments for local search\n    n = len(base_solution)\n    segment_size = max(3, n // 10)\n    start = random.randint(0, n - segment_size)\n    segment = base_solution[start:start + segment_size]\n\n    # Apply hybrid local search: edge swap and reinsertion\n    new_solution = base_solution.copy()\n\n    # Edge swap within the segment\n    if len(segment) >= 2:\n        swap_pos1, swap_pos2 = random.sample(range(len(segment)), 2)\n        global_pos1 = start + swap_pos1\n        global_pos2 = start + swap_pos2\n        new_solution[global_pos1], new_solution[global_pos2] = new_solution[global_pos2], new_solution[global_pos1]\n\n    # Reinsertion of a random node to a new position\n    if n > 3:\n        node_to_move = random.choice(segment)\n        new_pos = random.randint(0, n - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reinsertion causes issues\n        new_solution = base_solution.copy()\n        swap_pos1, swap_pos2 = random.sample(range(n), 2)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{A novel hybrid local search algorithm that combines a probabilistic edge selection mechanism with a guided 3-opt move to explore diverse neighborhoods while balancing the two objectives, ensuring feasibility by dynamically adjusting edge swaps based on both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-10)  # Prefer solutions with lower combined cost\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: guided 3-opt with edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Determine the best 3-opt move based on both distance matrices\n    # Consider all 8 possible 3-opt configurations\n    best_improvement = 0\n    best_config = None\n\n    # Original edges\n    a, b, c = new_solution[i], new_solution[j], new_solution[k]\n    original_cost = (distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_1[c, a] +\n                     distance_matrix_2[a, b] + distance_matrix_2[b, c] + distance_matrix_2[c, a])\n\n    # Generate all 8 possible 3-opt configurations\n    for configuration in [\n        (i, j, k), (i, k, j),\n        (j, i, k), (j, k, i),\n        (k, i, j), (k, j, i),\n        (i, j, k), (i, k, j)  # Duplicates are intentional to cover all cases\n    ]:\n        x, y, z = configuration\n        if x == y or y == z or z == x:\n            continue\n\n        # Create new solution with this configuration\n        temp_solution = new_solution.copy()\n        temp_solution[x], temp_solution[y], temp_solution[z] = new_solution[z], new_solution[y], new_solution[x]\n\n        # Calculate new cost\n        a1, b1, c1 = temp_solution[x], temp_solution[y], temp_solution[z]\n        new_cost = (distance_matrix_1[a1, b1] + distance_matrix_1[b1, c1] + distance_matrix_1[c1, a1] +\n                    distance_matrix_2[a1, b1] + distance_matrix_2[b1, c1] + distance_matrix_2[c1, a1])\n\n        improvement = original_cost - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_config = (x, y, z)\n\n    if best_config is not None:\n        x, y, z = best_config\n        new_solution[x], new_solution[y], new_solution[z] = new_solution[z], new_solution[y], new_solution[x]\n\n    return new_solution\n\n",
        "score": [
            -0.7995577156106635,
            0.6235561966896057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-10)  # Prefer solutions with lower combined cost\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: guided 3-opt with edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Determine the best 3-opt move based on both distance matrices\n    # Consider all 8 possible 3-opt configurations\n    best_improvement = 0\n    best_config = None\n\n    # Original edges\n    a, b, c = new_solution[i], new_solution[j], new_solution[k]\n    original_cost = (distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_1[c, a] +\n                     distance_matrix_2[a, b] + distance_matrix_2[b, c] + distance_matrix_2[c, a])\n\n    # Generate all 8 possible 3-opt configurations\n    for configuration in [\n        (i, j, k), (i, k, j),\n        (j, i, k), (j, k, i),\n        (k, i, j), (k, j, i),\n        (i, j, k), (i, k, j)  # Duplicates are intentional to cover all cases\n    ]:\n        x, y, z = configuration\n        if x == y or y == z or z == x:\n            continue\n\n        # Create new solution with this configuration\n        temp_solution = new_solution.copy()\n        temp_solution[x], temp_solution[y], temp_solution[z] = new_solution[z], new_solution[y], new_solution[x]\n\n        # Calculate new cost\n        a1, b1, c1 = temp_solution[x], temp_solution[y], temp_solution[z]\n        new_cost = (distance_matrix_1[a1, b1] + distance_matrix_1[b1, c1] + distance_matrix_1[c1, a1] +\n                    distance_matrix_2[a1, b1] + distance_matrix_2[b1, c1] + distance_matrix_2[c1, a1])\n\n        improvement = original_cost - new_cost\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_config = (x, y, z)\n\n    if best_config is not None:\n        x, y, z = best_config\n        new_solution[x], new_solution[y], new_solution[z] = new_solution[z], new_solution[y], new_solution[x]\n\n    return new_solution\n\n"
    }
]