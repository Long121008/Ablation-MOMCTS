[
    {
        "algorithm": "{A novel hybrid local search operator combines a multi-criteria selection of promising solutions from the archive, followed by a dynamic edge-swap strategy that balances improvements in both objective spaces while ensuring feasibility through a feasibility-preserving edge-swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge-swap with feasibility check\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure the swap is feasible (no duplicates or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (optional, but ensures correctness)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8762176715657244,
            0.7538501620292664
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic segment inversion strategy, guided by a weighted combination of the two objectives, to explore the solution space while maintaining feasibility and promoting high-quality improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8359818864743235,
            0.6165406107902527
        ]
    }
]