[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal operator\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal with a probability of 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a random feasible solution if invalid\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9207241637015102,
            0.6840910911560059
        ]
    },
    {
        "algorithm": "{A novel heuristic selects a solution from the archive based on objective diversity and applies a hybrid local search combining edge insertion with a biased random walk to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity * (objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk with edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limited iterations for efficiency\n        # Select a random segment to modify\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, min(start + 5, n))\n\n        # Extract and reverse the segment (with probability 0.5)\n        if np.random.rand() < 0.5:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n        # Insert a random node elsewhere\n        node_to_move = new_solution[start]\n        new_solution = np.roll(new_solution, -start)\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8894929445747322,
            0.3893139958381653
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines edge exchange with a guided segment relocation strategy to intelligently explore the solution space while ensuring feasibility, prioritizing solutions with promising objective trade-offs for further improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment relocation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Edge exchange between i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a segment between k and i to after j\n    if k < i and j < n - 1:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j+1], segment, new_solution[j+1:]])\n\n    # Ensure validity (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8806722851689966,
            0.42970335483551025
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a multi-criteria selection of promising solutions from the archive, followed by a dynamic edge-swap strategy that balances improvements in both objective spaces while ensuring feasibility through a feasibility-preserving edge-swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic edge-swap with feasibility check\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Ensure the swap is feasible (no duplicates or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (optional, but ensures correctness)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8762176715657244,
            0.7538501620292664
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic segment inversion strategy, guided by a weighted combination of the two objectives, to explore the solution space while maintaining feasibility and promoting high-quality improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Dynamic segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = random.randint(0, n - 2)\n    seg_length = random.randint(2, min(10, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Invert the selected segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Biased random walk: swap nodes based on weighted distance\n    for _ in range(5):  # Number of swaps\n        i, j = random.sample(range(n), 2)\n        # Calculate weighted gain\n        gain1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i-1], base_solution[i]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        gain2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] - distance_matrix_2[base_solution[i-1], base_solution[i]] - distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        weighted_gain = gain1 + gain2\n\n        if weighted_gain < 0 or random.random() < 0.3:  # Accept if improvement or with some probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8359818864743235,
            0.6165406107902527
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective dominance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    weights = np.sum(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swapping and segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Edge swapping: randomly select two edges and swap their positions\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment inversion: randomly select a segment and reverse it\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: if invalid, perform a simple 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7936356089132802,
            0.7914842963218689
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive based on dominance and diversity, then applies a novel hybrid local search combining edge-swapping and segment inversion to efficiently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by dominance (Pareto front) and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))  # Select from top 30% solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping for both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment inversion based on objective differences\n    if np.random.rand() < 0.5:  # 50% chance to apply segment inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert if it improves at least one objective\n        if cost1 > 0 or cost2 > 0:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7701032656864056,
            0.4679875373840332
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment relocation with multi-objective edge swapping to intelligently explore the solution space while balancing both objectives, ensuring feasibility through constraint-aware perturbation and guided selection of promising regions in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1+i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment relocation with multi-objective edge swapping\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n//2))  # Random segment length\n    start = random.randint(0, n - segment_length)     # Random start position\n    end = start + segment_length\n\n    # Relocate segment to a new position\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Multi-objective edge swapping\n    for _ in range(3):  # Perform a few swaps\n        i, j = random.sample(range(n), 2)\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.1:  # Allow some non-improving swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7450545479002306,
            0.7508071064949036
        ]
    },
    {
        "algorithm": "{A hybrid local search heuristic that intelligently selects a solution from the archive based on non-dominated solutions and their potential for improvement, then applies a customized edge-swap and node-reinsertion hybrid operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., high cost or diversity)\n        base_solution = max(non_dominated, key=lambda sol: np.sum(distance_matrix_1[sol[:-1], sol[1:]]) + np.sum(distance_matrix_2[sol[:-1], sol[1:]])).copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid operator: Edge-swap followed by node reinsertion\n    # Edge-swap: Select two non-adjacent edges and swap their endpoints\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    if new_solution[a] == new_solution[c] or new_solution[b] == new_solution[d]:\n        return new_solution  # Avoid invalid swap\n\n    # Perform edge-swap\n    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Node reinsertion: Remove a node and reinsert it at a better position\n    node_to_remove = random.choice(new_solution[1:-1])\n    idx = np.where(new_solution == node_to_remove)[0][0]\n    new_solution = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n    # Find the best insertion position for the removed node\n    best_cost = float('inf')\n    best_pos = 0\n    for i in range(1, len(new_solution)):\n        # Insert node_to_remove between new_solution[i-1] and new_solution[i]\n        cost = (distance_matrix_1[new_solution[i-1], node_to_remove] + distance_matrix_1[node_to_remove, new_solution[i]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n               (distance_matrix_2[new_solution[i-1], node_to_remove] + distance_matrix_2[node_to_remove, new_solution[i]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]])\n        if cost < best_cost:\n            best_cost = cost\n            best_pos = i\n\n    new_solution = np.insert(new_solution, best_pos, node_to_remove)\n\n    return new_solution\n\n",
        "score": [
            -0.7282095870887813,
            0.8123635649681091
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and crowding distance, then applies a novel 3-opt* local search operator that combines edge swaps with path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and crowding distance\n    selected_idx = 0\n    min_dominance = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        dominance = sum(obj)\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt* local search with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Create a new path by rearranging segments\n    new_path = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k][::-1],\n        new_solution[i:j],\n        new_solution[k:]\n    ])\n\n    # Ensure the path is a valid tour\n    if len(np.unique(new_path)) == n:\n        new_solution = new_path\n\n    return new_solution\n\n",
        "score": [
            -0.6933243741420154,
            0.4461817741394043
        ]
    }
]