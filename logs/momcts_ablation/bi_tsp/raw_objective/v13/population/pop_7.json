[
    {
        "algorithm": "The algorithm selects the solution with the lowest combined cost from the archive, then applies a hybrid local search combining segment reversal and edge swaps to generate a new neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses novel segment reversal to explore the solution space beyond standard edge swaps. The selection and operators ensure valid tours by maintaining node uniqueness and completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a random edge swap (standard operator)\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9453093012944958,
            0.1820637583732605
        ],
        "raw_score": [
            6.180186675512935,
            6.63654462139858
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (favoring lower-cost solutions but allowing some diversity) and applies a cross-segment swap operator, randomly exchanging two non-overlapping segments of the tour to generate a neighbor solution while ensuring feasibility. The selection prioritizes exploitation of good solutions but balances it with exploration by occasionally choosing from the middle of the archive. The cross-segment swap is a novel local search operator that disrupts larger tour structures compared to standard edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_threshold = min(2 * len(sorted_archive) // 3, len(sorted_archive) - 1)\n    selected_solution = random.choice(sorted_archive[:selection_threshold])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-segment swap: select two non-overlapping segments and swap them\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.837455409186324,
            0.1816069483757019
        ],
        "raw_score": [
            6.500691332763455,
            6.600301261577352
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a random solution from the archive, applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor, and ensures feasibility by checking for duplicates. The algorithm prioritizes diversity and non-dominance implicitly by random selection, while the local search explores the solution space creatively by reversing segments and reinserting edges at random positions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_end = (edge_start + 1) % n\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[edge_end]\n\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:edge_start], new_solution[edge_end+1:]])\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node1)\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node2)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8700755886195684,
            0.21495270729064941
        ],
        "raw_score": [
            7.227454476992637,
            6.950987236943185
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the lowest combined cost (sum of both objectives), then applies a hybrid local search combining segment reversal and a novel node insertion to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses random segment reversal and node insertion to explore the search space, maintaining validity by checking for duplicate nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine segment reversal with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a novel node insertion (insert a node from a random position to another)\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8447560499453636,
            0.19697046279907227
        ],
        "raw_score": [
            6.450616079700156,
            6.332469275271153
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top third of the archive (sorted by combined objective cost), then applies a hybrid local search: either randomly reinserting an edge or reversing a segment of the tour, ensuring feasibility by maintaining a valid TSP path. The selection prioritizes solutions with lower total cost, while the local search explores diverse neighborhood structures to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: randomly choose between edge insertion or segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7593220728994624,
            0.19668710231781006
        ],
        "raw_score": [
            5.831905830795691,
            5.995319237568243
        ]
    },
    {
        "algorithm": "The algorithm implements an adaptive probabilistic selection strategy that prioritizes top solutions (top 3-5) with weighted probabilities (e.g., 0.7, 0.2, 0.1) and applies a hybrid local search operator (segment reversal + cross-segment swaps) with dynamic disruption rates (0.2 or 0.4) to explore neighborhoods while ensuring feasibility through permutation validation. It balances exploitation (focusing on high-potential solutions) and exploration (controlled disruption) to navigate the bi-objective TSP solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Probabilistic selection from top-k solutions\n    k = min(5, len(archive))\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = sorted_archive[:k]\n    weights = [0.7, 0.2, 0.1] * (k // 3) + [0.05] * (k % 3)\n    selected = random.choices(top_k, weights=weights, k=1)[0][0].copy()\n\n    # Step 2: Apply constrained hybrid operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n    disruption_rate = 0.2 if len(set([sum(obj) for _, obj in archive])) > 1 else 0.4\n\n    if random.random() < disruption_rate:\n        # Hybrid operator: small segment reversal + cross-segment swap\n        if n >= 4:\n            # Small segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i <= 3:  # Limit disruption\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Cross-segment swap (constrained)\n            if n >= 6:\n                a, b, c, d = sorted(random.sample(range(n), 4))\n                if abs(b-a) == abs(d-c):  # Similar-length segments\n                    new_solution[a:b], new_solution[c:d] = new_solution[c:d], new_solution[a:b]\n    else:\n        # Standard edge swap\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Validate feasibility\n    if len(set(new_solution)) != len(selected):\n        return selected  # Revert if invalid\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8487701870973046,
            0.3124351501464844
        ],
        "raw_score": [
            6.8559313228961685,
            6.147794882567918
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the top 20% of the archive (sorted by normalized objective sums) and applies a hybrid local search, randomly choosing between edge swaps (60% probability) and a novel node insertion strategy (40% probability) to generate feasible neighbor solutions. Edge swaps exchange two random edges, while node insertion removes a node and reinserts it at a random position, ensuring tour validity. The selection prioritizes solutions with better combined normalized objectives, while the local search diversifies exploration to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        normalized_archive = archive\n    else:\n        normalized_archive = [(sol, (obj[0]/max_obj1, obj[1]/max_obj2)) for sol, obj in archive]\n    sorted_archive = sorted(normalized_archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge swap or novel node insertion\n    if random.random() < 0.6:\n        # Edge swap: swap two random edges\n        i = random.randint(0, n - 2)\n        j = random.randint(0, n - 2)\n        if i != j:\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n    else:\n        # Novel node insertion: remove a node and insert it in a different position\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.819648273754423,
            0.22441494464874268
        ],
        "raw_score": [
            6.13544825475205,
            6.491666412397946
        ]
    },
    {
        "algorithm": "The algorithm combines intelligent solution selection (favoring lower-cost solutions) with a novel probabilistic segment merge-and-split operator, ensuring feasibility and accepting only high-quality neighbors based on improvement thresholds in both objectives. It prioritizes exploration by randomly selecting segments and splitting them probabilistically, while maintaining feasibility checks and a strict improvement criterion for acceptance. The key variables are the improvement threshold (0.9) and segment selection bounds, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_threshold = min(2 * len(sorted_archive) // 3, len(sorted_archive) - 1)\n    selected_solution, selected_objective = random.choice(sorted_archive[:selection_threshold])\n    base_solution = selected_solution.copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment merge and split\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Merge segments\n    merged_segment = np.concatenate([new_solution[seg1_start:seg1_end+1], new_solution[seg2_start:seg2_end+1]])\n\n    # Split merged segment probabilistically\n    split_pos = random.randint(1, len(merged_segment) - 1)\n    new_seg1 = merged_segment[:split_pos]\n    new_seg2 = merged_segment[split_pos:]\n\n    # Create new solution by replacing merged segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        new_seg1,\n        new_solution[seg1_end+1:seg2_start],\n        new_seg2,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    # Probabilistic acceptance based on improvement\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    improvement_threshold = 0.9  # Accept if at least 90% improvement in both objectives\n    if (new_cost1 < original_cost1 * improvement_threshold and new_cost2 < original_cost2 * improvement_threshold):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "metric_score": [
            -0.8384279086459632,
            3.055922269821167
        ],
        "raw_score": [
            8.963055667998646,
            9.055821841167996
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing low-cost solutions and applies a hybrid local search combining segment reversal (randomly reversing a tour segment) and objective-aware edge swapping (swapping edges while ensuring at least one objective improves, reverting if both worsen significantly). The selection favors solutions with better combined objective values, and the local search balances exploration (segment reversal) and exploitation (edge swapping) to improve the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low cost and high diversity)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(1, len(sorted_archive) // 3)])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment reversal with objective-aware edge swapping\n    if random.random() < 0.5:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware edge swapping: swap edges that improve at least one objective\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a != b:\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            old_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            # Swap the edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            new_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            new_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            # Revert if both objectives worsen significantly\n            if (new_cost1 > old_cost1 and new_cost2 > old_cost2) and (new_cost1 > 1.1 * old_cost1 or new_cost2 > 1.1 * old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8149456813807384,
            0.3695242404937744
        ],
        "raw_score": [
            6.2928063882478416,
            5.604687846887915
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies either segment reversal (for the first objective) or edge insertion (for the second objective) to generate a neighbor solution, ensuring feasibility through validation. The operator selection dynamically adapts based on the relative improvement potential in each objective space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement in either objective\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement in each objective\n    obj1_potential = [obj[0] for obj in objectives]\n    obj2_potential = [obj[1] for obj in objectives]\n\n    # Select solution with best combined potential, but prioritize those with better potential in either objective\n    selected_idx = np.argmin([obj1 + obj2 for obj1, obj2 in zip(obj1_potential, obj2_potential)])\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware operator selection\n    obj1_improvement = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2_improvement = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    if obj1_improvement > obj2_improvement:\n        # If first objective is more critical, perform segment reversal\n        if n > 3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # If second objective is more critical, perform edge insertion\n        if n > 1:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate the solution remains feasible\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7907152681481812,
            0.2283899188041687
        ],
        "raw_score": [
            6.1732988613524,
            5.747055024875619
        ]
    }
]