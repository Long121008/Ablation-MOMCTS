[
    {
        "algorithm": "The algorithm selects the solution with the lowest combined cost from the archive, then applies a hybrid local search combining segment reversal and edge swaps to generate a new neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses novel segment reversal to explore the solution space beyond standard edge swaps. The selection and operators ensure valid tours by maintaining node uniqueness and completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a random edge swap (standard operator)\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9453093012944958,
            0.1820637583732605
        ],
        "raw_score": [
            6.180186675512935,
            6.63654462139858
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (favoring lower-cost solutions but allowing some diversity) and applies a cross-segment swap operator, randomly exchanging two non-overlapping segments of the tour to generate a neighbor solution while ensuring feasibility. The selection prioritizes exploitation of good solutions but balances it with exploration by occasionally choosing from the middle of the archive. The cross-segment swap is a novel local search operator that disrupts larger tour structures compared to standard edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_threshold = min(2 * len(sorted_archive) // 3, len(sorted_archive) - 1)\n    selected_solution = random.choice(sorted_archive[:selection_threshold])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-segment swap: select two non-overlapping segments and swap them\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.837455409186324,
            0.1816069483757019
        ],
        "raw_score": [
            6.500691332763455,
            6.600301261577352
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a random solution from the archive, applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor, and ensures feasibility by checking for duplicates. The algorithm prioritizes diversity and non-dominance implicitly by random selection, while the local search explores the solution space creatively by reversing segments and reinserting edges at random positions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    edge_start = np.random.randint(0, n - 1)\n    edge_end = (edge_start + 1) % n\n    edge_node1 = new_solution[edge_start]\n    edge_node2 = new_solution[edge_end]\n\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:edge_start], new_solution[edge_end+1:]])\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node1)\n    new_solution = np.insert(new_solution, np.random.randint(0, len(new_solution)), edge_node2)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8700755886195684,
            0.21495270729064941
        ],
        "raw_score": [
            7.227454476992637,
            6.950987236943185
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the lowest combined cost (sum of both objectives), then applies a hybrid local search combining segment reversal and a novel node insertion to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses random segment reversal and node insertion to explore the search space, maintaining validity by checking for duplicate nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine segment reversal with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a novel node insertion (insert a node from a random position to another)\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8447560499453636,
            0.19697046279907227
        ],
        "raw_score": [
            6.450616079700156,
            6.332469275271153
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [np.mean([np.linalg.norm(sol - other) for other in solutions]) for sol in solutions]\n    selection_scores = [obj[0] * 0.5 + obj[1] * 0.3 + div * 0.2 for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with controlled disruption\n    if n > 3:\n        k = random.randint(1, min(3, n//2))  # Limit rotation to small segments\n        new_solution = np.roll(new_solution, k)\n\n    # Edge insertion with feasibility check\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (i + j) // 2 if i < j else (i + j + 1) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Validate feasibility\n    if len(set(new_solution)) != len(new_solution):\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9092558547377287,
            2.49730521440506
        ],
        "raw_score": [
            5.720869650024556,
            7.851523467482659
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive using a Pareto-dominance-inspired score (prioritizing less-dominated solutions) combined with diversity (to avoid local optima), then applies a hybrid local search that reverses segments and swaps nodes to generate a feasible neighbor solution. The selection balances dominance (70%) and diversity (30%), while the local search ensures feasibility by maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto-dominance inspired selection\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores\n    dominance_scores = []\n    for i, obj1 in enumerate(objectives):\n        dominated_count = 0\n        for j, obj2 in enumerate(objectives):\n            if i != j and (obj1[0] >= obj2[0] and obj1[1] >= obj2[1]) and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated_count += 1\n        dominance_scores.append(-dominated_count)  # Higher score means less dominated\n\n    # Add diversity to selection\n    diversity_scores = [np.mean([np.linalg.norm(sol - other) for other in solutions]) for sol in solutions]\n    selection_scores = [dom * 0.7 + div * 0.3 for dom, div in zip(dominance_scores, diversity_scores)]\n    selected_idx = np.argmax(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: segment reversal and node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal (novel operator)\n    if n > 3:\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node swapping (novel operator)\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8966933705461448,
            1.1049444675445557
        ],
        "raw_score": [
            7.119999749165364,
            7.41150466127999
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive using weighted random sampling based on normalized objective values, then applies a hybrid local search combining adaptive segment reversal and probabilistic edge swaps to generate a feasible neighbor solution, prioritizing solutions with lower combined costs while ensuring the tour remains valid. The selection weights favor solutions with better normalized objectives, and the local search adaptively adjusts segment length and swap probability based on problem size.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection with weighted random sampling\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (1 + np.sum(normalized_costs, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with probabilistic length\n    if n > 3:\n        seg_length = min(random.randint(2, n//2), n-2)\n        start = random.randint(0, n-seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Probabilistic edge swaps with adaptive intensity\n    swap_prob = 0.3 if n > 20 else 0.5\n    if random.random() < swap_prob:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8918576688915671,
            0.22738558053970337
        ],
        "raw_score": [
            6.745697351573674,
            6.870386781264237
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top third of the archive (sorted by combined objective cost), then applies a hybrid local search: either randomly reinserting an edge or reversing a segment of the tour, ensuring feasibility by maintaining a valid TSP path. The selection prioritizes solutions with lower total cost, while the local search explores diverse neighborhood structures to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: randomly choose between edge insertion or segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7593220728994624,
            0.19668710231781006
        ],
        "raw_score": [
            5.831905830795691,
            5.995319237568243
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the top 20% of the archive (sorted by normalized objective sums) and applies a hybrid local search, randomly choosing between edge swaps (60% probability) and a novel node insertion strategy (40% probability) to generate feasible neighbor solutions. Edge swaps exchange two random edges, while node insertion removes a node and reinserts it at a random position, ensuring tour validity. The selection prioritizes solutions with better combined normalized objectives, while the local search diversifies exploration to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        normalized_archive = archive\n    else:\n        normalized_archive = [(sol, (obj[0]/max_obj1, obj[1]/max_obj2)) for sol, obj in archive]\n    sorted_archive = sorted(normalized_archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge swap or novel node insertion\n    if random.random() < 0.6:\n        # Edge swap: swap two random edges\n        i = random.randint(0, n - 2)\n        j = random.randint(0, n - 2)\n        if i != j:\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n    else:\n        # Novel node insertion: remove a node and insert it in a different position\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.819648273754423,
            0.22441494464874268
        ],
        "raw_score": [
            6.13544825475205,
            6.491666412397946
        ]
    },
    {
        "algorithm": "The algorithm implements an adaptive probabilistic selection strategy that prioritizes top solutions (top 3-5) with weighted probabilities (e.g., 0.7, 0.2, 0.1) and applies a hybrid local search operator (segment reversal + cross-segment swaps) with dynamic disruption rates (0.2 or 0.4) to explore neighborhoods while ensuring feasibility through permutation validation. It balances exploitation (focusing on high-potential solutions) and exploration (controlled disruption) to navigate the bi-objective TSP solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Probabilistic selection from top-k solutions\n    k = min(5, len(archive))\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = sorted_archive[:k]\n    weights = [0.7, 0.2, 0.1] * (k // 3) + [0.05] * (k % 3)\n    selected = random.choices(top_k, weights=weights, k=1)[0][0].copy()\n\n    # Step 2: Apply constrained hybrid operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n    disruption_rate = 0.2 if len(set([sum(obj) for _, obj in archive])) > 1 else 0.4\n\n    if random.random() < disruption_rate:\n        # Hybrid operator: small segment reversal + cross-segment swap\n        if n >= 4:\n            # Small segment reversal\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i <= 3:  # Limit disruption\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Cross-segment swap (constrained)\n            if n >= 6:\n                a, b, c, d = sorted(random.sample(range(n), 4))\n                if abs(b-a) == abs(d-c):  # Similar-length segments\n                    new_solution[a:b], new_solution[c:d] = new_solution[c:d], new_solution[a:b]\n    else:\n        # Standard edge swap\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Validate feasibility\n    if len(set(new_solution)) != len(selected):\n        return selected  # Revert if invalid\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8487701870973046,
            0.3124351501464844
        ],
        "raw_score": [
            6.8559313228961685,
            6.147794882567918
        ]
    }
]